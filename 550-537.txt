diff -r --exclude=.svn v550/app/controllers/devices_controller.rb v537/app/controllers/devices_controller.rb
404c404
<       @obj = Note.find_by_sql("select notes.id, notes.device_id, notes.notes, notes.description, users.email as userEmail, GetFiles(notes.id) as fileName, notes.created_at, notes.updated_at from notes inner join users on users.id = notes.user_id and users.deleted_at is null")
---
>       @obj = Note.find_by_sql("select notes.id, notes.device_id, notes.notes, notes.description, users.email as userEmail, GetFiles(notes.id) as fileName, notes.created_at, notes.updated_at from notes inner join users on users.id = notes.user_id")
407a408
> 
409a411
>     
diff -r --exclude=.svn v550/app/controllers/modbus_registers_controller.rb v537/app/controllers/modbus_registers_controller.rb
112c112
<     #    @register_and_groups = RegisterAndGroup.find_by_sql("select register_and_groups.id, register_and_groups.name, cust.register_group_id, register_and_groups.parent_id, modbus_registers.units from register_and_groups inner join (select register_and_groups.id, register_and_groups.register_group_id from register_and_groups where register_and_groups.register_group_id is not null) as cust on cust.id = register_and_groups.parent_id inner join modbus_registers on modbus_registers.id = register_and_groups.register_id where register_and_groups.deleted_at is null group by register_and_groups.id order by register_and_groups.id asc")
---
> #    @register_and_groups = RegisterAndGroup.find_by_sql("select register_and_groups.id, register_and_groups.name, cust.register_group_id, register_and_groups.parent_id, modbus_registers.units from register_and_groups inner join (select register_and_groups.id, register_and_groups.register_group_id from register_and_groups where register_and_groups.register_group_id is not null) as cust on cust.id = register_and_groups.parent_id inner join modbus_registers on modbus_registers.id = register_and_groups.register_id where register_and_groups.deleted_at is null group by register_and_groups.id order by register_and_groups.id asc")
119,131d118
<   def list_of_registers_for_highchart
<     @registers = RegisterAndGroup.find_by_sql("select register_and_groups.id, modbus_registers.id as rid, cust.register_group_id, modbus_registers.tag, modbus_registers.units from register_and_groups inner join (select register_and_groups.id, register_and_groups.register_group_id from register_and_groups where register_and_groups.register_group_id is not null and register_and_groups.deleted_at is null) as cust on cust.id = register_and_groups.parent_id inner join modbus_registers on modbus_registers.id = register_and_groups.register_id and modbus_registers.deleted_at is null where register_and_groups.deleted_at is null group by register_and_groups.id order by modbus_registers.id asc")
<     @res[:metaData][:fields] = [{:name => 'id', :type => 'int'}, {:name => 'rid', :type => 'int'}, {:name => 'register_group_id', :type => 'int'}, {:name => 'tag', :type => 'string'}, {:name => 'units', :type => 'string'}]
<     @res[:success] = true
< 		@res[:message] = 'Returned data'
< 		@res[:total] = @registers.count
< 		@res[:data]	 = @registers
< 		respond_with(@res, :status => :ok)
<     #respond_to do |format|
<     #  format.json { render :json => @register_and_groups }
<     #end
<   end
< 
diff -r --exclude=.svn v550/app/controllers/polling_schedule_controller.rb v537/app/controllers/polling_schedule_controller.rb
2c2
<   respond_to :json
---
>   respond_to :json, :html
16,62d15
<   def fields_to_display
<     @data = ActiveRecord::Base.connection.select("SET @pattern = '[^0-9A-Za-z ]';SELECT modbus_registers.id, REPLACE(REPLACE(LOWER(TRIM(BOTH ' ' FROM REGEX_REPLACE(@pattern, '', modbus_registers.tag))), '  ', ' '), ' ', '_') AS tag, modbus_registers.units FROM data_float INNER JOIN modbus_registers ON modbus_registers.id = data_float.register AND modbus_registers.deleted_at IS NULL GROUP BY modbus_registers.id;")
<     @res[:metaData][:fields] = [{:name => :id, :type => :int}, {:name => :tag, :type => :string}, {:name => :units, :type => :string}]
<     @res[:success] = true
<     @res[:message] = "Returned data"
<     @res[:total] = @data.count
<     @res[:data] = @data
<     respond_with(@res, :status => :ok)
<   end
< 
<   def data_to_display_graph
<     @data = ActiveRecord::Base.connection.select_sp("CALL GetHighchartData(#{params[:device_id].to_i});")
<     unless @data.blank?
<       @res[:metaData][:fields] = @data[0].keys()
<       if !params[:start].blank? and !params[:end].blank?
<         @data.collect! { |data|
<           data['date'].to_date < params[:start].to_date || (data['date'].to_date > params[:start].to_date && data['date'].to_date > params[:end].to_date)
<         }
<       elsif !params[:start].blank? and params[:end].blank?
<         @data = @data.collect! { |data|
<           data['date'].to_date < params[:start].to_date
<         }
<       elsif params[:start].blank? and !params[:end].blank?
<         @data.collect! { |data|
<           data['date'].to_date > params[:end].to_date
<         }
<       end
<     end
<     respond_to do |format|
<       format.json { render :json => @data }
<     end
<   end
< 
<   def data_to_display
<     @data = ActiveRecord::Base.connection.select_sp("CALL GetHighchartData(#{params[:device_id].to_i});")
<     @res[:metaData][:fields] = [{:name => 'id', :type => 'int'}, {:name => 'device_id', :type => 'int'}, {:name => 'date', :type => 'datetime'}]
<     unless @data.blank?
<       (@data[0].keys().sort-['id', 'device_id', 'date']).each{|key| @res[:metaData][:fields].concat([{:name => key, :type => 'float'}])}
<       @data = [@data.first] unless params[:limit].blank?
<     end
<     @res[:success] = true
<     @res[:message] = "Returned data"
<     @res[:total] = @data.count
<     @res[:data] = @data
<     respond_with(@res, :status => :ok)
<   end
< 
diff -r --exclude=.svn v550/app/controllers/register_groups_controller.rb v537/app/controllers/register_groups_controller.rb
251,256d250
<   def list_of_register_groups_for_highchart
<     @register_groups = RegisterGroup.find_by_sql("select register_groups.id, register_groups.name, register_groups.display_name, register_groups.device_type_id, register_groups.display_type, units.name as leftaxis, cust_u.name as rightaxis from register_groups inner join register_and_groups on register_groups.id = register_and_groups.register_group_id and register_and_groups.deleted_at is null and register_and_groups.device_type_id is null and register_and_groups.register_id is null inner join (select register_and_groups.id, register_and_groups.parent_id from register_and_groups where register_and_groups.deleted_at is null and register_and_groups.register_id is not null and register_and_groups.device_type_id is null and register_and_groups.register_group_id is null) as cust_rag on cust_rag.parent_id = register_and_groups.id left join units on units.id = register_groups.left_axis_unit_id and units.deleted_at is null left join (select units.id, units.name from units where units.deleted_at is null) as cust_u on cust_u.id = register_groups.right_axis_unit_id where register_groups.display_type != 'Read' and register_groups.display_type != 'Read/Write' and register_groups.display_type != 'Write' and register_groups.display_type != 'Display Dashboard - Table' and register_groups.display_type != 'Display Maps' and register_groups.display_type != '' and register_groups.deleted_at is null group by register_groups.id")
<     respond_to do |format|
<       format.json { render :json => @register_groups }
<     end
<   end
diff -r --exclude=.svn v550/app/views/devise/sessions/new.html.erb v537/app/views/devise/sessions/new.html.erb
2c2
<   body{font-family: verdana;}
---
> body {font-family: verdana;}
6,10c6,10
<   <h2>Sign in</h2>
<   <img width='503' height='329' src='/images/loginamci.jpg' alt='AMCi' />
<   <%= form_for(resource, :as => resource_name, :url => session_path(resource_name)) do |f| %>
<     <p><%= f.label :email %><br />
<       <%= f.text_field :email %></p>
---
> <h2>Sign in</h2>
> <img width='503' height='329' src='/images/loginamci.jpg' alt='AMCi'>
> <%= form_for(resource, :as => resource_name, :url => session_path(resource_name)) do |f| %>
>   <p><%= f.label :email %><br />
>   <%= f.text_field :email %></p>
12,13c12,13
<     <p><%= f.label :password %><br />
<       <%= f.password_field :password %></p>
---
>   <p><%= f.label :password %><br />
>   <%= f.password_field :password %></p>
15,17c15,17
<     <% if devise_mapping.rememberable? -%>
<       <p><%= f.check_box :remember_me %> <%= f.label :remember_me %></p>
<     <% end -%>
---
>   <% if devise_mapping.rememberable? -%>
>     <p><%= f.check_box :remember_me %> <%= f.label :remember_me %></p>
>   <% end -%>
19,21c19,21
<     <p><%= f.submit 'Sign in' %></p>
<   <% end %>
<   <%= render :partial => 'devise/shared/links' %>
---
>   <p><%= f.submit 'Sign in' %></p>
> <% end %>
> <%= render :partial => 'devise/shared/links' %>
diff -r --exclude=.svn v550/app/views/devise/shared/_links.erb v537/app/views/devise/shared/_links.erb
2c2
<   <%= link_to "Sign in", login_path %><br />
---
>   <%= link_to "Sign in", new_session_path(resource_name) %><br />
diff -r --exclude=.svn v550/app/views/layouts/amci.html.erb v537/app/views/layouts/amci.html.erb
47c47
<       if(!console || console === undefined){
---
>       if(console === undefined){
diff -r --exclude=.svn v550/config/routes.rb v537/config/routes.rb
132,134d131
<   match 'data-to-display-graph' => "polling_schedule#data_to_display_graph", :as => "data_to_display_graph"
<   match 'fields-to-display' => "polling_schedule#fields_to_display", :as => "fields_to_display"
<   match 'data-to-display' => "polling_schedule#data_to_display", :as => "data_to_display"
143d139
<   match 'list-of-register-groups-for-highchart' => "register_groups#list_of_register_groups_for_highchart", :as => "list_of_register_groups_for_highchart"
145d140
<   match 'list-of-registers-for-highchart' => "modbus_registers#list_of_registers_for_highchart", :as => "list_of_registers_for_highchart"
Only in v550/db/migrate: 20111115074838_create_function_regex_replace.rb
Only in v550/db/migrate: 20111115110033_create_stored_procedure_get_highchart_data.rb
diff -r --exclude=.svn v550/doc/README_FOR_APP v537/doc/README_FOR_APP
4,5c4
< rails runner 'require("db/migrate/20111115074838_create_function_regex_replace.rb").first.constantize.up'
< rails runner 'require("db/migrate/20111115110033_create_stored_procedure_get_highchart_data.rb").first.constantize.up'
---
> rails runner 'require("db/migrate/20111109122602_create_stored_procedure_get_registers_for_reporting.rb").first.constantize.up'
diff -r --exclude=.svn v550/public/highcharts/examples/line-ajax.htm v537/public/highcharts/examples/line-ajax.htm
3,13c3,13
<     <head>
<         <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<         <title>Highcharts Example</title>
< 
< 
<         <!-- 1. Add these JavaScript inclusions in the head of your page -->
<         <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<         <script type="text/javascript" src="../js/highcharts.js"></script>
< 
<         <!-- 1a) Optional: add a theme file -->
<         <!--
---
> 	<head>
> 		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
> 		<title>Highcharts Example</title>
> 		
> 		
> 		<!-- 1. Add these JavaScript inclusions in the head of your page -->
> 		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
> 		<script type="text/javascript" src="../js/highcharts.js"></script>
> 		
> 		<!-- 1a) Optional: add a theme file -->
> 		<!--
16,22d15
< 
<         <!-- 1b) Optional: the exporting module -->
<         <script type="text/javascript" src="../js/modules/exporting.js"></script>
< 
< 
<         <!-- 2. Add the JavaScript to initialize the chart on document ready -->
<         <script type="text/javascript">
24,25c17,25
<             var chart;
<             $(document).ready(function() {
---
> 		<!-- 1b) Optional: the exporting module -->
> 		<script type="text/javascript" src="../js/modules/exporting.js"></script>
> 		
> 		
> 		<!-- 2. Add the JavaScript to initialize the chart on document ready -->
> 		<script type="text/javascript">
> 		
> 			var chart;
> 			$(document).ready(function() {
27,28c27,28
<                 // define the options
<                 var options = {
---
> 				// define the options
> 				var options = {
30,132c30,132
<                     chart: {
<                         renderTo: 'container'
<                     },
< 					
<                     title: {
<                         text: 'Daily visits at www.highcharts.com'
<                     },
< 					
<                     subtitle: {
<                         text: 'Source: Google Analytics'
<                     },
< 					
<                     xAxis: {
<                         type: 'datetime',
<                         tickInterval: 7 * 24 * 3600 * 1000, // one week
<                         tickWidth: 0,
<                         gridLineWidth: 1,
<                         labels: {
<                             align: 'left',
<                             x: 3,
<                             y: -3
<                         }
<                     },
< 					
<                     yAxis: [{ // left y axis
<                             title: {
<                                 text: null
<                             },
<                             labels: {
<                                 align: 'left',
<                                 x: 3,
<                                 y: 16,
<                                 formatter: function() {
<                                     return Highcharts.numberFormat(this.value, 0);
<                                 }
<                             },
<                             showFirstLabel: false
<                         }, { // right y axis
<                             linkedTo: 0,
<                             gridLineWidth: 0,
<                             opposite: true,
<                             title: {
<                                 text: null
<                             },
<                             labels: {
<                                 align: 'right',
<                                 x: -3,
<                                 y: 16,
<                                 formatter: function() {
<                                     return Highcharts.numberFormat(this.value, 0);
<                                 }
<                             },
<                             showFirstLabel: false
<                         }],
< 					
<                     legend: {
<                         align: 'left',
<                         verticalAlign: 'top',
<                         y: 20,
<                         floating: true,
<                         borderWidth: 0
<                     },
< 					
<                     tooltip: {
<                         shared: true,
<                         crosshairs: true
<                     },
< 					
<                     plotOptions: {
<                         series: {
<                             cursor: 'pointer',
<                             point: {
<                                 events: {
<                                     click: function() {
<                                         hs.htmlExpand(null, {
<                                             pageOrigin: {
<                                                 x: this.pageX,
<                                                 y: this.pageY
<                                             },
<                                             headingText: this.series.name,
<                                             maincontentText: Highcharts.dateFormat('%A, %b %e, %Y', this.x) +':<br/> '+
<                                                 this.y +' visits',
<                                             width: 200
<                                         });
<                                     }
<                                 }
<                             },
<                             marker: {
<                                 lineWidth: 1
<                             }
<                         }
<                     },
< 					
<                     series: [{
<                             name: 'All visits',
<                             lineWidth: 4,
<                             marker: {
<                                 radius: 4
<                             }
<                         }, {
<                             name: 'New visitors'
<                         }]
<                 }
---
> 					chart: {
> 						renderTo: 'container'
> 					},
> 					
> 					title: {
> 						text: 'Daily visits at www.highcharts.com'
> 					},
> 					
> 					subtitle: {
> 						text: 'Source: Google Analytics'
> 					},
> 					
> 					xAxis: {
> 						type: 'datetime',
> 						tickInterval: 7 * 24 * 3600 * 1000, // one week
> 						tickWidth: 0,
> 						gridLineWidth: 1,
> 						labels: {
> 							align: 'left',
> 							x: 3,
> 							y: -3 
> 						}
> 					},
> 					
> 					yAxis: [{ // left y axis
> 						title: {
> 							text: null
> 						},
> 						labels: {
> 							align: 'left',
> 							x: 3,
> 							y: 16,
> 							formatter: function() {
> 								return Highcharts.numberFormat(this.value, 0);
> 							}
> 						},
> 						showFirstLabel: false
> 					}, { // right y axis
> 						linkedTo: 0,
> 						gridLineWidth: 0,
> 						opposite: true,
> 						title: {
> 							text: null
> 						},
> 						labels: {
> 							align: 'right',
> 							x: -3,
> 							y: 16,
> 							formatter: function() {
> 								return Highcharts.numberFormat(this.value, 0);
> 							}
> 						},
> 						showFirstLabel: false
> 					}],
> 					
> 					legend: {
> 						align: 'left',
> 						verticalAlign: 'top',
> 						y: 20,
> 						floating: true,
> 						borderWidth: 0
> 					},
> 					
> 					tooltip: {
> 						shared: true,
> 						crosshairs: true
> 					},
> 					
> 					plotOptions: {
> 						series: {
> 							cursor: 'pointer',
> 							point: {
> 								events: {
> 									click: function() {
> 										hs.htmlExpand(null, {
> 											pageOrigin: {
> 												x: this.pageX, 
> 												y: this.pageY
> 											},
> 											headingText: this.series.name,
> 											maincontentText: Highcharts.dateFormat('%A, %b %e, %Y', this.x) +':<br/> '+ 
> 												this.y +' visits',
> 											width: 200
> 										});
> 									}
> 								}
> 							},
> 							marker: {
> 								lineWidth: 1
> 							}
> 						}
> 					},
> 					
> 					series: [{
> 						name: 'All visits',
> 						lineWidth: 4,
> 						marker: {
> 							radius: 4
> 						}
> 					}, {
> 						name: 'New visitors'
> 					}]
> 				}
134,141c134,141
<                 // Load data asynchronously using jQuery. On success, add the data
<                 // to the options and initiate the chart.
<                 // This data is obtained by exporting a GA custom report to TSV.
<                 // http://api.jquery.com/jQuery.get/
<                 jQuery.get('/demo/analytics.tsv', null, function(tsv) {
<                     var lines = [],
<                     listen = false,
<                     date,
---
> 				// Load data asynchronously using jQuery. On success, add the data
> 				// to the options and initiate the chart.
> 				// This data is obtained by exporting a GA custom report to TSV.
> 				// http://api.jquery.com/jQuery.get/
> 				jQuery.get('/demo/analytics.tsv', null, function(tsv) {
> 					var lines = [],
> 						listen = false,
> 						date,
143,145c143,145
<                     // set up the two data series
<                     allVisits = [],
<                     newVisitors = [];
---
> 						// set up the two data series
> 						allVisits = [],
> 						newVisitors = [];
147,150c147,150
<                     try {
<                         // split the data return into lines and parse them
<                         tsv = tsv.split(/\n/g);
<                         jQuery.each(tsv, function(i, line) {
---
> 					try {
> 					// split the data return into lines and parse them
> 					tsv = tsv.split(/\n/g);
> 					jQuery.each(tsv, function(i, line) {
152,157c152,157
<                             // listen for data lines between the Graph and Table headers
<                             if (tsv[i - 3] == '# Graph') {
<                                 listen = true;
<                             } else if (line == '' || line.charAt(0) == '#') {
<                                 listen = false;
<                             }
---
> 						// listen for data lines between the Graph and Table headers
> 						if (tsv[i - 3] == '# Graph') {
> 							listen = true;
> 						} else if (line == '' || line.charAt(0) == '#') {
> 							listen = false;
> 						}
159,162c159,162
<                             // all data lines start with a double quote
<                             if (listen) {
<                                 line = line.split(/\t/);
<                                 date = Date.parse(line[0] +' UTC');
---
> 						// all data lines start with a double quote
> 						if (listen) {
> 							line = line.split(/\t/);
> 							date = Date.parse(line[0] +' UTC');
164,176c164,176
<                                 allVisits.push([
<                                     date,
<                                     parseInt(line[1].replace(',', ''), 10)
<                                 ]);
<                                 newVisitors.push([
<                                     date,
<                                     parseInt(line[2].replace(',', ''), 10)
<                                 ]);
<                             }
<                         });
<                     } catch (e) { alert(e.message) }
<                     options.series[0].data = allVisits;
<                     options.series[1].data = newVisitors;
---
> 							allVisits.push([
> 								date, 
> 								parseInt(line[1].replace(',', ''), 10)
> 							]);
> 							newVisitors.push([
> 								date, 
> 								parseInt(line[2].replace(',', ''), 10)
> 							]);
> 						}
> 					});
> 					} catch (e) { alert(e.message) }
> 					options.series[0].data = allVisits;
> 					options.series[1].data = newVisitors;
178,179c178,181
<                     chart = new Highcharts.Chart(options);
<                 });
---
> 					chart = new Highcharts.Chart(options);
> 				});
> 				
> 			});
181c183,194
<             });
---
> 		</script>
> 		
> 		<!-- Additional files for the Highslide popup effect -->
> 		<script type="text/javascript" src="http://www.highcharts.com/highslide/highslide-full.min.js"></script>
> 		<script type="text/javascript" src="http://www.highcharts.com/highslide/highslide.config.js" charset="utf-8"></script>
> 		<link rel="stylesheet" type="text/css" href="http://www.highcharts.com/highslide/highslide.css" />
> 	</head>
> 	<body>
> 		
> 		<!-- 3. Add the container -->
> 		<div id="container" style="width: 800px; height: 400px; margin: 0 auto"></div>
> 		
183,196c196
<         </script>
< 
<         <!-- Additional files for the Highslide popup effect -->
<         <script type="text/javascript" src="http://www.highcharts.com/highslide/highslide-full.min.js"></script>
<         <script type="text/javascript" src="http://www.highcharts.com/highslide/highslide.config.js" charset="utf-8"></script>
<         <link rel="stylesheet" type="text/css" href="http://www.highcharts.com/highslide/highslide.css" />
<     </head>
<     <body>
< 
<         <!-- 3. Add the container -->
<         <div id="container" style="width: 800px; height: 400px; margin: 0 auto"></div>
< 
< 
<     </body>
---
> 	</body>
diff -r --exclude=.svn v550/public/highcharts/js/Ext.ux.HighChart.js v537/public/highcharts/js/Ext.ux.HighChart.js
57c57
<         for(var i = 0; i < series.length; i++){
---
>         for (var i = 0; i < series.length; i++) {
59,63c59,62
<             if(!serie.serieCls){
<                 if(serie.type != null || this.defaultSerieType != null){
<                     cls = Ext.ux.HighChart.Series.get(serie.type != null ? serie.type : this.defaultSerieType, serie.unit)
<                 }
<                 else{
---
>             if (!serie.serieCls) {
>                 if (serie.type != null || this.defaultSerieType != null) {
>                     cls = Ext.ux.HighChart.Series.get(serie.type != null ? serie.type : this.defaultSerieType)
>                 } else {
66,68c65,66
<                 serieObject = new cls(serie);
<             }
<             else{
---
>                 serieObject = new cls(serie)
>             } else {
180,181c178,180
<     afterRender: function(){
<         if(this.store){
---
>     afterRender: function() {
> 
>         if (this.store){
451c450
<         for(var i = 0; i < records.length; i++){
---
>         for (var i = 0; i < records.length; i++) {
453c452
<             if(i == records.length - 1){
---
>             if (i == records.length - 1){
456c455
<             if(this.xField){
---
>             if (this.xField) {
459,460c458,459
<             //alert('this.chart : '+JSON.stringify(this.chart));
<             for(var x = 0; x < this.chart.series.length; x++){
---
> 
>             for (var x = 0; x < this.chart.series.length; x++) {
528c527
<     
---
> 
548c547
<     if(!config.data){
---
>     if (!config.data){
551,553d549
<     if(!config.unit){
<         config.unit = null;
<     }
diff -r --exclude=.svn v550/public/highcharts/js/highcharts.js v537/public/highcharts/js/highcharts.js
13,14c13,14
<     }
<     function la(a,b){
---
>         }
>         function la(a,b){
16,17c16,17
<     }
<     function Qb(a){
---
>         }
>         function Qb(a){
19,20c19,20
<     }
<     function Kb(a){
---
>         }
>         function Kb(a){
22,23c22,23
<     }
<     function ec(a){
---
>         }
>         function ec(a){
25,26c25,26
<     }
<     function rc(a,b){
---
>         }
>         function rc(a,b){
31,33c31,33
<     }
<     function J(a){
<         return a!==Ua&&a!==null
---
>         }
>         function J(a){
>     return a!==Ua&&a!==null
36,39c36,39
<         var d,e;
<         if(Qb(b))if(J(c))a.setAttribute(b,c);
<             else{
<                 if(a&&a.getAttribute)e=a.getAttribute(b)
---
>     var d,e;
>     if(Qb(b))if(J(c))a.setAttribute(b,c);
>         else{
>         if(a&&a.getAttribute)e=a.getAttribute(b)
41c41
<             b[d]);return e
---
>         b[d]);return e
44,45c44,45
<         if(!a||a.constructor!==Array)a=[a];
<         return a
---
>     if(!a||a.constructor!==Array)a=[a];
>     return a
48,51c48,52
<         var a=arguments,b,c,d=a.length;
<         for(b=0;b<d;b++){
<             c=a[b];
<             if(typeof c!=="undefined"&&c!==null)return c
---
>     var a=arguments,b,c,d=a.length;
>     for(b=0;b<d;b++){
>         c=a[b];
>         if(typeof c!=="undefined"&&c!==null)return c
>             }
53d53
<     }
55,56c55,56
<         var b="",c;
<         for(c in a)b+=c+":"+a[c]+";";return b
---
>     var b="",c;
>     for(c in a)b+=c+":"+a[c]+";";return b
59,60c59,60
<         if(Cc)if(b&&b.opacity!==Ua)b.filter="alpha(opacity="+b.opacity*100+")";
<         pa(a.style,b)
---
>     if(Cc)if(b&&b.opacity!==Ua)b.filter="alpha(opacity="+b.opacity*100+")";
>     pa(a.style,b)
63,72c63,72
<         a=wa.createElement(a);
<         b&&pa(a,b);
<         e&&La(a,{
<             padding:0,
<             border:jb,
<             margin:0
<         });
<         c&&La(a,c);
<         d&&d.appendChild(a);
<         return a
---
>     a=wa.createElement(a);
>     b&&pa(a,b);
>     e&&La(a,{
>         padding:0,
>         border:jb,
>         margin:0
>     });
>     c&&La(a,c);
>     d&&d.appendChild(a);
>     return a
75,76c75,76
<         b){
<         var c=function(){};
---
>     b){
>     var c=function(){};
78,80c78,80
<         c.prototype=new a;
<         pa(c.prototype,b);
<         return c
---
>     c.prototype=new a;
>     pa(c.prototype,b);
>     return c
83,91c83,91
<         var e=Va.lang;
<         a=a;
<         var f=isNaN(b=db(b))?2:b;
<         b=c===undefined?e.decimalPoint:c;
<         d=d===undefined?e.thousandsSep:d;
<         e=a<0?"-":"";
<         c=String(la(a=db(+a||0).toFixed(f)));
<         var g=c.length>3?c.length%3:0;
<         return e+(g?c.substr(0,g)+d:"")+c.substr(g).replace(/(\d{3})(?=\d)/g,"$1"+d)+(f?b+db(a-c).toFixed(f).slice(2):"")
---
>     var e=Va.lang;
>     a=a;
>     var f=isNaN(b=db(b))?2:b;
>     b=c===undefined?e.decimalPoint:c;
>     d=d===undefined?e.thousandsSep:d;
>     e=a<0?"-":"";
>     c=String(la(a=db(+a||0).toFixed(f)));
>     var g=c.length>3?c.length%3:0;
>     return e+(g?c.substr(0,g)+d:"")+c.substr(g).replace(/(\d{3})(?=\d)/g,"$1"+d)+(f?b+db(a-c).toFixed(f).slice(2):"")
94c94
<         Dc=B(a,b.animation)
---
>     Dc=B(a,b.animation)
97,100c97,100
<         var a=Va.global.useUTC;
<         Ec=a?Date.UTC:function(b,c,d,e,f,g){
<             return(new Date(b,
<                 c,B(d,1),B(e,0),B(f,0),B(g,0))).getTime()
---
>     var a=Va.global.useUTC;
>     Ec=a?Date.UTC:function(b,c,d,e,f,g){
>         return(new Date(b,
>             c,B(d,1),B(e,0),B(f,0),B(g,0))).getTime()
103,113c103,113
<         dd=a?"getUTCMinutes":"getMinutes";
<         ed=a?"getUTCHours":"getHours";
<         fd=a?"getUTCDay":"getDay";
<         tc=a?"getUTCDate":"getDate";
<         Fc=a?"getUTCMonth":"getMonth";
<         Gc=a?"getUTCFullYear":"getFullYear";
<         Dd=a?"setUTCMinutes":"setMinutes";
<         Ed=a?"setUTCHours":"setHours";
<         gd=a?"setUTCDate":"setDate";
<         Fd=a?"setUTCMonth":"setMonth";
<         Gd=a?"setUTCFullYear":"setFullYear"
---
>     dd=a?"getUTCMinutes":"getMinutes";
>     ed=a?"getUTCHours":"getHours";
>     fd=a?"getUTCDay":"getDay";
>     tc=a?"getUTCDate":"getDate";
>     Fc=a?"getUTCMonth":"getMonth";
>     Gc=a?"getUTCFullYear":"getFullYear";
>     Dd=a?"setUTCMinutes":"setMinutes";
>     Ed=a?"setUTCHours":"setHours";
>     gd=a?"setUTCDate":"setDate";
>     Fd=a?"setUTCMonth":"setMonth";
>     Gd=a?"setUTCFullYear":"setFullYear"
116,118c116,118
<         Ic||(Ic=ib(Rb));
<         a&&Ic.appendChild(a);
<         Ic.innerHTML=""
---
>     Ic||(Ic=ib(Rb));
>     a&&Ic.appendChild(a);
>     Ic.innerHTML=""
122,128c122,128
<         function c(m,i){
<             function y(k,
<                 o){
<                 this.pos=k;
<                 this.minor=o;
<                 this.isNew=true;
<                 o||this.addLabel()
---
>     function c(m,i){
>         function y(k,
>             o){
>             this.pos=k;
>             this.minor=o;
>             this.isNew=true;
>             o||this.addLabel()
131,133c131,133
<                 if(k){
<                     this.options=k;
<                     this.id=k.id
---
>             if(k){
>                 this.options=k;
>                 this.id=k.id
138,145c138,145
<                 this.isNegative=o;
<                 this.options=k;
<                 this.x=r;
<                 this.alignOptions={
<                     align:k.align||(qa?o?"left":"right":"center"),
<                     verticalAlign:k.verticalAlign||(qa?"middle":o?"bottom":"top"),
<                     y:B(k.y,qa?4:o?14:-6),
<                     x:B(k.x,qa?o?-6:6:0)
---
>             this.isNegative=o;
>             this.options=k;
>             this.x=r;
>             this.alignOptions={
>                 align:k.align||(qa?o?"left":"right":"center"),
>                 verticalAlign:k.verticalAlign||(qa?"middle":o?"bottom":"top"),
>                 y:B(k.y,qa?4:o?14:-6),
>                 x:B(k.x,qa?o?-6:6:0)
148c148
<                 this.textAlign=k.textAlign||(qa?o?"right":"left":"center")
---
>             this.textAlign=k.textAlign||(qa?o?"right":"left":"center")
151,161c151,161
<                 var k=[],o=[],r;
<                 T=ra=null;
<                 Da=[];
<                 t(Ga,function(q){
<                     r=false;
<                     t(["xAxis","yAxis"],
<                         function(ma){
<                             if(q.isCartesian&&(ma==="xAxis"&&Ea||ma==="yAxis"&&!Ea)&&(q.options[ma]===i.index||q.options[ma]===Ua&&i.index===0)){
<                                 q[ma]=w;
<                                 Da.push(q);
<                                 r=true
---
>             var k=[],o=[],r;
>             T=ra=null;
>             Da=[];
>             t(Ga,function(q){
>                 r=false;
>                 t(["xAxis","yAxis"],
>                     function(ma){
>                         if(q.isCartesian&&(ma==="xAxis"&&Ea||ma==="yAxis"&&!Ea)&&(q.options[ma]===i.index||q.options[ma]===Ua&&i.index===0)){
>                             q[ma]=w;
>                             Da.push(q);
>                             r=true
164,182c164,177
<                     if(!q.visible&&u.ignoreHiddenSeries)r=false;
<                     if(r){
<                         var A,U,F,V,Aa;
<                         if(!Ea){
<                             A=q.options.stacking;
<                             Kc=A==="percent";
<                             if(A){
<                                 V=q.type+B(q.options.stack,"");
<                                 Aa="-"+V;
<                                 q.stackKey=V;
<                                 U=k[V]||[];
<                                 k[V]=U;
<                                 F=o[Aa]||[];
<                                 o[Aa]=F
<                             }
<                             if(Kc){
<                                 T=0;
<                                 ra=99
<                             }
---
>             if(!q.visible&&u.ignoreHiddenSeries)r=false;
>                 if(r){
>                 var A,U,F,V,Aa;
>                 if(!Ea){
>                     A=q.options.stacking;
>                     Kc=A==="percent";
>                     if(A){
>                         V=q.type+B(q.options.stack,"");
>                         Aa="-"+V;
>                         q.stackKey=V;
>                         U=k[V]||[];
>                         k[V]=U;
>                         F=o[Aa]||[];
>                         o[Aa]=F
184,211c179,181
<                         if(q.isCartesian){
<                             t(q.data,function(ma){
<                                 var s=ma.x,W=ma.y,$=W<0,ga=$?F:U,zb=$?Aa:V;
<                                 if(T===null)T=ra=ma[ha];
<                                 if(Ea)if(s>
<                                     ra)ra=s;
<                                     else{
<                                         if(s<T)T=s
<                                     }else if(J(W)){
<                                     if(A)ga[s]=J(ga[s])?ga[s]+W:W;
<                                     W=ga?ga[s]:W;
<                                     ma=B(ma.low,W);
<                                     if(!Kc)if(W>ra)ra=W;
<                                         else if(ma<T)T=ma;
<                                     if(A){
<                                         v[zb]||(v[zb]={});
<                                         v[zb][s]||(v[zb][s]=new R(i.stackLabels,$,s));
<                                         v[zb][s].setTotal(W)
<                                     }
<                                 }
<                             });
<                             if(/(area|column|bar)/.test(q.type)&&!Ea)if(T>=0){
<                                 T=0;
<                                 Id=true
<                             }else if(ra<0){
<                                 ra=0;
<                                 Jd=true
<                             }
---
>                         if(Kc){
>                         T=0;
>                         ra=99
214,402c184,189
<                 })
<             }
<             function N(k,o){
<                 var r,q;
<                 Cb=o?1:ta.pow(10,kb(ta.log(k)/ta.LN10));
<                 r=k/Cb;
<                 if(!o){
<                     o=[1,2,2.5,5,10];
<                     if(i.allowDecimals===false||D)if(Cb===1)o=[1,2,5,10];
<                         else if(Cb<=0.1)o=[1/Cb]
<                 }
<                 for(q=
<                     0;q<o.length;q++){
<                     k=o[q];
<                     if(r<=(o[q]+(o[q+1]||o[q]))/2)break
<                 }
<                 k*=Cb;
<                 return k
<             }
<             function ba(k){
<                 var o;
<                 o=k;
<                 Cb=B(Cb,ta.pow(10,kb(ta.log(Qa)/ta.LN10)));
<                 if(Cb<1){
<                     o=X(1/Cb)*10;
<                     o=X(k*o)/o
<                 }
<                 return o
<             }
<             function Ka(){
<                 var k,o,r,q,A=i.tickInterval,U=i.tickPixelInterval;
<                 k=i.maxZoom||(Ea&&!J(i.min)&&!J(i.max)?qb(m.smallestInterval*5,ra-T):null);
<                 oa=z?Ba:xa;
<                 if(Sb){
<                     r=m[Ea?"xAxis":"yAxis"][i.linkedTo];
<                     q=r.getExtremes();
<                     aa=B(q.min,q.dataMin);
<                     ca=B(q.max,q.dataMax)
<                 }else{
<                     aa=B(Ha,i.min,T);
<                     ca=B(Ma,i.max,ra)
<                 }
<                 if(D){
<                     aa=ta.log(aa)/
<                     ta.LN10;
<                     ca=ta.log(ca)/ta.LN10
<                 }
<                 if(ca-aa<k){
<                     q=(k-ca+aa)/2;
<                     aa=Fa(aa-q,B(i.min,aa-q),T);
<                     ca=qb(aa+k,B(i.max,aa+k),ra)
<                 }
<                 if(!Wa&&!Kc&&!Sb&&J(aa)&&J(ca)){
<                     k=ca-aa||1;
<                     if(!J(i.min)&&!J(Ha)&&Kd&&(T<0||!Id))aa-=k*Kd;
<                     if(!J(i.max)&&!J(Ma)&&Ld&&(ra>0||!Jd))ca+=k*Ld
<                 }
<                 Qa=aa===ca?1:Sb&&!A&&U===r.options.tickPixelInterval?r.tickInterval:B(A,Wa?1:(ca-aa)*U/oa);
<                 if(!E&&!J(i.tickInterval))Qa=N(Qa);
<                 w.tickInterval=Qa;
<                 Lc=i.minorTickInterval==="auto"&&Qa?Qa/5:i.minorTickInterval;
<                 if(E){
<                     ua=[];
<                     A=Va.global.useUTC;
<                     var F=1E3/rb,V=6E4/
<                     rb,Aa=36E5/rb;
<                     U=864E5/rb;
<                     k=6048E5/rb;
<                     q=2592E6/rb;
<                     var ma=31556952E3/rb,s=[["second",F,[1,2,5,10,15,30]],["minute",V,[1,2,5,10,15,30]],["hour",Aa,[1,2,3,4,6,8,12]],["day",U,[1,2]],["week",k,[1,2]],["month",q,[1,2,3,4,6]],["year",ma,null]],W=s[6],$=W[1],ga=W[2];
<                     for(r=0;r<s.length;r++){
<                         W=s[r];
<                         $=W[1];
<                         ga=W[2];
<                         if(s[r+1])if(Qa<=($*ga[ga.length-1]+s[r+1][1])/2)break
<                     }
<                     if($===ma&&Qa<5*$)ga=[1,2,5];
<                     s=N(Qa/$,ga);
<                     ga=new Date(aa*rb);
<                     ga.setMilliseconds(0);
<                     if($>=F)ga.setSeconds($>=V?0:s*kb(ga.getSeconds()/s));
<                     if($>=
<                         V)ga[Dd]($>=Aa?0:s*kb(ga[dd]()/s));
<                     if($>=Aa)ga[Ed]($>=U?0:s*kb(ga[ed]()/s));
<                     if($>=U)ga[gd]($>=q?1:s*kb(ga[tc]()/s));
<                     if($>=q){
<                         ga[Fd]($>=ma?0:s*kb(ga[Fc]()/s));
<                         o=ga[Gc]()
<                     }
<                     if($>=ma){
<                         o-=o%s;
<                         ga[Gd](o)
<                     }
<                     $===k&&ga[gd](ga[tc]()-ga[fd]()+i.startOfWeek);
<                     r=1;
<                     o=ga[Gc]();
<                     F=ga.getTime()/rb;
<                     V=ga[Fc]();
<                     for(Aa=ga[tc]();F<ca&&r<Ba;){
<                         ua.push(F);
<                         if($===ma)F=Ec(o+r*s,0)/rb;
<                         else if($===q)F=Ec(o,V+r*s)/rb;
<                         else if(!A&&($===U||$===k))F=Ec(o,V,Aa+r*s*($===U?1:7));else F+=$*s;
<                         r++
<                     }
<                     ua.push(F);
<                     Mc=i.dateTimeLabelFormats[W[0]]
<                 }else{
<                     r=
<                     ba(kb(aa/Qa)*Qa);
<                     o=ba(hd(ca/Qa)*Qa);
<                     ua=[];
<                     for(r=ba(r);r<=o;){
<                         ua.push(r);
<                         r=ba(r+Qa)
<                     }
<                 }
<                 if(!Sb){
<                     if(Wa||Ea&&m.hasColumn){
<                         o=(Wa?1:Qa)*0.5;
<                         if(Wa||!J(B(i.min,Ha)))aa-=o;
<                         if(Wa||!J(B(i.max,Ma)))ca+=o
<                     }
<                     o=ua[0];
<                     r=ua[ua.length-1];
<                     if(i.startOnTick)aa=o;else aa>o&&ua.shift();
<                     if(i.endOnTick)ca=r;else ca<r&&ua.pop();
<                     Lb||(Lb={
<                         x:0,
<                         y:0
<                     });
<                     if(!E&&ua.length>Lb[ha])Lb[ha]=ua.length
<                 }
<             }
<             function za(){
<                 var k,o;
<                 Db=aa;
<                 Md=ca;
<                 na();
<                 Ka();
<                 fb=va;
<                 va=oa/(ca-aa||1);
<                 if(!Ea)for(k in v)for(o in v[k])v[k][o].cum=v[k][o].total;if(!w.isDirty)w.isDirty=
<                     aa!==Db||ca!==Md
<             }
<             function Na(k){
<                 k=(new x(k)).render();
<                 Tb.push(k);
<                 return k
<             }
<             function Oa(){
<                 var k=i.title,o=i.stackLabels,r=i.alternateGridColor,q=i.lineWidth,A,U,F=m.hasRendered,V=F&&J(Db)&&!isNaN(Db);
<                 A=Da.length&&J(aa)&&J(ca);
<                 oa=z?Ba:xa;
<                 va=oa/(ca-aa||1);
<                 eb=z?Z:sb;
<                 if(A||Sb){
<                     if(Lc&&!Wa)for(A=aa+(ua[0]-aa)%Lc;A<=ca;A+=Lc){
<                         ac[A]||(ac[A]=new y(A,true));
<                         V&&ac[A].isNew&&ac[A].render(null,true);
<                         ac[A].isActive=true;
<                         ac[A].render()
<                     }
<                     t(ua,function(s,W){
<                         if(!Sb||s>=aa&&s<=ca){
<                             V&&tb[s].isNew&&tb[s].render(W,true);
<                             tb[s].isActive=true;
<                             tb[s].render(W)
<                         }
<                     });
<                     r&&t(ua,function(s,W){
<                         if(W%2===0&&s<ca){
<                             gc[s]||(gc[s]=new x);
<                             gc[s].options={
<                                 from:s,
<                                 to:ua[W+1]!==Ua?ua[W+1]:ca,
<                                 color:r
<                             };
< 
<                             gc[s].render();
<                             gc[s].isActive=true
<                         }
<                     });
<                     F||t((i.plotLines||[]).concat(i.plotBands||[]),function(s){
<                         Tb.push((new x(s)).render())
<                     })
<                 }
<                 t([tb,ac,gc],function(s){
<                     for(var W in s)if(s[W].isActive)s[W].isActive=false;
---
>                 if(q.isCartesian){
>                 t(q.data,function(ma){
>                     var s=ma.x,W=ma.y,$=W<0,ga=$?F:U,zb=$?Aa:V;
>                     if(T===null)T=ra=ma[ha];
>                     if(Ea)if(s>
>                         ra)ra=s;
404,405c191,202
<                             s[W].destroy();
<                             delete s[W]
---
>                         if(s<T)T=s
>                             }else if(J(W)){
>                         if(A)ga[s]=J(ga[s])?ga[s]+W:W;
>                         W=ga?ga[s]:W;
>                         ma=B(ma.low,W);
>                         if(!Kc)if(W>ra)ra=W;
>                             else if(ma<T)T=ma;
>                         if(A){
>                             v[zb]||(v[zb]={});
>                             v[zb][s]||(v[zb][s]=new R(i.stackLabels,$,s));
>                             v[zb][s].setTotal(W)
>                             }
408,446c205,210
<                 if(q){
<                     A=Z+(Ia?Ba:0)+M;
<                     U=Ra-sb-(Ia?xa:0)+M;
<                     A=da.crispLine([Za,z?Z:A,z?U:ea,Ja,z?Xa-Eb:A,z?U:Ra-sb],q);
<                     if(ja)ja.animate({
<                         d:A
<                     });
<                     else ja=da.path(A).attr({
<                         stroke:i.lineColor,
<                         "stroke-width":q,
<                         zIndex:7
<                     }).add()
<                 }
<                 if(w.axisTitle){
<                     A=z?Z:ea;
<                     q=la(k.style.fontSize||12);
<                     A={
<                         low:A+(z?0:oa),
<                         middle:A+oa/2,
<                         high:A+(z?oa:0)
<                     }
<                     [k.align];
<                     q=(z?ea+xa:Z)+(z?1:-1)*(Ia?-1:1)*id+(Y===2?q:0);
<                     w.axisTitle[F?"animate":"attr"]({
<                         x:z?A:q+(Ia?Ba:0)+M+(k.x||0),
<                         y:z?q-(Ia?xa:0)+M:A+(k.y||0)
<                     })
<                 }
<                 if(o&&o.enabled){
<                     var Aa,ma;
<                     o=w.stackTotalGroup;
<                     if(!o)w.stackTotalGroup=o=da.g("stack-labels").attr({
<                         visibility:ub,
<                         zIndex:6
<                     }).translate(Z,ea).add();
<                     for(Aa in v){
<                         k=v[Aa];
<                         for(ma in k)k[ma].render(o)
<                     }
---
>             if(/(area|column|bar)/.test(q.type)&&!Ea)if(T>=0){
>                 T=0;
>                 Id=true
>                 }else if(ra<0){
>                 ra=0;
>                 Jd=true
448,449d211
<                 w.isDirty=
<                 false
451,452c213,328
<             function Ya(k){
<                 for(var o=Tb.length;o--;)Tb[o].id===k&&Tb[o].destroy()
---
>         }
> })
> }
> function N(k,o){
>     var r,q;
>     Cb=o?1:ta.pow(10,kb(ta.log(k)/ta.LN10));
>     r=k/Cb;
>     if(!o){
>         o=[1,2,2.5,5,10];
>         if(i.allowDecimals===false||D)if(Cb===1)o=[1,2,5,10];
>             else if(Cb<=0.1)o=[1/Cb]
>             }
>             for(q=
>         0;q<o.length;q++){
>         k=o[q];
>         if(r<=(o[q]+(o[q+1]||o[q]))/2)break
>     }
>     k*=Cb;
>     return k
>     }
>     function ba(k){
>     var o;
>     o=k;
>     Cb=B(Cb,ta.pow(10,kb(ta.log(Qa)/ta.LN10)));
>     if(Cb<1){
>         o=X(1/Cb)*10;
>         o=X(k*o)/o
>         }
>         return o
>     }
>     function Ka(){
>     var k,o,r,q,A=i.tickInterval,U=i.tickPixelInterval;
>     k=i.maxZoom||(Ea&&!J(i.min)&&!J(i.max)?qb(m.smallestInterval*5,ra-T):null);
>     oa=z?Ba:xa;
>     if(Sb){
>         r=m[Ea?"xAxis":"yAxis"][i.linkedTo];
>         q=r.getExtremes();
>         aa=B(q.min,q.dataMin);
>         ca=B(q.max,q.dataMax)
>         }else{
>         aa=B(Ha,i.min,T);
>         ca=B(Ma,i.max,ra)
>         }
>         if(D){
>         aa=ta.log(aa)/
>         ta.LN10;
>         ca=ta.log(ca)/ta.LN10
>         }
>         if(ca-aa<k){
>         q=(k-ca+aa)/2;
>         aa=Fa(aa-q,B(i.min,aa-q),T);
>         ca=qb(aa+k,B(i.max,aa+k),ra)
>         }
>         if(!Wa&&!Kc&&!Sb&&J(aa)&&J(ca)){
>         k=ca-aa||1;
>         if(!J(i.min)&&!J(Ha)&&Kd&&(T<0||!Id))aa-=k*Kd;
>         if(!J(i.max)&&!J(Ma)&&Ld&&(ra>0||!Jd))ca+=k*Ld
>             }
>             Qa=aa===ca?1:Sb&&!A&&U===r.options.tickPixelInterval?r.tickInterval:B(A,Wa?1:(ca-aa)*U/oa);
>     if(!E&&!J(i.tickInterval))Qa=N(Qa);
>     w.tickInterval=Qa;
>     Lc=i.minorTickInterval==="auto"&&Qa?Qa/5:i.minorTickInterval;
>     if(E){
>         ua=[];
>         A=Va.global.useUTC;
>         var F=1E3/rb,V=6E4/
>         rb,Aa=36E5/rb;
>         U=864E5/rb;
>         k=6048E5/rb;
>         q=2592E6/rb;
>         var ma=31556952E3/rb,s=[["second",F,[1,2,5,10,15,30]],["minute",V,[1,2,5,10,15,30]],["hour",Aa,[1,2,3,4,6,8,12]],["day",U,[1,2]],["week",k,[1,2]],["month",q,[1,2,3,4,6]],["year",ma,null]],W=s[6],$=W[1],ga=W[2];
>         for(r=0;r<s.length;r++){
>             W=s[r];
>             $=W[1];
>             ga=W[2];
>             if(s[r+1])if(Qa<=($*ga[ga.length-1]+s[r+1][1])/2)break
>         }
>         if($===ma&&Qa<5*$)ga=[1,2,5];
>         s=N(Qa/$,ga);
>         ga=new Date(aa*rb);
>         ga.setMilliseconds(0);
>         if($>=F)ga.setSeconds($>=V?0:s*kb(ga.getSeconds()/s));
>         if($>=
>             V)ga[Dd]($>=Aa?0:s*kb(ga[dd]()/s));
>         if($>=Aa)ga[Ed]($>=U?0:s*kb(ga[ed]()/s));
>         if($>=U)ga[gd]($>=q?1:s*kb(ga[tc]()/s));
>         if($>=q){
>             ga[Fd]($>=ma?0:s*kb(ga[Fc]()/s));
>             o=ga[Gc]()
>             }
>             if($>=ma){
>             o-=o%s;
>             ga[Gd](o)
>             }
>             $===k&&ga[gd](ga[tc]()-ga[fd]()+i.startOfWeek);
>         r=1;
>         o=ga[Gc]();
>         F=ga.getTime()/rb;
>         V=ga[Fc]();
>         for(Aa=ga[tc]();F<ca&&r<Ba;){
>             ua.push(F);
>             if($===ma)F=Ec(o+r*s,0)/rb;
>             else if($===q)F=Ec(o,V+r*s)/rb;
>             else if(!A&&($===U||$===k))F=Ec(o,V,Aa+r*s*($===U?1:7));else F+=$*s;
>             r++
>         }
>         ua.push(F);
>         Mc=i.dateTimeLabelFormats[W[0]]
>         }else{
>         r=
>         ba(kb(aa/Qa)*Qa);
>         o=ba(hd(ca/Qa)*Qa);
>         ua=[];
>         for(r=ba(r);r<=o;){
>             ua.push(r);
>             r=ba(r+Qa)
454,538c330,390
<             var Ea=i.isX,Ia=i.opposite,z=qa?!Ea:Ea,Y=z?Ia?0:2:Ia?1:3,v={};
< 
<             i=sa(Ea?Nc:jd,[$d,ae,Nd,be][Y],i);
<             var w=this,L=i.type,E=L==="datetime",D=L==="logarithmic",M=i.offset||0,ha=Ea?"x":"y",oa,va,fb,eb=z?Z:sb,Fb,Ub,hc,I,ja,T,ra,Da,Ha,Ma,ca=null,aa=null,Db,Md,Kd=i.minPadding,Ld=i.maxPadding,Sb=J(i.linkedTo),Id,Jd,Kc;
<             L=i.events;
<             var kd,Tb=[],Qa,Lc,Cb,ua,tb={},ac={},gc={},ic,jc,id,Mc,Wa=i.categories,ce=i.labels.formatter||function(){
<                 var k=
<                 this.value;
<                 return Mc?Oc(Mc,k):Qa%1E6===0?k/1E6+"M":Qa%1E3===0?k/1E3+"k":!Wa&&k>=1E3?Bd(k,0):k
<             },Pc=z&&i.labels.staggerLines,bc=i.reversed,cc=Wa&&i.tickmarkPlacement==="between"?0.5:0;
<             y.prototype={
<                 addLabel:function(){
<                     var k=this.pos,o=i.labels,r=!(k===aa&&!B(i.showFirstLabel,1)||k===ca&&!B(i.showLastLabel,0)),q=Wa&&z&&Wa.length&&!o.step&&!o.staggerLines&&!o.rotation&&Ba/Wa.length||!z&&Ba/2,A=this.label;
<                     k=ce.call({
<                         isFirst:k===ua[0],
<                         isLast:k===ua[ua.length-1],
<                         dateTimeLabelFormat:Mc,
<                         value:Wa&&Wa[k]?Wa[k]:
<                         k
<                     });
<                     q=q&&{
<                         width:Fa(1,X(q-2*(o.padding||10)))+$a
<                     };
< 
<                     q=pa(q,o.style);
<                     if(A===Ua)this.label=J(k)&&r&&o.enabled?da.text(k,0,0).attr({
<                         align:o.align,
<                         rotation:o.rotation
<                     }).css(q).add(hc):null;else A&&A.attr({
<                         text:k
<                     }).css(q)
<                 },
<                 getLabelSize:function(){
<                     var k=this.label;
<                     return k?(this.labelBBox=k.getBBox())[z?"height":"width"]:0
<                 },
<                 render:function(k,o){
<                     var r=!this.minor,q=this.label,A=this.pos,U=i.labels,F=this.gridLine,V=r?i.gridLineWidth:i.minorGridLineWidth,Aa=r?i.gridLineColor:i.minorGridLineColor,ma=r?i.gridLineDashStyle:
<                     i.minorGridLineDashStyle,s=this.mark,W=r?i.tickLength:i.minorTickLength,$=r?i.tickWidth:i.minorTickWidth||0,ga=r?i.tickColor:i.minorTickColor,zb=r?i.tickPosition:i.minorTickPosition;
<                     r=U.step;
<                     var lb=o&&Qc||Ra,Mb;
<                     Mb=z?Fb(A+cc,null,null,o)+eb:Z+M+(Ia?(o&&ld||Xa)-Eb-Z:0);
<                     lb=z?lb-sb+M-(Ia?xa:0):lb-Fb(A+cc,null,null,o)-eb;
<                     if(V){
<                         A=Ub(A+cc,V,o);
<                         if(F===Ua){
<                             F={
<                                 stroke:Aa,
<                                 "stroke-width":V
<                             };
< 
<                             if(ma)F.dashstyle=ma;
<                             this.gridLine=F=V?da.path(A).attr(F).add(I):null
<                         }
<                         F&&A&&F.animate({
<                             d:A
<                         })
<                     }
<                     if($){
<                         if(zb==="inside")W=-W;
<                         if(Ia)W=-W;
<                         V=da.crispLine([Za,Mb,lb,Ja,Mb+(z?0:-W),lb+(z?W:0)],$);
<                         if(s)s.animate({
<                             d:V
<                         });else this.mark=da.path(V).attr({
<                             stroke:ga,
<                             "stroke-width":$
<                         }).add(hc)
<                     }
<                     if(q&&!isNaN(Mb)){
<                         Mb=Mb+U.x-(cc&&z?cc*va*(bc?-1:1):0);
<                         lb=lb+U.y-(cc&&!z?cc*va*(bc?1:-1):0);
<                         J(U.y)||(lb+=la(q.styles.lineHeight)*0.9-q.getBBox().height/2);
<                         if(Pc)lb+=k/(r||1)%Pc*16;
<                         if(r)q[k%r?"hide":"show"]();
<                         q[this.isNew?"attr":"animate"]({
<                             x:Mb,
<                             y:lb
<                         })
<                     }
<                     this.isNew=false
<                 },
<                 destroy:function(){
<                     for(var k in this)this[k]&&this[k].destroy&&this[k].destroy()
<                 }
---
>         }
>         if(!Sb){
>     if(Wa||Ea&&m.hasColumn){
>         o=(Wa?1:Qa)*0.5;
>         if(Wa||!J(B(i.min,Ha)))aa-=o;
>         if(Wa||!J(B(i.max,Ma)))ca+=o
>             }
>             o=ua[0];
>     r=ua[ua.length-1];
>     if(i.startOnTick)aa=o;else aa>o&&ua.shift();
>     if(i.endOnTick)ca=r;else ca<r&&ua.pop();
>     Lb||(Lb={
>         x:0,
>         y:0
>     });
>     if(!E&&ua.length>Lb[ha])Lb[ha]=ua.length
>         }
>     }
> function za(){
>     var k,o;
>     Db=aa;
>     Md=ca;
>     na();
>     Ka();
>     fb=va;
>     va=oa/(ca-aa||1);
>     if(!Ea)for(k in v)for(o in v[k])v[k][o].cum=v[k][o].total;if(!w.isDirty)w.isDirty=
>         aa!==Db||ca!==Md
>         }
>         function Na(k){
>     k=(new x(k)).render();
>     Tb.push(k);
>     return k
>     }
>     function Oa(){
>     var k=i.title,o=i.stackLabels,r=i.alternateGridColor,q=i.lineWidth,A,U,F=m.hasRendered,V=F&&J(Db)&&!isNaN(Db);
>     A=Da.length&&J(aa)&&J(ca);
>     oa=z?Ba:xa;
>     va=oa/(ca-aa||1);
>     eb=z?Z:sb;
>     if(A||Sb){
>         if(Lc&&!Wa)for(A=aa+(ua[0]-aa)%Lc;A<=ca;A+=Lc){
>             ac[A]||(ac[A]=new y(A,true));
>             V&&ac[A].isNew&&ac[A].render(null,true);
>             ac[A].isActive=true;
>             ac[A].render()
>             }
>             t(ua,function(s,W){
>             if(!Sb||s>=aa&&s<=ca){
>                 V&&tb[s].isNew&&tb[s].render(W,true);
>                 tb[s].isActive=true;
>                 tb[s].render(W)
>                 }
>             });
>     r&&t(ua,function(s,W){
>         if(W%2===0&&s<ca){
>             gc[s]||(gc[s]=new x);
>             gc[s].options={
>                 from:s,
>                 to:ua[W+1]!==Ua?ua[W+1]:ca,
>                 color:r
540,550d391
<             x.prototype={
<                 render:function(){
<                     var k=this,o=k.options,r=o.label,q=k.label,A=o.width,U=o.to,F,V=o.from,Aa=o.dashStyle,ma=k.svgElem,s=[],W,$,ga=o.color;
<                     $=o.zIndex;
<                     var zb=o.events;
<                     if(A){
<                         s=Ub(o.value,A);
<                         o={
<                             stroke:ga,
<                             "stroke-width":A
<                         };
552,579c393,454
<                         if(Aa)o.dashstyle=Aa
<                     }else if(J(V)&&J(U)){
<                         V=Fa(V,aa);
<                         U=qb(U,ca);
<                         F=Ub(U);
<                         if((s=Ub(V))&&F)s.push(F[4],F[5],F[1],F[2]);else s=null;
<                         o={
<                             fill:ga
<                         }
<                     }else return;
<                     if(J($))o.zIndex=$;
<                     if(ma)if(s)ma.animate({
<                         d:s
<                     },null,ma.onGetPath);
<                     else{
<                         ma.hide();
<                         ma.onGetPath=function(){
<                             ma.show()
<                         }
<                     }else if(s&&
<                         s.length){
<                         k.svgElem=ma=da.path(s).attr(o).add();
<                         if(zb){
<                             Aa=function(lb){
<                                 ma.on(lb,function(Mb){
<                                     zb[lb].apply(k,[Mb])
<                                 })
<                             };
---
>             gc[s].render();
>             gc[s].isActive=true
>             }
>         });
> F||t((i.plotLines||[]).concat(i.plotBands||[]),function(s){
>     Tb.push((new x(s)).render())
>     })
> }
> t([tb,ac,gc],function(s){
>     for(var W in s)if(s[W].isActive)s[W].isActive=false;
>         else{
>         s[W].destroy();
>         delete s[W]
>     }
>     });
> if(q){
>     A=Z+(Ia?Ba:0)+M;
>     U=Ra-sb-(Ia?xa:0)+M;
>     A=da.crispLine([Za,z?Z:A,z?U:ea,Ja,z?Xa-Eb:A,z?U:Ra-sb],q);
>     if(ja)ja.animate({
>         d:A
>     });
>     else ja=da.path(A).attr({
>         stroke:i.lineColor,
>         "stroke-width":q,
>         zIndex:7
>     }).add()
>         }
>         if(w.axisTitle){
>     A=z?Z:ea;
>     q=la(k.style.fontSize||12);
>     A={
>         low:A+(z?0:oa),
>         middle:A+oa/2,
>         high:A+(z?oa:0)
>         }
>         [k.align];
>     q=(z?ea+xa:Z)+(z?1:-1)*(Ia?-1:1)*id+(Y===2?q:0);
>     w.axisTitle[F?"animate":"attr"]({
>         x:z?A:q+(Ia?Ba:0)+M+(k.x||0),
>         y:z?q-(Ia?xa:0)+M:A+(k.y||0)
>         })
>     }
>     if(o&&o.enabled){
>     var Aa,ma;
>     o=w.stackTotalGroup;
>     if(!o)w.stackTotalGroup=o=da.g("stack-labels").attr({
>         visibility:ub,
>         zIndex:6
>     }).translate(Z,ea).add();
>     for(Aa in v){
>         k=v[Aa];
>         for(ma in k)k[ma].render(o)
>             }
>         }
>     w.isDirty=
> false
> }
> function Ya(k){
>     for(var o=Tb.length;o--;)Tb[o].id===k&&Tb[o].destroy()
>         }
>         var Ea=i.isX,Ia=i.opposite,z=qa?!Ea:Ea,Y=z?Ia?0:2:Ia?1:3,v={};
581,618c456,475
<                             for(W in zb)Aa(W)
<                         }
<                     }
<                     if(r&&J(r.text)&&s&&s.length&&Ba>0&&xa>0){
<                         r=sa({
<                             align:z&&F&&"center",
<                             x:z?!F&&4:10,
<                             verticalAlign:!z&&F&&"middle",
<                             y:z?F?16:10:F?6:-4,
<                             rotation:z&&!F&&90
<                         },r);
<                         if(!q)k.label=q=da.text(r.text,0,0).attr({
<                             align:r.textAlign||r.align,
<                             rotation:r.rotation,
<                             zIndex:$
<                         }).css(r.style).add();
<                         F=[s[1],s[4],B(s[6],s[1])];
<                         s=[s[2],s[5],B(s[7],s[2])];
<                         W=qb.apply(ta,F);
<                         $=qb.apply(ta,s);
<                         q.align(r,
<                             false,{
<                                 x:W,
<                                 y:$,
<                                 width:Fa.apply(ta,F)-W,
<                                 height:Fa.apply(ta,s)-$
<                             });
<                         q.show()
<                     }else q&&q.hide();
<                     return k
<                 },
<                 destroy:function(){
<                     for(var k in this){
<                         this[k]&&this[k].destroy&&this[k].destroy();
<                         delete this[k]
<                     }
<                     rc(Tb,this)
<                 }
---
> i=sa(Ea?Nc:jd,[$d,ae,Nd,be][Y],i);
> var w=this,L=i.type,E=L==="datetime",D=L==="logarithmic",M=i.offset||0,ha=Ea?"x":"y",oa,va,fb,eb=z?Z:sb,Fb,Ub,hc,I,ja,T,ra,Da,Ha,Ma,ca=null,aa=null,Db,Md,Kd=i.minPadding,Ld=i.maxPadding,Sb=J(i.linkedTo),Id,Jd,Kc;
> L=i.events;
> var kd,Tb=[],Qa,Lc,Cb,ua,tb={},ac={},gc={},ic,jc,id,Mc,Wa=i.categories,ce=i.labels.formatter||function(){
>     var k=
>     this.value;
>     return Mc?Oc(Mc,k):Qa%1E6===0?k/1E6+"M":Qa%1E3===0?k/1E3+"k":!Wa&&k>=1E3?Bd(k,0):k
>     },Pc=z&&i.labels.staggerLines,bc=i.reversed,cc=Wa&&i.tickmarkPlacement==="between"?0.5:0;
> y.prototype={
>     addLabel:function(){
>         var k=this.pos,o=i.labels,r=!(k===aa&&!B(i.showFirstLabel,1)||k===ca&&!B(i.showLastLabel,0)),q=Wa&&z&&Wa.length&&!o.step&&!o.staggerLines&&!o.rotation&&Ba/Wa.length||!z&&Ba/2,A=this.label;
>         k=ce.call({
>             isFirst:k===ua[0],
>             isLast:k===ua[ua.length-1],
>             dateTimeLabelFormat:Mc,
>             value:Wa&&Wa[k]?Wa[k]:
>             k
>             });
>         q=q&&{
>             width:Fa(1,X(q-2*(o.padding||10)))+$a
621,645c478,503
<             R.prototype={
<                 setTotal:function(k){
<                     this.cum=this.total=k
<                 },
<                 render:function(k){
<                     var o=this.options.formatter.call(this);
<                     if(this.label)this.label.attr({
<                         text:o,
<                         visibility:gb
<                     });else this.label=m.renderer.text(o,0,0).css(this.options.style).attr({
<                         align:this.textAlign,
<                         rotation:this.options.rotation,
<                         visibility:gb
<                     }).add(k)
<                 },
<                 setOffset:function(k,o){
<                     var r=this.isNegative,q=w.translate(this.total),A=w.translate(0);
<                     A=db(q-A);
<                     var U=m.xAxis[0].translate(this.x)+k,F=m.plotHeight;
<                     r={
<                         x:qa?r?q:q-A:U,
<                         y:qa?F-U-o:r?F-q-A:F-q,
<                         width:qa?A:o,
<                         height:qa?o:A
<                     };
---
>         q=pa(q,o.style);
>         if(A===Ua)this.label=J(k)&&r&&o.enabled?da.text(k,0,0).attr({
>             align:o.align,
>             rotation:o.rotation
>             }).css(q).add(hc):null;else A&&A.attr({
>             text:k
>         }).css(q)
>             },
>     getLabelSize:function(){
>         var k=this.label;
>         return k?(this.labelBBox=k.getBBox())[z?"height":"width"]:0
>         },
>     render:function(k,o){
>         var r=!this.minor,q=this.label,A=this.pos,U=i.labels,F=this.gridLine,V=r?i.gridLineWidth:i.minorGridLineWidth,Aa=r?i.gridLineColor:i.minorGridLineColor,ma=r?i.gridLineDashStyle:
>         i.minorGridLineDashStyle,s=this.mark,W=r?i.tickLength:i.minorTickLength,$=r?i.tickWidth:i.minorTickWidth||0,ga=r?i.tickColor:i.minorTickColor,zb=r?i.tickPosition:i.minorTickPosition;
>         r=U.step;
>         var lb=o&&Qc||Ra,Mb;
>         Mb=z?Fb(A+cc,null,null,o)+eb:Z+M+(Ia?(o&&ld||Xa)-Eb-Z:0);
>         lb=z?lb-sb+M-(Ia?xa:0):lb-Fb(A+cc,null,null,o)-eb;
>         if(V){
>             A=Ub(A+cc,V,o);
>             if(F===Ua){
>                 F={
>                     stroke:Aa,
>                     "stroke-width":V
>                 };
647,649c505,506
<                     this.label&&this.label.align(this.alignOptions,null,r).attr({
<                         visibility:ub
<                     })
---
>                 if(ma)F.dashstyle=ma;
>                 this.gridLine=F=V?da.path(A).attr(F).add(I):null
650a508,549
>                 F&&A&&F.animate({
>                 d:A
>             })
>             }
>             if($){
>             if(zb==="inside")W=-W;
>             if(Ia)W=-W;
>             V=da.crispLine([Za,Mb,lb,Ja,Mb+(z?0:-W),lb+(z?W:0)],$);
>             if(s)s.animate({
>                 d:V
>             });else this.mark=da.path(V).attr({
>                 stroke:ga,
>                 "stroke-width":$
>             }).add(hc)
>                 }
>                 if(q&&!isNaN(Mb)){
>             Mb=Mb+U.x-(cc&&z?cc*va*(bc?-1:1):0);
>             lb=lb+U.y-(cc&&!z?cc*va*(bc?1:-1):0);
>             J(U.y)||(lb+=la(q.styles.lineHeight)*0.9-q.getBBox().height/2);
>             if(Pc)lb+=k/(r||1)%Pc*16;
>             if(r)q[k%r?"hide":"show"]();
>             q[this.isNew?"attr":"animate"]({
>                 x:Mb,
>                 y:lb
>             })
>             }
>             this.isNew=false
>         },
>     destroy:function(){
>         for(var k in this)this[k]&&this[k].destroy&&this[k].destroy()
>             }
>         };
> x.prototype={
>     render:function(){
>         var k=this,o=k.options,r=o.label,q=k.label,A=o.width,U=o.to,F,V=o.from,Aa=o.dashStyle,ma=k.svgElem,s=[],W,$,ga=o.color;
>         $=o.zIndex;
>         var zb=o.events;
>         if(A){
>             s=Ub(o.value,A);
>             o={
>                 stroke:ga,
>                 "stroke-width":A
653,674c552,578
<             Fb=function(k,o,r,q,A){
<                 var U=1,F=0,V=q?fb:va;
<                 q=q?Db:aa;
<                 V||(V=va);
<                 if(r){
<                     U*=-1;
<                     F=oa
<                 }
<                 if(bc){
<                     U*=-1;
<                     F-=U*oa
<                 }
<                 if(o){
<                     if(bc)k=oa-k;
<                     k=k/V+q;
<                     if(D&&A)k=ta.pow(10,k)
<                 }else{
<                     if(D&&A)k=ta.log(k)/
<                         ta.LN10;
<                     k=U*(k-q)*V+F
<                 }
<                 return k
---
>             if(Aa)o.dashstyle=Aa
>                 }else if(J(V)&&J(U)){
>             V=Fa(V,aa);
>             U=qb(U,ca);
>             F=Ub(U);
>             if((s=Ub(V))&&F)s.push(F[4],F[5],F[1],F[2]);else s=null;
>             o={
>                 fill:ga
>             }
>         }else return;
>     if(J($))o.zIndex=$;
>     if(ma)if(s)ma.animate({
>         d:s
>     },null,ma.onGetPath);
>     else{
>         ma.hide();
>         ma.onGetPath=function(){
>             ma.show()
>             }
>         }else if(s&&
>     s.length){
>     k.svgElem=ma=da.path(s).attr(o).add();
>     if(zb){
>         Aa=function(lb){
>             ma.on(lb,function(Mb){
>                 zb[lb].apply(k,[Mb])
>                 })
677,693c581,644
<             Ub=function(k,o,r){
<                 var q,A,U;
<                 k=Fb(k,null,null,r);
<                 var F=r&&Qc||Ra,V=r&&ld||Xa,Aa;
<                 r=A=X(k+eb);
<                 q=U=X(F-k-eb);
<                 if(isNaN(k))Aa=true;
<                 else if(z){
<                     q=ea;
<                     U=F-sb;
<                     if(r<Z||r>Z+Ba)Aa=true
<                 }else{
<                     r=Z;
<                     A=V-Eb;
<                     if(q<ea||q>ea+xa)Aa=true
<                 }
<                 return Aa?null:da.crispLine([Za,r,q,Ja,A,U],o||0)
---
>         for(W in zb)Aa(W)
>             }
>         }
> if(r&&J(r.text)&&s&&s.length&&Ba>0&&xa>0){
>     r=sa({
>         align:z&&F&&"center",
>         x:z?!F&&4:10,
>         verticalAlign:!z&&F&&"middle",
>         y:z?F?16:10:F?6:-4,
>         rotation:z&&!F&&90
>         },r);
>     if(!q)k.label=q=da.text(r.text,0,0).attr({
>         align:r.textAlign||r.align,
>         rotation:r.rotation,
>         zIndex:$
>     }).css(r.style).add();
>     F=[s[1],s[4],B(s[6],s[1])];
>     s=[s[2],s[5],B(s[7],s[2])];
>     W=qb.apply(ta,F);
>     $=qb.apply(ta,s);
>     q.align(r,
>         false,{
>             x:W,
>             y:$,
>             width:Fa.apply(ta,F)-W,
>             height:Fa.apply(ta,s)-$
>             });
>     q.show()
>     }else q&&q.hide();
> return k
> },
> destroy:function(){
>     for(var k in this){
>         this[k]&&this[k].destroy&&this[k].destroy();
>         delete this[k]
>     }
>     rc(Tb,this)
>     }
> };
> 
> R.prototype={
>     setTotal:function(k){
>         this.cum=this.total=k
>         },
>     render:function(k){
>         var o=this.options.formatter.call(this);
>         if(this.label)this.label.attr({
>             text:o,
>             visibility:gb
>         });else this.label=m.renderer.text(o,0,0).css(this.options.style).attr({
>             align:this.textAlign,
>             rotation:this.options.rotation,
>             visibility:gb
>         }).add(k)
>             },
>     setOffset:function(k,o){
>         var r=this.isNegative,q=w.translate(this.total),A=w.translate(0);
>         A=db(q-A);
>         var U=m.xAxis[0].translate(this.x)+k,F=m.plotHeight;
>         r={
>             x:qa?r?q:q-A:U,
>             y:qa?F-U-o:r?F-q-A:F-q,
>             width:qa?A:o,
>             height:qa?o:A
696,817c647,649
<             if(qa&&Ea&&bc===Ua)bc=true;
<             pa(w,{
<                 addPlotBand:Na,
<                 addPlotLine:Na,
<                 adjustTickAmount:function(){
<                     if(Lb&&!E&&!Wa&&!Sb){
<                         var k=ic,o=ua.length;
<                         ic=Lb[ha];
<                         if(o<ic){
<                             for(;ua.length<ic;)ua.push(ba(ua[ua.length-1]+Qa));
<                             va*=
<                             (o-1)/(ic-1);
<                             ca=ua[ua.length-1]
<                         }
<                         if(J(k)&&ic!==k)w.isDirty=true
<                     }
<                 },
<                 categories:Wa,
<                 getExtremes:function(){
<                     return{
<                         min:aa,
<                         max:ca,
<                         dataMin:T,
<                         dataMax:ra,
<                         userMin:Ha,
<                         userMax:Ma
<                     }
<                 },
<                 getPlotLinePath:Ub,
<                 getThreshold:function(k){
<                     if(aa>k)k=aa;
<                     else if(ca<k)k=ca;
<                     return Fb(k,0,1)
<                 },
<                 isXAxis:Ea,
<                 options:i,
<                 plotLinesAndBands:Tb,
<                 getOffset:function(){
<                     var k=Da.length&&J(aa)&&J(ca),o=0,r=0,q=i.title,A=i.labels,U=[-1,1,1,-1][Y],F;
<                     if(!hc){
<                         hc=da.g("axis").attr({
<                             zIndex:7
<                         }).add();
<                         I=da.g("grid").attr({
<                             zIndex:1
<                         }).add()
<                     }
<                     jc=0;
<                     if(k||Sb){
<                         t(ua,
<                             function(V){
<                                 if(tb[V])tb[V].addLabel();else tb[V]=new y(V);
<                                 if(Y===0||Y===2||{
<                                     1:"left",
<                                     3:"right"
<                                 }
<                                 [Y]===A.align)jc=Fa(tb[V].getLabelSize(),jc)
<                             });
<                         if(Pc)jc+=(Pc-1)*16
<                     }else for(F in tb){
<                         tb[F].destroy();
<                         delete tb[F]
<                     }
<                     if(q&&q.text){
<                         if(!w.axisTitle)w.axisTitle=da.text(q.text,0,0).attr({
<                             zIndex:7,
<                             rotation:q.rotation||0,
<                             align:q.textAlign||{
<                                 low:"left",
<                                 middle:"center",
<                                 high:"right"
<                             }
<                             [q.align]
<                         }).css(q.style).add();
<                         o=w.axisTitle.getBBox()[z?"height":"width"];
<                         r=B(q.margin,z?5:10)
<                     }
<                     M=U*(i.offset||Vb[Y]);
<                     id=jc+(Y!==2&&
<                         jc&&U*i.labels[z?"y":"x"])+r;
<                     Vb[Y]=Fa(Vb[Y],id+o+U*M)
<                 },
<                 render:Oa,
<                 setCategories:function(k,o){
<                     w.categories=Wa=k;
<                     t(Da,function(r){
<                         r.translate();
<                         r.setTooltipPoints(true)
<                     });
<                     w.isDirty=true;
<                     B(o,true)&&m.redraw()
<                 },
<                 setExtremes:function(k,o,r,q){
<                     r=B(r,true);
<                     Pa(w,"setExtremes",{
<                         min:k,
<                         max:o
<                     },function(){
<                         Ha=k;
<                         Ma=o;
<                         r&&m.redraw(q)
<                     })
<                 },
<                 setScale:za,
<                 setTickPositions:Ka,
<                 translate:Fb,
<                 redraw:function(){
<                     kc.resetTracker&&kc.resetTracker();
<                     Oa();
<                     t(Tb,function(k){
<                         k.render()
<                     });
<                     t(Da,function(k){
<                         k.isDirty=true
<                     })
<                 },
<                 removePlotBand:Ya,
<                 removePlotLine:Ya,
<                 reversed:bc,
<                 stacks:v
<             });
<             for(kd in L)Sa(w,kd,L[kd]);za()
---
>         this.label&&this.label.align(this.alignOptions,null,r).attr({
>             visibility:ub
>         })
819,820c651
<         function d(){
<             var m={};
---
>     };
822,840c653,659
<             return{
<                 add:function(i,y,x,R){
<                     if(!m[i]){
<                         y=da.text(y,0,0).css(a.toolbar.itemStyle).align({
<                             align:"right",
<                             x:-Eb-20,
<                             y:ea+30
<                         }).on("click",R).attr({
<                             align:"right",
<                             zIndex:20
<                         }).add();
<                         m[i]=y
<                     }
<                 },
<                 remove:function(i){
<                     Hc(m[i].element);
<                     m[i]=null
<                 }
<             }
---
> Fb=function(k,o,r,q,A){
>     var U=1,F=0,V=q?fb:va;
>     q=q?Db:aa;
>     V||(V=va);
>     if(r){
>         U*=-1;
>         F=oa
842,852c661,691
<         function e(m){
<             function i(){
<                 var E=this.points||sc(this),D=E[0].series.xAxis,M=this.x;
<                 D=D&&D.options.type==="datetime";
<                 var ha=Qb(M)||D,oa;
<                 oa=ha?['<span style="font-size: 10px">'+
<                 (D?Oc("%A, %b %e, %Y",M):M)+"</span>"]:[];
<                 t(E,function(va){
<                     oa.push(va.point.tooltipFormatter(ha))
<                 });
<                 return oa.join("<br/>")
---
>         if(bc){
>         U*=-1;
>         F-=U*oa
>         }
>         if(o){
>         if(bc)k=oa-k;
>         k=k/V+q;
>         if(D&&A)k=ta.pow(10,k)
>             }else{
>         if(D&&A)k=ta.log(k)/
>             ta.LN10;
>         k=U*(k-q)*V+F
>         }
>         return k
>     };
> 
> Ub=function(k,o,r){
>     var q,A,U;
>     k=Fb(k,null,null,r);
>     var F=r&&Qc||Ra,V=r&&ld||Xa,Aa;
>     r=A=X(k+eb);
>     q=U=X(F-k-eb);
>     if(isNaN(k))Aa=true;
>     else if(z){
>         q=ea;
>         U=F-sb;
>         if(r<Z||r>Z+Ba)Aa=true
>             }else{
>         r=Z;
>         A=V-Eb;
>         if(q<ea||q>ea+xa)Aa=true
854,870c693,752
<             function y(E,D){
<                 z=Ya?E:(2*z+E)/3;
<                 Y=Ya?D:(Y+D)/2;
<                 v.translate(z,Y);
<                 md=db(E-z)>1||db(D-Y)>1?function(){
<                     y(E,D)
<                 }:null
<             }
<             function x(){
<                 if(!Ya){
<                     var E=p.hoverPoints;
<                     v.hide();
<                     t(ba,function(D){
<                         D&&D.hide()
<                     });
<                     E&&t(E,function(D){
<                         D.setState()
---
>             return Aa?null:da.crispLine([Za,r,q,Ja,A,U],o||0)
>     };
> 
> if(qa&&Ea&&bc===Ua)bc=true;
> pa(w,{
>     addPlotBand:Na,
>     addPlotLine:Na,
>     adjustTickAmount:function(){
>         if(Lb&&!E&&!Wa&&!Sb){
>             var k=ic,o=ua.length;
>             ic=Lb[ha];
>             if(o<ic){
>                 for(;ua.length<ic;)ua.push(ba(ua[ua.length-1]+Qa));
>                 va*=
>                 (o-1)/(ic-1);
>                 ca=ua[ua.length-1]
>                 }
>                 if(J(k)&&ic!==k)w.isDirty=true
>                 }
>             },
> categories:Wa,
> getExtremes:function(){
>     return{
>         min:aa,
>         max:ca,
>         dataMin:T,
>         dataMax:ra,
>         userMin:Ha,
>         userMax:Ma
>     }
> },
> getPlotLinePath:Ub,
> getThreshold:function(k){
>     if(aa>k)k=aa;
>     else if(ca<k)k=ca;
>     return Fb(k,0,1)
>     },
> isXAxis:Ea,
> options:i,
> plotLinesAndBands:Tb,
> getOffset:function(){
>     var k=Da.length&&J(aa)&&J(ca),o=0,r=0,q=i.title,A=i.labels,U=[-1,1,1,-1][Y],F;
>     if(!hc){
>         hc=da.g("axis").attr({
>             zIndex:7
>         }).add();
>         I=da.g("grid").attr({
>             zIndex:1
>         }).add()
>         }
>         jc=0;
>     if(k||Sb){
>         t(ua,
>             function(V){
>                 if(tb[V])tb[V].addLabel();else tb[V]=new y(V);
>                 if(Y===0||Y===2||{
>                     1:"left",
>                     3:"right"
>                 }
>                 [Y]===A.align)jc=Fa(tb[V].getLabelSize(),jc)
872,873c754,833
<                     p.hoverPoints=null;
<                     Ya=true
---
>         if(Pc)jc+=(Pc-1)*16
>             }else for(F in tb){
>         tb[F].destroy();
>         delete tb[F]
>     }
>     if(q&&q.text){
>         if(!w.axisTitle)w.axisTitle=da.text(q.text,0,0).attr({
>             zIndex:7,
>             rotation:q.rotation||0,
>             align:q.textAlign||{
>                 low:"left",
>                 middle:"center",
>                 high:"right"
>             }
>             [q.align]
>             }).css(q.style).add();
>         o=w.axisTitle.getBBox()[z?"height":"width"];
>         r=B(q.margin,z?5:10)
>         }
>         M=U*(i.offset||Vb[Y]);
>     id=jc+(Y!==2&&
>         jc&&U*i.labels[z?"y":"x"])+r;
>     Vb[Y]=Fa(Vb[Y],id+o+U*M)
>     },
> render:Oa,
> setCategories:function(k,o){
>     w.categories=Wa=k;
>     t(Da,function(r){
>         r.translate();
>         r.setTooltipPoints(true)
>         });
>     w.isDirty=true;
>     B(o,true)&&m.redraw()
>     },
> setExtremes:function(k,o,r,q){
>     r=B(r,true);
>     Pa(w,"setExtremes",{
>         min:k,
>         max:o
>     },function(){
>         Ha=k;
>         Ma=o;
>         r&&m.redraw(q)
>         })
>     },
> setScale:za,
> setTickPositions:Ka,
> translate:Fb,
> redraw:function(){
>     kc.resetTracker&&kc.resetTracker();
>     Oa();
>     t(Tb,function(k){
>         k.render()
>         });
>     t(Da,function(k){
>         k.isDirty=true
>         })
>     },
> removePlotBand:Ya,
> removePlotLine:Ya,
> reversed:bc,
> stacks:v
> });
> for(kd in L)Sa(w,kd,L[kd]);za()
> }
> function d(){
>     var m={};
> 
>     return{
>         add:function(i,y,x,R){
>             if(!m[i]){
>                 y=da.text(y,0,0).css(a.toolbar.itemStyle).align({
>                     align:"right",
>                     x:-Eb-20,
>                     y:ea+30
>                     }).on("click",R).attr({
>                     align:"right",
>                     zIndex:20
>                 }).add();
>                 m[i]=y
875,886c835,864
<             }
<             var R,na=m.borderWidth,N=m.crosshairs,ba=[],Ka=m.style,za=m.shared,Na=la(Ka.padding),Oa=na+Na,Ya=true,Ea,Ia,z=0,Y=0;
<             Ka.padding=
<             0;
<             var v=da.g("tooltip").attr({
<                 zIndex:8
<             }).add(),w=da.rect(Oa,Oa,0,0,m.borderRadius,na).attr({
<                 fill:m.backgroundColor,
<                 "stroke-width":na
<             }).add(v).shadow(m.shadow),L=da.text("",Na+Oa,la(Ka.fontSize)+Na+Oa).attr({
<                 zIndex:1
<             }).css(Ka).add(v);
---
>             },
>     remove:function(i){
>         Hc(m[i].element);
>         m[i]=null
>         }
>     }
> }
> function e(m){
>     function i(){
>         var E=this.points||sc(this),D=E[0].series.xAxis,M=this.x;
>         D=D&&D.options.type==="datetime";
>         var ha=Qb(M)||D,oa;
>         oa=ha?['<span style="font-size: 10px">'+
>         (D?Oc("%A, %b %e, %Y",M):M)+"</span>"]:[];
>         t(E,function(va){
>             oa.push(va.point.tooltipFormatter(ha))
>             });
>         return oa.join("<br/>")
>         }
>         function y(E,D){
>         z=Ya?E:(2*z+E)/3;
>         Y=Ya?D:(Y+D)/2;
>         v.translate(z,Y);
>         md=db(E-z)>1||db(D-Y)>1?function(){
>             y(E,D)
>             }:null
>         }
>         function x(){
>         if(!Ya){
>             var E=p.hoverPoints;
888,909c866,909
<             return{
<                 shared:za,
<                 refresh:function(E){
<                     var D,M,ha,oa=0,va={},fb=[];
<                     ha=E.tooltipPos;
<                     D=m.formatter||i;
<                     va=p.hoverPoints;
<                     if(za){
<                         va&&t(va,function(eb){
<                             eb.setState()
<                         });
<                         p.hoverPoints=E;
<                         t(E,function(eb){
<                             eb.setState(Ab);
<                             oa+=eb.plotY;
<                             fb.push(eb.getLabelConfig())
<                         });
<                         M=E[0].plotX;
<                         oa=X(oa)/E.length;
<                         va={
<                             x:E[0].category
<                         };
---
>             t(ba,function(D){
>                 D&&D.hide()
>                 });
>             E&&t(E,function(D){
>                 D.setState()
>                 });
>             p.hoverPoints=null;
>             Ya=true
>             }
>         }
>     var R,na=m.borderWidth,N=m.crosshairs,ba=[],Ka=m.style,za=m.shared,Na=la(Ka.padding),Oa=na+Na,Ya=true,Ea,Ia,z=0,Y=0;
> Ka.padding=
> 0;
> var v=da.g("tooltip").attr({
>     zIndex:8
> }).add(),w=da.rect(Oa,Oa,0,0,m.borderRadius,na).attr({
>     fill:m.backgroundColor,
>     "stroke-width":na
> }).add(v).shadow(m.shadow),L=da.text("",Na+Oa,la(Ka.fontSize)+Na+Oa).attr({
>     zIndex:1
> }).css(Ka).add(v);
> v.hide();
> return{
>     shared:za,
>     refresh:function(E){
>         var D,M,ha,oa=0,va={},fb=[];
>         ha=E.tooltipPos;
>         D=m.formatter||i;
>         va=p.hoverPoints;
>         if(za){
>             va&&t(va,function(eb){
>                 eb.setState()
>                 });
>             p.hoverPoints=E;
>             t(E,function(eb){
>                 eb.setState(Ab);
>                 oa+=eb.plotY;
>                 fb.push(eb.getLabelConfig())
>                 });
>             M=E[0].plotX;
>             oa=X(oa)/E.length;
>             va={
>                 x:E[0].category
>                 };
911,921c911,958
<                         va.points=fb;
<                         E=E[0]
<                     }else va=E.getLabelConfig();
<                     va=D.call(va);
<                     R=E.series;
<                     M=za?M:E.plotX;
<                     oa=za?oa:E.plotY;
<                     D=X(ha?ha[0]:qa?Ba-oa:M);
<                     M=X(ha?ha[1]:qa?xa-M:oa);
<                     ha=za||!E.series.isCartesian||lc(D,M);
<                     if(va===false||!ha)x();
---
>             va.points=fb;
>             E=E[0]
>             }else va=E.getLabelConfig();
>         va=D.call(va);
>         R=E.series;
>         M=za?M:E.plotX;
>         oa=za?oa:E.plotY;
>         D=X(ha?ha[0]:qa?Ba-oa:M);
>         M=X(ha?ha[1]:qa?xa-M:oa);
>         ha=za||!E.series.isCartesian||lc(D,M);
>         if(va===false||!ha)x();
>         else{
>             if(Ya){
>                 v.show();
>                 Ya=false
>                 }
>                 L.attr({
>                 text:va
>             });
>             ha=L.getBBox();
>             Ea=ha.width+2*Na;
>             Ia=ha.height+2*Na;
>             w.attr({
>                 width:Ea,
>                 height:Ia,
>                 stroke:m.borderColor||E.color||R.color||"#606060"
>                 });
>             D=D-Ea+Z-25;
>             M=M-Ia+ea+10;
>             if(D<7){
>                 D=7;
>                 M-=30
>                 }
>                 if(M<5)M=5;
>             else if(M+Ia>Ra)M=
>                 Ra-Ia-5;
>             y(X(D-Oa),X(M-Oa))
>             }
>             if(N){
>             N=sc(N);
>             for(D=N.length;D--;){
>                 M=E.series[D?"yAxis":"xAxis"];
>                 if(N[D]&&M){
>                     M=M.getPlotLinePath(E[D?"y":"x"],1);
>                     if(ba[D])ba[D].attr({
>                         d:M,
>                         visibility:ub
>                     });
923,964c960,964
<                         if(Ya){
<                             v.show();
<                             Ya=false
<                         }
<                         L.attr({
<                             text:va
<                         });
<                         ha=L.getBBox();
<                         Ea=ha.width+2*Na;
<                         Ia=ha.height+2*Na;
<                         w.attr({
<                             width:Ea,
<                             height:Ia,
<                             stroke:m.borderColor||E.color||R.color||"#606060"
<                         });
<                         D=D-Ea+Z-25;
<                         M=M-Ia+ea+10;
<                         if(D<7){
<                             D=7;
<                             M-=30
<                         }
<                         if(M<5)M=5;
<                         else if(M+Ia>Ra)M=
<                             Ra-Ia-5;
<                         y(X(D-Oa),X(M-Oa))
<                     }
<                     if(N){
<                         N=sc(N);
<                         for(D=N.length;D--;){
<                             M=E.series[D?"yAxis":"xAxis"];
<                             if(N[D]&&M){
<                                 M=M.getPlotLinePath(E[D?"y":"x"],1);
<                                 if(ba[D])ba[D].attr({
<                                     d:M,
<                                     visibility:ub
<                                 });
<                                 else{
<                                     ha={
<                                         "stroke-width":N[D].width||1,
<                                         stroke:N[D].color||"#C0C0C0",
<                                         zIndex:2
<                                     };
---
>                         ha={
>                             "stroke-width":N[D].width||1,
>                             stroke:N[D].color||"#C0C0C0",
>                             zIndex:2
>                         };
966,969c966,967
<                                     if(N[D].dashStyle)ha.dashstyle=N[D].dashStyle;
<                                     ba[D]=da.path(M).attr(ha).add()
<                                 }
<                             }
---
>                         if(N[D].dashStyle)ha.dashstyle=N[D].dashStyle;
>                         ba[D]=da.path(M).attr(ha).add()
972,973d969
<                 },
<                 hide:x
976,1025c972,987
<         function f(m,i){
<             function y(z){
<                 var Y,v=Od&&wa.width/wa.documentElement.clientWidth-1,w,L,E;
<                 z=z||ab.event;
<                 if(!z.target)z.target=z.srcElement;
<                 Y=z.touches?z.touches.item(0):
<                 z;
<                 if(z.type!=="mousemove"||ab.opera||v){
<                     w=ya;
<                     L={
<                         left:w.offsetLeft,
<                         top:w.offsetTop
<                     };
< 
<                     for(w=w.offsetParent;w;){
<                         L.left+=w.offsetLeft;
<                         L.top+=w.offsetTop;
<                         if(w!==wa.body&&w!==wa.documentElement){
<                             L.left-=w.scrollLeft;
<                             L.top-=w.scrollTop
<                         }
<                         w=w.offsetParent
<                     }
<                     uc=L;
<                     w=uc.left;
<                     L=uc.top
<                 }
<                 if(Cc){
<                     E=z.x;
<                     Y=z.y
<                 }else if(Y.layerX===Ua){
<                     E=Y.pageX-w;
<                     Y=Y.pageY-L
<                 }else{
<                     E=z.layerX;
<                     Y=z.layerY
<                 }
<                 if(v){
<                     E+=X((v+1)*w-w);
<                     Y+=X((v+1)*L-L)
<                 }
<                 return pa(z,{
<                     chartX:E,
<                     chartY:Y
<                 })
<             }
<             function x(z){
<                 var Y={
<                     xAxis:[],
<                     yAxis:[]
---
> },
> hide:x
> }
> }
> function f(m,i){
>     function y(z){
>         var Y,v=Od&&wa.width/wa.documentElement.clientWidth-1,w,L,E;
>         z=z||ab.event;
>         if(!z.target)z.target=z.srcElement;
>         Y=z.touches?z.touches.item(0):
>         z;
>         if(z.type!=="mousemove"||ab.opera||v){
>             w=ya;
>             L={
>                 left:w.offsetLeft,
>                 top:w.offsetTop
1028,1043c990,1011
<                 t(bb,function(v){
<                     var w=v.translate,
<                     L=v.isXAxis;
<                     Y[L?"xAxis":"yAxis"].push({
<                         axis:v,
<                         value:w((qa?!L:L)?z.chartX-Z:xa-z.chartY+ea,true)
<                     })
<                 });
<                 return Y
<             }
<             function R(){
<                 var z=m.hoverSeries,Y=m.hoverPoint;
<                 Y&&Y.onMouseOut();
<                 z&&z.onMouseOut();
<                 vc&&vc.hide();
<                 nd=null
---
>             for(w=w.offsetParent;w;){
>                 L.left+=w.offsetLeft;
>                 L.top+=w.offsetTop;
>                 if(w!==wa.body&&w!==wa.documentElement){
>                     L.left-=w.scrollLeft;
>                     L.top-=w.scrollTop
>                     }
>                     w=w.offsetParent
>                 }
>                 uc=L;
>             w=uc.left;
>             L=uc.top
>             }
>             if(Cc){
>             E=z.x;
>             Y=z.y
>             }else if(Y.layerX===Ua){
>             E=Y.pageX-w;
>             Y=Y.pageY-L
>             }else{
>             E=z.layerX;
>             Y=z.layerY
1045,1064c1013,1062
<             function na(){
<                 if(za){
<                     var z={
<                         xAxis:[],
<                         yAxis:[]
<                     },Y=za.getBBox(),v=Y.x-Z,w=Y.y-ea;
<                     if(Ka){
<                         t(bb,function(L){
<                             var E=L.translate,D=L.isXAxis,M=qa?!D:D,ha=E(M?v:xa-w-Y.height,true,0,0,1);
<                             E=E(M?v+Y.width:xa-w,true,0,0,1);
<                             z[D?"xAxis":"yAxis"].push({
<                                 axis:L,
<                                 min:qb(ha,E),
<                                 max:Fa(ha,E)
<                             })
<                         });
<                         Pa(m,"selection",
<                             z,od)
<                     }
<                     za=za.destroy()
---
>             if(v){
>             E+=X((v+1)*w-w);
>             Y+=X((v+1)*L-L)
>             }
>             return pa(z,{
>             chartX:E,
>             chartY:Y
>         })
>         }
>         function x(z){
>         var Y={
>             xAxis:[],
>             yAxis:[]
>         };
> 
>         t(bb,function(v){
>             var w=v.translate,
>             L=v.isXAxis;
>             Y[L?"xAxis":"yAxis"].push({
>                 axis:v,
>                 value:w((qa?!L:L)?z.chartX-Z:xa-z.chartY+ea,true)
>                 })
>             });
>         return Y
>         }
>         function R(){
>         var z=m.hoverSeries,Y=m.hoverPoint;
>         Y&&Y.onMouseOut();
>         z&&z.onMouseOut();
>         vc&&vc.hide();
>         nd=null
>         }
>         function na(){
>         if(za){
>             var z={
>                 xAxis:[],
>                 yAxis:[]
>             },Y=za.getBBox(),v=Y.x-Z,w=Y.y-ea;
>             if(Ka){
>                 t(bb,function(L){
>                     var E=L.translate,D=L.isXAxis,M=qa?!D:D,ha=E(M?v:xa-w-Y.height,true,0,0,1);
>                     E=E(M?v+Y.width:xa-w,true,0,0,1);
>                     z[D?"xAxis":"yAxis"].push({
>                         axis:L,
>                         min:qb(ha,E),
>                         max:Fa(ha,E)
>                         })
>                     });
>                 Pa(m,"selection",
>                     z,od)
1066,1067c1064
<                 m.mouseIsDown=pd=Ka=false;
<                 Gb(wa,Nb?"touchend":"mouseup",na)
---
>                 za=za.destroy()
1069,1079c1066,1079
<             var N,ba,Ka,za,Na=u.zoomType,Oa=/x/.test(Na),Ya=/y/.test(Na),Ea=Oa&&!qa||Ya&&qa,Ia=Ya&&!qa||Oa&&qa;
<             Rc=function(){
<                 if(Sc){
<                     Sc.translate(Z,ea);
<                     qa&&Sc.attr({
<                         width:m.plotWidth,
<                         height:m.plotHeight
<                     }).invert()
<                 }else m.trackerGroup=Sc=da.g("tracker").attr({
<                     zIndex:9
<                 }).add()
---
>             m.mouseIsDown=pd=Ka=false;
>         Gb(wa,Nb?"touchend":"mouseup",na)
>         }
>         var N,ba,Ka,za,Na=u.zoomType,Oa=/x/.test(Na),Ya=/y/.test(Na),Ea=Oa&&!qa||Ya&&qa,Ia=Ya&&!qa||Oa&&qa;
>     Rc=function(){
>         if(Sc){
>             Sc.translate(Z,ea);
>             qa&&Sc.attr({
>                 width:m.plotWidth,
>                 height:m.plotHeight
>                 }).invert()
>             }else m.trackerGroup=Sc=da.g("tracker").attr({
>             zIndex:9
>         }).add()
1082,1093c1082,1093
<             Rc();
<             if(i.enabled)m.tooltip=vc=e(i);
<             (function(){
<                 var z=true;
<                 ya.onmousedown=function(v){
<                     v=y(v);
<                     m.mouseIsDown=pd=true;
<                     N=v.chartX;
<                     ba=v.chartY;
<                     Sa(wa,Nb?"touchend":
<                         "mouseup",na)
<                 };
---
>     Rc();
>     if(i.enabled)m.tooltip=vc=e(i);
>     (function(){
>         var z=true;
>         ya.onmousedown=function(v){
>             v=y(v);
>             m.mouseIsDown=pd=true;
>             N=v.chartX;
>             ba=v.chartY;
>             Sa(wa,Nb?"touchend":
>                 "mouseup",na)
>             };
1095,1106c1095,1106
<                 var Y=function(v){
<                     if(!(v&&v.touches&&v.touches.length>1)){
<                         v=y(v);
<                         if(!Nb)v.returnValue=false;
<                         var w=v.chartX,L=v.chartY,E=!lc(w-Z,L-ea);
<                         if(Nb&&v.type==="touchstart")if(Ca(v.target,"isTracker"))m.runTrackerClick||v.preventDefault();else!de&&!E&&v.preventDefault();
<                         if(E){
<                             z||R();
<                             if(w<Z)w=Z;
<                             else if(w>Z+Ba)w=Z+Ba;
<                             if(L<ea)L=ea;
<                             else if(L>ea+xa)L=ea+xa
---
>         var Y=function(v){
>             if(!(v&&v.touches&&v.touches.length>1)){
>                 v=y(v);
>                 if(!Nb)v.returnValue=false;
>                 var w=v.chartX,L=v.chartY,E=!lc(w-Z,L-ea);
>                 if(Nb&&v.type==="touchstart")if(Ca(v.target,"isTracker"))m.runTrackerClick||v.preventDefault();else!de&&!E&&v.preventDefault();
>                 if(E){
>                     z||R();
>                     if(w<Z)w=Z;
>                     else if(w>Z+Ba)w=Z+Ba;
>                     if(L<ea)L=ea;
>                     else if(L>ea+xa)L=ea+xa
1109,1129c1109,1121
<                             Ka=Math.sqrt(Math.pow(N-w,2)+Math.pow(ba-L,2));
<                             if(Ka>10){
<                                 if(mc&&(Oa||Ya)&&lc(N-Z,ba-ea))za||(za=da.rect(Z,ea,Ea?
<                                     1:Ba,Ia?1:xa,0).attr({
<                                     fill:"rgba(69,114,167,0.25)",
<                                     zIndex:7
<                                 }).add());
<                                 if(za&&Ea){
<                                     w=w-N;
<                                     za.attr({
<                                         width:db(w),
<                                         x:(w>0?0:w)+N
<                                     })
<                                 }
<                                 if(za&&Ia){
<                                     L=L-ba;
<                                     za.attr({
<                                         height:db(L),
<                                         y:(L>0?0:L)+ba
<                                     })
<                                 }
---
>                     Ka=Math.sqrt(Math.pow(N-w,2)+Math.pow(ba-L,2));
>                     if(Ka>10){
>                         if(mc&&(Oa||Ya)&&lc(N-Z,ba-ea))za||(za=da.rect(Z,ea,Ea?
>                             1:Ba,Ia?1:xa,0).attr({
>                             fill:"rgba(69,114,167,0.25)",
>                             zIndex:7
>                         }).add());
>                         if(za&&Ea){
>                             w=w-N;
>                             za.attr({
>                                 width:db(w),
>                                 x:(w>0?0:w)+N
>                                 })
1131,1150c1123,1128
<                         }else if(!E){
<                             var D;
<                             L=m.hoverPoint;
<                             w=m.hoverSeries;
<                             var M,ha,oa=Xa,va=qa?v.chartY:v.chartX-Z;
<                             if(vc&&i.shared){
<                                 D=[];
<                                 M=Ga.length;
<                                 for(ha=0;ha<M;ha++)if(Ga[ha].visible&&Ga[ha].tooltipPoints.length){
<                                     v=Ga[ha].tooltipPoints[va];
<                                     v._dist=db(va-v.plotX);
<                                     oa=qb(oa,v._dist);
<                                     D.push(v)
<                                 }
<                                 for(M=D.length;M--;)D[M]._dist>oa&&D.splice(M,1);
<                                 if(D.length&&
<                                     D[0].plotX!==nd){
<                                     vc.refresh(D);
<                                     nd=D[0].plotX
<                                 }
---
>                             if(za&&Ia){
>                             L=L-ba;
>                             za.attr({
>                                 height:db(L),
>                                 y:(L>0?0:L)+ba
>                                 })
1152d1129
<                             if(w&&w.tracker)(v=w.tooltipPoints[va])&&v!==L&&v.onMouseOver()
1154c1131,1149
<                         return(z=E)||!mc
---
>                 }else if(!E){
>             var D;
>             L=m.hoverPoint;
>             w=m.hoverSeries;
>             var M,ha,oa=Xa,va=qa?v.chartY:v.chartX-Z;
>             if(vc&&i.shared){
>                 D=[];
>                 M=Ga.length;
>                 for(ha=0;ha<M;ha++)if(Ga[ha].visible&&Ga[ha].tooltipPoints.length){
>                     v=Ga[ha].tooltipPoints[va];
>                     v._dist=db(va-v.plotX);
>                     oa=qb(oa,v._dist);
>                     D.push(v)
>                     }
>                     for(M=D.length;M--;)D[M]._dist>oa&&D.splice(M,1);
>                 if(D.length&&
>                     D[0].plotX!==nd){
>                     vc.refresh(D);
>                     nd=D[0].plotX
1156,1163c1151,1156
<                 };
< 
<                 ya.onmousemove=Y;
<                 Sa(ya,"mouseleave",R);
<                 ya.ontouchstart=function(v){
<                     if(Oa||Ya)ya.onmousedown(v);
<                     Y(v)
<                 };
---
>                 }
>             if(w&&w.tracker)(v=w.tooltipPoints[va])&&v!==L&&v.onMouseOver()
>             }
>             return(z=E)||!mc
>         }
>     };
1165,1168c1158,1163
<                 ya.ontouchmove=Y;
<                 ya.ontouchend=function(){
<                     Ka&&R()
<                 };
---
> ya.onmousemove=Y;
> Sa(ya,"mouseleave",R);
> ya.ontouchstart=function(v){
>     if(Oa||Ya)ya.onmousedown(v);
>     Y(v)
>     };
1170,1180c1165,1168
<                 ya.onclick=function(v){
<                     var w=m.hoverPoint;
<                     v=y(v);
<                     v.cancelBubble=true;
<                     if(!Ka)if(w&&Ca(v.target,"isTracker")){
<                         var L=w.plotX,E=w.plotY;
<                         pa(w,{
<                             pageX:uc.left+Z+(qa?Ba-E:L),
<                             pageY:uc.top+ea+(qa?xa-L:E)
<                         });
<                         Pa(w.series,"click",pa(v,
---
> ya.ontouchmove=Y;
> ya.ontouchend=function(){
>     Ka&&R()
>     };
1182,1200c1170,1188
<                         {
<                                 point:w
<                             }));
<                         w.firePointEvent("click",v)
<                     }else{
<                         pa(v,x(v));
<                         lc(v.chartX-Z,v.chartY-ea)&&Pa(m,"click",v)
<                     }
<                     Ka=false
<                 }
<             })();
<             Pd=setInterval(function(){
<                 md&&md()
<             },32);
<             pa(this,{
<                 zoomX:Oa,
<                 zoomY:Ya,
<                 resetTracker:R
<             })
---
> ya.onclick=function(v){
>     var w=m.hoverPoint;
>     v=y(v);
>     v.cancelBubble=true;
>     if(!Ka)if(w&&Ca(v.target,"isTracker")){
>         var L=w.plotX,E=w.plotY;
>         pa(w,{
>             pageX:uc.left+Z+(qa?Ba-E:L),
>             pageY:uc.top+ea+(qa?xa-L:E)
>             });
>         Pa(w.series,"click",pa(v,
> 
>         {
>             point:w
>         }));
>         w.firePointEvent("click",v)
>         }else{
>         pa(v,x(v));
>         lc(v.chartX-Z,v.chartY-ea)&&Pa(m,"click",v)
1202,1217c1190,1225
<         function g(m){
<             var i=m.type||u.type||u.defaultSeriesType,y=vb[i],x=p.hasRendered;
<             if(x)if(qa&&i==="column")y=vb.bar;
<                 else if(!qa&&i==="bar")y=vb.column;
<             i=new y;
<             i.init(p,m);
<             if(!x&&i.inverted)qa=true;
<             if(i.isCartesian)mc=i.isCartesian;
<             Ga.push(i);
<             return i
<         }
<         function h(){
<             u.alignTicks!==false&&t(bb,function(m){
<                 m.adjustTickAmount()
<             });
<             Lb=null
---
>         Ka=false
>     }
> })();
> Pd=setInterval(function(){
>     md&&md()
>     },32);
> pa(this,{
>     zoomX:Oa,
>     zoomY:Ya,
>     resetTracker:R
> })
> }
> function g(m){
>     var i=m.type||u.type||u.defaultSeriesType,y=vb[i],x=p.hasRendered;
>     if(x)if(qa&&i==="column")y=vb.bar;
>         else if(!qa&&i==="bar")y=vb.column;
>     i=new y;
>     i.init(p,m);
>     if(!x&&i.inverted)qa=true;
>     if(i.isCartesian)mc=i.isCartesian;
>     Ga.push(i);
>     return i
>     }
>     function h(){
>     u.alignTicks!==false&&t(bb,function(m){
>         m.adjustTickAmount()
>         });
>     Lb=null
>     }
>     function j(m){
>     var i=p.isDirtyLegend,y,x=p.isDirtyBox,R=Ga.length,na=R,N=p.clipRect;
>     for(fc(m,p);na--;){
>         m=Ga[na];
>         if(m.isDirty&&m.options.stacking){
>             y=true;
>             break
1219,1269c1227,1236
<         function j(m){
<             var i=p.isDirtyLegend,y,x=p.isDirtyBox,R=Ga.length,na=R,N=p.clipRect;
<             for(fc(m,p);na--;){
<                 m=Ga[na];
<                 if(m.isDirty&&m.options.stacking){
<                     y=true;
<                     break
<                 }
<             }
<             if(y)for(na=R;na--;){
<                 m=Ga[na];
<                 if(m.options.stacking)m.isDirty=true
<             }
<             t(Ga,function(ba){
<                 if(ba.isDirty){
<                     ba.cleanData();
<                     ba.getSegments();
<                     if(ba.options.legendType==="point")i=true
<                 }
<             });
<             if(i&&qd.renderLegend){
<                 qd.renderLegend();
<                 p.isDirtyLegend=false
<             }
<             if(mc){
<                 if(!Tc){
<                     Lb=null;
<                     t(bb,function(ba){
<                         ba.setScale()
<                     })
<                 }
<                 h();
<                 wc();
<                 t(bb,function(ba){
<                     if(ba.isDirty||
<                         x){
<                         ba.redraw();
<                         x=true
<                     }
<                 })
<             }
<             if(x){
<                 rd();
<                 Rc();
<                 if(N){
<                     Uc(N);
<                     N.animate({
<                         width:p.plotSizeX,
<                         height:p.plotSizeY
<                     })
<                 }
---
>     }
>     if(y)for(na=R;na--;){
>     m=Ga[na];
>     if(m.options.stacking)m.isDirty=true
>         }
>         t(Ga,function(ba){
>     if(ba.isDirty){
>         ba.cleanData();
>         ba.getSegments();
>         if(ba.options.legendType==="point")i=true
1271,1275c1238,1248
<             t(Ga,function(ba){
<                 if(ba.isDirty&&ba.visible&&(!ba.isCartesian||ba.xAxis))ba.redraw()
<             });
<             kc&&kc.resetTracker&&kc.resetTracker();
<             Pa(p,"redraw")
---
>         });
> if(i&&qd.renderLegend){
>     qd.renderLegend();
>     p.isDirtyLegend=false
>     }
>     if(mc){
>     if(!Tc){
>         Lb=null;
>         t(bb,function(ba){
>             ba.setScale()
>             })
1277,1296c1250,1268
<         function l(){
<             var m=a.xAxis||{},i=a.yAxis||{},y;
<             m=sc(m);
<             t(m,function(x,R){
<                 x.index=R;
<                 x.isX=true
<             });
<             i=sc(i);
<             t(i,function(x,R){
<                 x.index=R
<             });
<             bb=m.concat(i);
<             p.xAxis=[];
<             p.yAxis=[];
<             bb=nc(bb,function(x){
<                 y=new c(p,x);
<                 p[y.isXAxis?"xAxis":"yAxis"].push(y);
<                 return y
<             });
<             h()
---
>         h();
>     wc();
>     t(bb,function(ba){
>         if(ba.isDirty||
>             x){
>             ba.redraw();
>             x=true
>             }
>         })
> }
> if(x){
>     rd();
>     Rc();
>     if(N){
>         Uc(N);
>         N.animate({
>             width:p.plotSizeX,
>             height:p.plotSizeY
>             })
1298,1312c1270,1312
<         function n(m,i){
<             Hb=sa(a.title,m);
<             xc=sa(a.subtitle,i);
<             t([["title",m,Hb],["subtitle",i,xc]],function(y){
<                 var x=y[0],R=p[x],na=y[1];
<                 y=y[2];
<                 if(R&&na){
<                     R.destroy();
<                     R=null
<                 }
<                 if(y&&y.text&&!R)p[x]=da.text(y.text,0,0).attr({
<                     align:y.align,
<                     "class":"highcharts-"+x,
<                     zIndex:1
<                 }).css(y.style).add().align(y,false,Ob)
---
>     }
> t(Ga,function(ba){
>     if(ba.isDirty&&ba.visible&&(!ba.isCartesian||ba.xAxis))ba.redraw()
>         });
> kc&&kc.resetTracker&&kc.resetTracker();
> Pa(p,"redraw")
> }
> function l(){
>     var m=a.xAxis||{},i=a.yAxis||{},y;
>     m=sc(m);
>     t(m,function(x,R){
>         x.index=R;
>         x.isX=true
>         });
>     i=sc(i);
>     t(i,function(x,R){
>         x.index=R
>         });
>     bb=m.concat(i);
>     p.xAxis=[];
>     p.yAxis=[];
>     bb=nc(bb,function(x){
>         y=new c(p,x);
>         p[y.isXAxis?"xAxis":"yAxis"].push(y);
>         return y
>         });
>     h()
>     }
> function n(m,i){
>     Hb=sa(a.title,m);
>     xc=sa(a.subtitle,i);
>     t([["title",m,Hb],["subtitle",i,xc]],function(y){
>         var x=y[0],R=p[x],na=y[1];
>         y=y[2];
>         if(R&&na){
>             R.destroy();
>             R=null
>             }
>             if(y&&y.text&&!R)p[x]=da.text(y.text,0,0).attr({
>             align:y.align,
>             "class":"highcharts-"+x,
>             zIndex:1
>         }).css(y.style).add().align(y,false,Ob)
1313a1314,1327
>     }
>     function C(){
>     mb=u.renderTo;
>     Qd=oc+sd++;
>     if(Qb(mb))mb=wa.getElementById(mb);
>     mb.innerHTML="";
>     if(!mb.offsetWidth){
>         Wb=mb.cloneNode(0);
>         La(Wb,{
>             position:pc,
>             top:"-9999px",
>             display:""
>         });
>         wa.body.appendChild(Wb)
1315,1363c1329,1356
<         function C(){
<             mb=u.renderTo;
<             Qd=oc+sd++;
<             if(Qb(mb))mb=wa.getElementById(mb);
<             mb.innerHTML="";
<             if(!mb.offsetWidth){
<                 Wb=mb.cloneNode(0);
<                 La(Wb,{
<                     position:pc,
<                     top:"-9999px",
<                     display:""
<                 });
<                 wa.body.appendChild(Wb)
<             }
<             Vc=
<             (Wb||mb).offsetWidth;
<             yc=(Wb||mb).offsetHeight;
<             p.chartWidth=Xa=u.width||Vc||600;
<             p.chartHeight=Ra=u.height||(yc>19?yc:400);
<             p.container=ya=ib(Rb,{
<                 className:"highcharts-container"+(u.className?" "+u.className:""),
<                 id:Qd
<             },pa({
<                 position:Rd,
<                 overflow:gb,
<                 width:Xa+$a,
<                 height:Ra+$a,
<                 textAlign:"left"
<             },u.style),Wb||mb);
<             p.renderer=da=u.forExport?new Wc(ya,Xa,Ra,true):new Xc(ya,Xa,Ra);
<             var m,i;
<             if(Sd&&ya.getBoundingClientRect){
<                 m=function(){
<                     La(ya,{
<                         left:0,
<                         top:0
<                     });
<                     i=ya.getBoundingClientRect();
<                     La(ya,{
<                         left:-(i.left-la(i.left))+
<                         $a,
<                         top:-(i.top-la(i.top))+$a
<                     })
<                 };
< 
<                 m();
<                 Sa(ab,"resize",m);
<                 Sa(p,"destroy",function(){
<                     Gb(ab,"resize",m)
---
>         Vc=
>     (Wb||mb).offsetWidth;
>     yc=(Wb||mb).offsetHeight;
>     p.chartWidth=Xa=u.width||Vc||600;
>     p.chartHeight=Ra=u.height||(yc>19?yc:400);
>     p.container=ya=ib(Rb,{
>         className:"highcharts-container"+(u.className?" "+u.className:""),
>         id:Qd
>     },pa({
>         position:Rd,
>         overflow:gb,
>         width:Xa+$a,
>         height:Ra+$a,
>         textAlign:"left"
>     },u.style),Wb||mb);
>     p.renderer=da=u.forExport?new Wc(ya,Xa,Ra,true):new Xc(ya,Xa,Ra);
>     var m,i;
>     if(Sd&&ya.getBoundingClientRect){
>         m=function(){
>             La(ya,{
>                 left:0,
>                 top:0
>             });
>             i=ya.getBoundingClientRect();
>             La(ya,{
>                 left:-(i.left-la(i.left))+
>                 $a,
>                 top:-(i.top-la(i.top))+$a
1365c1358,1364
<             }
---
>             };
> 
>         m();
>         Sa(ab,"resize",m);
>         Sa(p,"destroy",function(){
>             Gb(ab,"resize",m)
>             })
1367,1378c1366,1375
<         function G(){
<             function m(){
<                 var y=u.width||mb.offsetWidth,x=u.height||mb.offsetHeight;
<                 if(y&&x){
<                     if(y!==Vc||x!==yc){
<                         clearTimeout(i);
<                         i=setTimeout(function(){
<                             td(y,x,false)
<                         },100)
<                     }
<                     Vc=y;
<                     yc=x
---
>     }
> function G(){
>     function m(){
>         var y=u.width||mb.offsetWidth,x=u.height||mb.offsetHeight;
>         if(y&&x){
>             if(y!==Vc||x!==yc){
>                 clearTimeout(i);
>                 i=setTimeout(function(){
>                     td(y,x,false)
>                     },100)
1379a1377,1378
>                 Vc=y;
>             yc=x
1381,1385d1379
<             var i;
<             Sa(ab,"resize",m);
<             Sa(p,"destroy",function(){
<                 Gb(ab,"resize",m)
<             })
1387,1421c1381,1421
<         function fa(){
<             var m=a.labels,i=a.credits,y;
<             n();
<             qd=p.legend=new ee(p);
<             wc();
<             t(bb,function(x){
<                 x.setTickPositions(true)
<             });
<             h();
<             wc();
<             rd();
<             mc&&t(bb,function(x){
<                 x.render()
<             });
<             if(!p.seriesGroup)p.seriesGroup=da.g("series-group").attr({
<                 zIndex:3
<             }).add();
<             t(Ga,function(x){
<                 x.translate();
<                 x.setTooltipPoints();
<                 x.render()
<             });
<             m.items&&t(m.items,function(){
<                 var x=pa(m.style,this.style),R=la(x.left)+Z,na=la(x.top)+ea+12;
<                 delete x.left;
<                 delete x.top;
<                 da.text(this.html,R,na).attr({
<                     zIndex:2
<                 }).css(x).add()
<             });
<             if(!p.toolbar)p.toolbar=d(p);
<             if(i.enabled&&!p.credits){
<                 y=i.href;
<                 da.text(i.text,0,0).on("click",function(){
<                     if(y)location.href=y
---
>     var i;
> Sa(ab,"resize",m);
> Sa(p,"destroy",function(){
>     Gb(ab,"resize",m)
>     })
> }
> function fa(){
>     var m=a.labels,i=a.credits,y;
>     n();
>     qd=p.legend=new ee(p);
>     wc();
>     t(bb,function(x){
>         x.setTickPositions(true)
>         });
>     h();
>     wc();
>     rd();
>     mc&&t(bb,function(x){
>         x.render()
>         });
>     if(!p.seriesGroup)p.seriesGroup=da.g("series-group").attr({
>         zIndex:3
>     }).add();
>     t(Ga,function(x){
>         x.translate();
>         x.setTooltipPoints();
>         x.render()
>         });
>     m.items&&t(m.items,function(){
>         var x=pa(m.style,this.style),R=la(x.left)+Z,na=la(x.top)+ea+12;
>         delete x.left;
>         delete x.top;
>         da.text(this.html,R,na).attr({
>             zIndex:2
>         }).css(x).add()
>         });
>     if(!p.toolbar)p.toolbar=d(p);
>     if(i.enabled&&!p.credits){
>         y=i.href;
>         da.text(i.text,0,0).on("click",function(){
>             if(y)location.href=y
1423,1474c1423,1515
<                     align:i.position.align,
<                     zIndex:8
<                 }).css(i.style).add().align(i.position)
<             }
<             Rc();
<             p.hasRendered=true;
<             if(Wb){
<                 mb.appendChild(ya);
<                 Hc(Wb)
<             }
<         }
<         function K(){
<             var m=Ga.length,i=ya&&ya.parentNode;
<             Pa(p,"destroy");
<             Gb(ab,"unload",K);
<             Gb(p);
<             for(t(bb,function(y){
<                 Gb(y)
<             });m--;)Ga[m].destroy();
<             if(ya){
<                 ya.innerHTML="";
<                 Gb(ya);
<                 i&&i.removeChild(ya);
<                 ya=null
<             }
<             if(da)da.alignedObjects=null;
<             clearInterval(Pd);
<             for(m in p)delete p[m]
<         }
<         function ia(){
<             if(!zc&&ab==ab.top&&wa.readyState!=="complete")wa.attachEvent("onreadystatechange",function(){
<                 wa.detachEvent("onreadystatechange",ia);
<                 wa.readyState==="complete"&&ia()
<             });
<             else{
<                 Yc=Pb=0;
<                 C();
<                 ud();
<                 vd();
<                 t(a.series||[],function(m){
<                     g(m)
<                 });
<                 p.inverted=qa=B(qa,a.chart.inverted);
<                 l();
<                 p.render=fa;
<                 p.tracker=kc=new f(p,a.tooltip);
<                 fa();
<                 Pa(p,"load");
<                 b&&b.apply(p,[p]);
<                 t(p.callbacks,function(m){
<                     m.apply(p,[p])
<                 })
---
>             align:i.position.align,
>             zIndex:8
>         }).css(i.style).add().align(i.position)
>         }
>         Rc();
>     p.hasRendered=true;
>     if(Wb){
>         mb.appendChild(ya);
>         Hc(Wb)
>         }
>     }
> function K(){
>     var m=Ga.length,i=ya&&ya.parentNode;
>     Pa(p,"destroy");
>     Gb(ab,"unload",K);
>     Gb(p);
>     for(t(bb,function(y){
>         Gb(y)
>         });m--;)Ga[m].destroy();
>     if(ya){
>         ya.innerHTML="";
>         Gb(ya);
>         i&&i.removeChild(ya);
>         ya=null
>         }
>         if(da)da.alignedObjects=null;
>     clearInterval(Pd);
>     for(m in p)delete p[m]
>     }
>     function ia(){
>     if(!zc&&ab==ab.top&&wa.readyState!=="complete")wa.attachEvent("onreadystatechange",function(){
>         wa.detachEvent("onreadystatechange",ia);
>         wa.readyState==="complete"&&ia()
>         });
>     else{
>         Yc=Pb=0;
>         C();
>         ud();
>         vd();
>         t(a.series||[],function(m){
>             g(m)
>             });
>         p.inverted=qa=B(qa,a.chart.inverted);
>         l();
>         p.render=fa;
>         p.tracker=kc=new f(p,a.tooltip);
>         fa();
>         Pa(p,"load");
>         b&&b.apply(p,[p]);
>         t(p.callbacks,function(m){
>             m.apply(p,[p])
>             })
>         }
>     }
> Nc=sa(Nc,Va.xAxis);
> jd=sa(jd,Va.yAxis);
> Va.xAxis=Va.yAxis=null;
> a=sa(Va,a);
> var u=a.chart,P=u.margin;
> P=Kb(P)?P:[P,P,P,P];
> var O=B(u.marginTop,P[0]),Q=B(u.marginRight,P[1]),H=B(u.marginBottom,P[2]),S=B(u.marginLeft,P[3]),Ta=u.spacingTop,cb=u.spacingRight,Ib=u.spacingBottom,Jb=u.spacingLeft,
> Ob,Hb,xc,ea,Eb,sb,Z,Vb,mb,Wb,ya,Qd,Vc,yc,Xa,Ra,ld,Qc,Zc,wd,xd,$c,p=this,de=(P=u.events)&&!!P.click,yd,lc,vc,pd,dc,Td,zd,xa,Ba,kc,Sc,Rc,qd,Xb,Yb,uc,mc=u.showAxes,Tc=0,bb=[],Lb,Ga=[],qa,da,md,Pd,nd,rd,wc,ud,vd,td,od,Ud,ee=function(m){
>     function i(I,ja){
>         var T=I.legendItem,ra=I.legendLine,Da=I.legendSymbol,Ha=Ia.color,Ma=ja?N.itemStyle.color:Ha,ca=ja?I.color:Ha;
>         Ha=ja?I.pointAttr[hb]:{
>             stroke:Ha,
>             fill:Ha
>         };
> 
>         T&&T.css({
>             fill:Ma
>         });
>         ra&&ra.attr({
>             stroke:ca
>         });
>         Da&&Da.attr(Ha)
>         }
>         function y(I,ja,T){
>         var ra=I.legendItem,Da=
>         I.legendLine,Ha=I.legendSymbol;
>         I=I.checkbox;
>         ra&&ra.attr({
>             x:ja,
>             y:T
>         });
>         Da&&Da.translate(ja,T-4);
>         Ha&&Ha.attr({
>             x:ja+Ha.xOff,
>             y:T+Ha.yOff
>             });
>         if(I){
>             I.x=ja;
>             I.y=T
1477,1489c1518,1542
<         Nc=sa(Nc,Va.xAxis);
<         jd=sa(jd,Va.yAxis);
<         Va.xAxis=Va.yAxis=null;
<         a=sa(Va,a);
<         var u=a.chart,P=u.margin;
<         P=Kb(P)?P:[P,P,P,P];
<         var O=B(u.marginTop,P[0]),Q=B(u.marginRight,P[1]),H=B(u.marginBottom,P[2]),S=B(u.marginLeft,P[3]),Ta=u.spacingTop,cb=u.spacingRight,Ib=u.spacingBottom,Jb=u.spacingLeft,
<         Ob,Hb,xc,ea,Eb,sb,Z,Vb,mb,Wb,ya,Qd,Vc,yc,Xa,Ra,ld,Qc,Zc,wd,xd,$c,p=this,de=(P=u.events)&&!!P.click,yd,lc,vc,pd,dc,Td,zd,xa,Ba,kc,Sc,Rc,qd,Xb,Yb,uc,mc=u.showAxes,Tc=0,bb=[],Lb,Ga=[],qa,da,md,Pd,nd,rd,wc,ud,vd,td,od,Ud,ee=function(m){
<             function i(I,ja){
<                 var T=I.legendItem,ra=I.legendLine,Da=I.legendSymbol,Ha=Ia.color,Ma=ja?N.itemStyle.color:Ha,ca=ja?I.color:Ha;
<                 Ha=ja?I.pointAttr[hb]:{
<                     stroke:Ha,
<                     fill:Ha
---
>     function x(){
>     t(Na,function(I){
>         var ja=I.checkbox,T=fb.alignAttr;
>         ja&&La(ja,{
>             left:T.translateX+I.legendItemWidth+ja.x-40+$a,
>             top:T.translateY+ja.y-11+$a
>             })
>         })
>     }
>     function R(I){
>     var ja,T,ra,Da,Ha=I.legendItem;
>     Da=I.series||I;
>     var Ma=Da.options,ca=Ma&&Ma.borderWidth||0;
>     if(!Ha){
>         Da=/^(bar|pie|area|column)$/.test(Da.type);
>         I.legendItem=Ha=da.text(N.labelFormatter.call(I),
>             0,0).css(I.visible?Ya:Ia).on("mouseover",function(){
>             I.setState(Ab);
>             Ha.css(Ea)
>             }).on("mouseout",function(){
>             Ha.css(I.visible?Ya:Ia);
>             I.setState()
>             }).on("click",function(){
>             var Db=function(){
>                 I.setVisible()
1492,1516c1545,1556
<                 T&&T.css({
<                     fill:Ma
<                 });
<                 ra&&ra.attr({
<                     stroke:ca
<                 });
<                 Da&&Da.attr(Ha)
<             }
<             function y(I,ja,T){
<                 var ra=I.legendItem,Da=
<                 I.legendLine,Ha=I.legendSymbol;
<                 I=I.checkbox;
<                 ra&&ra.attr({
<                     x:ja,
<                     y:T
<                 });
<                 Da&&Da.translate(ja,T-4);
<                 Ha&&Ha.attr({
<                     x:ja+Ha.xOff,
<                     y:T+Ha.yOff
<                 });
<                 if(I){
<                     I.x=ja;
<                     I.y=T
<                 }
---
>             I.firePointEvent?I.firePointEvent("legendItemClick",null,Db):Pa(I,"legendItemClick",null,Db)
>             }).attr({
>             zIndex:2
>         }).add(fb);
>         if(!Da&&Ma&&Ma.lineWidth){
>             var aa={
>                 "stroke-width":Ma.lineWidth,
>                 zIndex:2
>             };
> 
>             if(Ma.dashStyle)aa.dashstyle=Ma.dashStyle;
>             I.legendLine=da.path([Za,-Ka-za,0,Ja,-za,0]).attr(aa).add(fb)
1518,1523c1558,1581
<             function x(){
<                 t(Na,function(I){
<                     var ja=I.checkbox,T=fb.alignAttr;
<                     ja&&La(ja,{
<                         left:T.translateX+I.legendItemWidth+ja.x-40+$a,
<                         top:T.translateY+ja.y-11+$a
---
>             if(Da)ja=
>             da.rect(T=-Ka-za,ra=-11,Ka,12,2).attr({
>                 zIndex:3
>             }).add(fb);
>         else if(Ma&&Ma.marker&&Ma.marker.enabled)ja=da.symbol(I.symbol,T=-Ka/2-za,ra=-4,Ma.marker.radius).attr({
>             zIndex:3
>         }).add(fb);
>         if(ja){
>             ja.xOff=T+ca%2/2;
>             ja.yOff=ra+ca%2/2
>             }
>             I.legendSymbol=ja;
>         i(I,I.visible);
>         if(Ma&&Ma.showCheckbox){
>             I.checkbox=ib("input",{
>                 type:"checkbox",
>                 checked:I.selected,
>                 defaultChecked:I.selected
>                 },N.itemCheckboxStyle,ya);
>             Sa(I.checkbox,"click",function(Db){
>                 Pa(I,"checkboxClick",{
>                     checked:Db.target.checked
>                     },function(){
>                     I.select()
1527,1597c1585,1633
<             function R(I){
<                 var ja,T,ra,Da,Ha=I.legendItem;
<                 Da=I.series||I;
<                 var Ma=Da.options,ca=Ma&&Ma.borderWidth||0;
<                 if(!Ha){
<                     Da=/^(bar|pie|area|column)$/.test(Da.type);
<                     I.legendItem=Ha=da.text(N.labelFormatter.call(I),
<                         0,0).css(I.visible?Ya:Ia).on("mouseover",function(){
<                         I.setState(Ab);
<                         Ha.css(Ea)
<                     }).on("mouseout",function(){
<                         Ha.css(I.visible?Ya:Ia);
<                         I.setState()
<                     }).on("click",function(){
<                         var Db=function(){
<                             I.setVisible()
<                         };
< 
<                         I.firePointEvent?I.firePointEvent("legendItemClick",null,Db):Pa(I,"legendItemClick",null,Db)
<                     }).attr({
<                         zIndex:2
<                     }).add(fb);
<                     if(!Da&&Ma&&Ma.lineWidth){
<                         var aa={
<                             "stroke-width":Ma.lineWidth,
<                             zIndex:2
<                         };
< 
<                         if(Ma.dashStyle)aa.dashstyle=Ma.dashStyle;
<                         I.legendLine=da.path([Za,-Ka-za,0,Ja,-za,0]).attr(aa).add(fb)
<                     }
<                     if(Da)ja=
<                         da.rect(T=-Ka-za,ra=-11,Ka,12,2).attr({
<                             zIndex:3
<                         }).add(fb);
<                     else if(Ma&&Ma.marker&&Ma.marker.enabled)ja=da.symbol(I.symbol,T=-Ka/2-za,ra=-4,Ma.marker.radius).attr({
<                         zIndex:3
<                     }).add(fb);
<                     if(ja){
<                         ja.xOff=T+ca%2/2;
<                         ja.yOff=ra+ca%2/2
<                     }
<                     I.legendSymbol=ja;
<                     i(I,I.visible);
<                     if(Ma&&Ma.showCheckbox){
<                         I.checkbox=ib("input",{
<                             type:"checkbox",
<                             checked:I.selected,
<                             defaultChecked:I.selected
<                         },N.itemCheckboxStyle,ya);
<                         Sa(I.checkbox,"click",function(Db){
<                             Pa(I,"checkboxClick",{
<                                 checked:Db.target.checked
<                             },function(){
<                                 I.select()
<                             })
<                         })
<                     }
<                 }
<                 ja=
<                 Ha.getBBox();
<                 T=I.legendItemWidth=N.itemWidth||Ka+za+ja.width+Y;
<                 M=ja.height;
<                 if(ba&&L-w+T>(Fb||Xa-2*z-w)){
<                     L=w;
<                     E+=M
<                 }
<                 D=E;
<                 y(I,L,E);
<                 if(ba)L+=T;else E+=M;
<                 eb=Fb||Fa(ba?L-w:T,eb)
---
>         }
>     ja=
> Ha.getBBox();
> T=I.legendItemWidth=N.itemWidth||Ka+za+ja.width+Y;
> M=ja.height;
> if(ba&&L-w+T>(Fb||Xa-2*z-w)){
>     L=w;
>     E+=M
>     }
>     D=E;
> y(I,L,E);
> if(ba)L+=T;else E+=M;
> eb=Fb||Fa(ba?L-w:T,eb)
> }
> function na(){
>     L=w;
>     E=v;
>     D=eb=0;
>     fb||(fb=da.g("legend").attr({
>         zIndex:7
>     }).add());
>     Na=[];
>     t(Ub,function(ra){
>         var Da=ra.options;
>         if(Da.showInLegend)Na=Na.concat(Da.legendType==="point"?ra.data:ra)
>             });
>     Na.sort(function(ra,Da){
>         return(ra.options.legendIndex||0)-(Da.options.legendIndex||0)
>         });
>     hc&&Na.reverse();
>     t(Na,R);
>     Xb=Fb||eb;
>     Yb=D-v+M;
>     if(oa||va){
>         Xb+=
>         2*z;
>         Yb+=2*z;
>         if(ha)Xb>0&&Yb>0&&ha.animate(ha.crisp(null,null,null,Xb,Yb));else ha=da.rect(0,0,Xb,Yb,N.borderRadius,oa||0).attr({
>             stroke:N.borderColor,
>             "stroke-width":oa||0,
>             fill:va||jb
>             }).add(fb).shadow(N.shadow);
>         ha[Na.length?"show":"hide"]()
>         }
>         for(var I=["left","right","top","bottom"],ja,T=4;T--;){
>         ja=I[T];
>         if(Oa[ja]&&Oa[ja]!=="auto"){
>             N[T<2?"align":"verticalAlign"]=ja;
>             N[T<2?"x":"y"]=la(Oa[ja])*(T%2?-1:1)
1599,1612c1635,1653
<             function na(){
<                 L=w;
<                 E=v;
<                 D=eb=0;
<                 fb||(fb=da.g("legend").attr({
<                     zIndex:7
<                 }).add());
<                 Na=[];
<                 t(Ub,function(ra){
<                     var Da=ra.options;
<                     if(Da.showInLegend)Na=Na.concat(Da.legendType==="point"?ra.data:ra)
<                 });
<                 Na.sort(function(ra,Da){
<                     return(ra.options.legendIndex||0)-(Da.options.legendIndex||0)
---
>         }
>     fb.align(pa(N,{
>     width:Xb,
>     height:Yb
> }),true,Ob);
> Tc||x()
> }
> var N=m.options.legend;
> if(N.enabled){
>     var ba=N.layout===
>     "horizontal",Ka=N.symbolWidth,za=N.symbolPadding,Na,Oa=N.style,Ya=N.itemStyle,Ea=N.itemHoverStyle,Ia=N.itemHiddenStyle,z=la(Oa.padding),Y=20,v=18,w=4+z+Ka+za,L,E,D,M=0,ha,oa=N.borderWidth,va=N.backgroundColor,fb,eb,Fb=N.width,Ub=m.series,hc=N.reversed;
>     na();
>     Sa(m,"endResize",x);
>     return{
>         colorizeItem:i,
>         destroyItem:function(I){
>             var ja=I.checkbox;
>             t(["legendItem","legendLine","legendSymbol"],function(T){
>                 I[T]&&I[T].destroy()
1614,1660c1655,1660
<                 hc&&Na.reverse();
<                 t(Na,R);
<                 Xb=Fb||eb;
<                 Yb=D-v+M;
<                 if(oa||va){
<                     Xb+=
<                     2*z;
<                     Yb+=2*z;
<                     if(ha)Xb>0&&Yb>0&&ha.animate(ha.crisp(null,null,null,Xb,Yb));else ha=da.rect(0,0,Xb,Yb,N.borderRadius,oa||0).attr({
<                         stroke:N.borderColor,
<                         "stroke-width":oa||0,
<                         fill:va||jb
<                     }).add(fb).shadow(N.shadow);
<                     ha[Na.length?"show":"hide"]()
<                 }
<                 for(var I=["left","right","top","bottom"],ja,T=4;T--;){
<                     ja=I[T];
<                     if(Oa[ja]&&Oa[ja]!=="auto"){
<                         N[T<2?"align":"verticalAlign"]=ja;
<                         N[T<2?"x":"y"]=la(Oa[ja])*(T%2?-1:1)
<                     }
<                 }
<                 fb.align(pa(N,{
<                     width:Xb,
<                     height:Yb
<                 }),true,Ob);
<                 Tc||x()
<             }
<             var N=m.options.legend;
<             if(N.enabled){
<                 var ba=N.layout===
<                 "horizontal",Ka=N.symbolWidth,za=N.symbolPadding,Na,Oa=N.style,Ya=N.itemStyle,Ea=N.itemHoverStyle,Ia=N.itemHiddenStyle,z=la(Oa.padding),Y=20,v=18,w=4+z+Ka+za,L,E,D,M=0,ha,oa=N.borderWidth,va=N.backgroundColor,fb,eb,Fb=N.width,Ub=m.series,hc=N.reversed;
<                 na();
<                 Sa(m,"endResize",x);
<                 return{
<                     colorizeItem:i,
<                     destroyItem:function(I){
<                         var ja=I.checkbox;
<                         t(["legendItem","legendLine","legendSymbol"],function(T){
<                             I[T]&&I[T].destroy()
<                         });
<                         ja&&Hc(I.checkbox)
<                     },
<                     renderLegend:na
<                 }
<             }
<         };
---
>             ja&&Hc(I.checkbox)
>             },
>         renderLegend:na
>     }
> }
> };
1662,1665c1662,1665
<         lc=function(m,i){
<             return m>=0&&m<=Ba&&i>=0&&
<             i<=xa
<         };
---
> lc=function(m,i){
>     return m>=0&&m<=Ba&&i>=0&&
>     i<=xa
>     };
1667,1672c1667,1672
<         Ud=function(){
<             Pa(p,"selection",{
<                 resetSelection:true
<             },od);
<             p.toolbar.remove("zoom")
<         };
---
> Ud=function(){
>     Pa(p,"selection",{
>         resetSelection:true
>     },od);
>     p.toolbar.remove("zoom")
>     };
1674,1681c1674,1681
<         od=function(m){
<             var i=Va.lang,y=p.pointCount<100;
<             p.toolbar.add("zoom",i.resetZoom,i.resetZoomTitle,Ud);
<             !m||m.resetSelection?t(bb,function(x){
<                 x.setExtremes(null,null,false,y)
<             }):t(m.xAxis.concat(m.yAxis),function(x){
<                 var R=x.axis;
<                 if(p.tracker[R.isXAxis?"zoomX":"zoomY"])R.setExtremes(x.min,x.max,false,y)
---
> od=function(m){
>     var i=Va.lang,y=p.pointCount<100;
>     p.toolbar.add("zoom",i.resetZoom,i.resetZoomTitle,Ud);
>     !m||m.resetSelection?t(bb,function(x){
>         x.setExtremes(null,null,false,y)
>         }):t(m.xAxis.concat(m.yAxis),function(x){
>         var R=x.axis;
>         if(p.tracker[R.isXAxis?"zoomX":"zoomY"])R.setExtremes(x.min,x.max,false,y)
1683,1684c1683,1684
<             j()
<         };
---
>     j()
>     };
1686,1703c1686,1703
<         wc=function(){
<             var m=a.legend,i=B(m.margin,10),y=m.x,x=m.y,R=m.align,na=m.verticalAlign,N;
<             ud();
<             if((p.title||
<                 p.subtitle)&&!J(O))if(N=Fa(p.title&&!Hb.floating&&!Hb.verticalAlign&&Hb.y||0,p.subtitle&&!xc.floating&&!xc.verticalAlign&&xc.y||0))ea=Fa(ea,N+B(Hb.margin,15)+Ta);
<             if(m.enabled&&!m.floating)if(R==="right")J(Q)||(Eb=Fa(Eb,Xb-y+i+cb));
<                 else if(R==="left")J(S)||(Z=Fa(Z,Xb+y+i+Jb));
<                 else if(na==="top")J(O)||(ea=Fa(ea,Yb+x+i+Ta));
<                 else if(na==="bottom")J(H)||(sb=Fa(sb,Yb-x+i+Ib));
<             mc&&t(bb,function(ba){
<                 ba.getOffset()
<             });
<             J(S)||(Z+=Vb[3]);
<             J(O)||(ea+=Vb[0]);
<             J(H)||(sb+=Vb[2]);
<             J(Q)||(Eb+=Vb[1]);
<             vd()
<         };
---
> wc=function(){
>     var m=a.legend,i=B(m.margin,10),y=m.x,x=m.y,R=m.align,na=m.verticalAlign,N;
>     ud();
>     if((p.title||
>         p.subtitle)&&!J(O))if(N=Fa(p.title&&!Hb.floating&&!Hb.verticalAlign&&Hb.y||0,p.subtitle&&!xc.floating&&!xc.verticalAlign&&xc.y||0))ea=Fa(ea,N+B(Hb.margin,15)+Ta);
>     if(m.enabled&&!m.floating)if(R==="right")J(Q)||(Eb=Fa(Eb,Xb-y+i+cb));
>         else if(R==="left")J(S)||(Z=Fa(Z,Xb+y+i+Jb));
>         else if(na==="top")J(O)||(ea=Fa(ea,Yb+x+i+Ta));
>         else if(na==="bottom")J(H)||(sb=Fa(sb,Yb-x+i+Ib));
>     mc&&t(bb,function(ba){
>         ba.getOffset()
>         });
>     J(S)||(Z+=Vb[3]);
>     J(O)||(ea+=Vb[0]);
>     J(H)||(sb+=Vb[2]);
>     J(Q)||(Eb+=Vb[1]);
>     vd()
>     };
1705,1742c1705,1742
<         td=function(m,
<             i,y){
<             var x=p.title,R=p.subtitle;
<             Tc+=1;
<             fc(y,p);
<             Qc=Ra;
<             ld=Xa;
<             p.chartWidth=Xa=X(m);
<             p.chartHeight=Ra=X(i);
<             La(ya,{
<                 width:Xa+$a,
<                 height:Ra+$a
<             });
<             da.setSize(Xa,Ra,y);
<             Ba=Xa-Z-Eb;
<             xa=Ra-ea-sb;
<             Lb=null;
<             t(bb,function(na){
<                 na.isDirty=true;
<                 na.setScale()
<             });
<             t(Ga,function(na){
<                 na.isDirty=true
<             });
<             p.isDirtyLegend=true;
<             p.isDirtyBox=true;
<             wc();
<             x&&x.align(null,null,Ob);
<             R&&R.align(null,null,Ob);
<             j(y);
<             Qc=null;
<             Pa(p,"resize");
<             setTimeout(function(){
<                 Pa(p,"endResize",null,function(){
<                     Tc-=1
<                 })
<             },Dc&&Dc.duration||500)
<         };
---
> td=function(m,
>     i,y){
>     var x=p.title,R=p.subtitle;
>     Tc+=1;
>     fc(y,p);
>     Qc=Ra;
>     ld=Xa;
>     p.chartWidth=Xa=X(m);
>     p.chartHeight=Ra=X(i);
>     La(ya,{
>         width:Xa+$a,
>         height:Ra+$a
>         });
>     da.setSize(Xa,Ra,y);
>     Ba=Xa-Z-Eb;
>     xa=Ra-ea-sb;
>     Lb=null;
>     t(bb,function(na){
>         na.isDirty=true;
>         na.setScale()
>         });
>     t(Ga,function(na){
>         na.isDirty=true
>         });
>     p.isDirtyLegend=true;
>     p.isDirtyBox=true;
>     wc();
>     x&&x.align(null,null,Ob);
>     R&&R.align(null,null,Ob);
>     j(y);
>     Qc=null;
>     Pa(p,"resize");
>     setTimeout(function(){
>         Pa(p,"endResize",null,function(){
>             Tc-=1
>             })
>         },Dc&&Dc.duration||500)
>     };
1744,1758c1744,1758
<         vd=function(){
<             p.plotLeft=
<             Z=X(Z);
<             p.plotTop=ea=X(ea);
<             p.plotWidth=Ba=X(Xa-Z-Eb);
<             p.plotHeight=xa=X(Ra-ea-sb);
<             p.plotSizeX=qa?xa:Ba;
<             p.plotSizeY=qa?Ba:xa;
<             Ob={
<                 x:Jb,
<                 y:Ta,
<                 width:Xa-Jb-cb,
<                 height:Ra-Ta-Ib
<             }
<         };
---
> vd=function(){
>     p.plotLeft=
>     Z=X(Z);
>     p.plotTop=ea=X(ea);
>     p.plotWidth=Ba=X(Xa-Z-Eb);
>     p.plotHeight=xa=X(Ra-ea-sb);
>     p.plotSizeX=qa?xa:Ba;
>     p.plotSizeY=qa?Ba:xa;
>     Ob={
>         x:Jb,
>         y:Ta,
>         width:Xa-Jb-cb,
>         height:Ra-Ta-Ib
>         }
>     };
1760,1766c1760,1766
<         ud=function(){
<             ea=B(O,Ta);
<             Eb=B(Q,cb);
<             sb=B(H,Ib);
<             Z=B(S,Jb);
<             Vb=[0,0,0,0]
<         };
---
> ud=function(){
>     ea=B(O,Ta);
>     Eb=B(Q,cb);
>     sb=B(H,Ib);
>     Z=B(S,Jb);
>     Vb=[0,0,0,0]
>     };
1768,1774c1768,1774
<         rd=function(){
<             var m=u.borderWidth||0,i=u.backgroundColor,y=u.plotBackgroundColor,x=u.plotBackgroundImage,R,na={
<                 x:Z,
<                 y:ea,
<                 width:Ba,
<                 height:xa
<             };
---
> rd=function(){
>     var m=u.borderWidth||0,i=u.backgroundColor,y=u.plotBackgroundColor,x=u.plotBackgroundImage,R,na={
>         x:Z,
>         y:ea,
>         width:Ba,
>         height:xa
>     };
1776,1793c1776,1793
<             R=m+(u.shadow?8:0);
<             if(m||i)if(Zc)Zc.animate(Zc.crisp(null,null,null,Xa-R,Ra-R));else Zc=da.rect(R/2,R/2,Xa-R,Ra-R,u.borderRadius,
<                 m).attr({
<                 stroke:u.borderColor,
<                 "stroke-width":m,
<                 fill:i||jb
<             }).add().shadow(u.shadow);
<             if(y)if(wd)wd.animate(na);else wd=da.rect(Z,ea,Ba,xa,0).attr({
<                 fill:y
<             }).add().shadow(u.plotShadow);
<             if(x)if(xd)xd.animate(na);else xd=da.image(x,Z,ea,Ba,xa).add();
<             if(u.plotBorderWidth)if($c)$c.animate($c.crisp(null,Z,ea,Ba,xa));else $c=da.rect(Z,ea,Ba,xa,0,u.plotBorderWidth).attr({
<                 stroke:u.plotBorderColor,
<                 "stroke-width":u.plotBorderWidth,
<                 zIndex:4
<             }).add();
<             p.isDirtyBox=false
<         };
---
>     R=m+(u.shadow?8:0);
>     if(m||i)if(Zc)Zc.animate(Zc.crisp(null,null,null,Xa-R,Ra-R));else Zc=da.rect(R/2,R/2,Xa-R,Ra-R,u.borderRadius,
>         m).attr({
>         stroke:u.borderColor,
>         "stroke-width":m,
>         fill:i||jb
>         }).add().shadow(u.shadow);
>     if(y)if(wd)wd.animate(na);else wd=da.rect(Z,ea,Ba,xa,0).attr({
>         fill:y
>     }).add().shadow(u.plotShadow);
>     if(x)if(xd)xd.animate(na);else xd=da.image(x,Z,ea,Ba,xa).add();
>     if(u.plotBorderWidth)if($c)$c.animate($c.crisp(null,Z,ea,Ba,xa));else $c=da.rect(Z,ea,Ba,xa,0,u.plotBorderWidth).attr({
>         stroke:u.plotBorderColor,
>         "stroke-width":u.plotBorderWidth,
>         zIndex:4
>     }).add();
>     p.isDirtyBox=false
>     };
1795,1815c1795,1815
<         Sa(ab,"unload",K);
<         u.reflow!==false&&Sa(p,"load",
<             G);
<         if(P)for(yd in P)Sa(p,yd,P[yd]);p.options=a;
<         p.series=Ga;
<         p.addSeries=function(m,i,y){
<             var x;
<             if(m){
<                 fc(y,p);
<                 i=B(i,true);
<                 Pa(p,"addSeries",{
<                     options:m
<                 },function(){
<                     x=g(m);
<                     x.isDirty=true;
<                     p.isDirtyLegend=true;
<                     i&&p.redraw()
<                 })
<             }
<             return x
<         };
---
> Sa(ab,"unload",K);
> u.reflow!==false&&Sa(p,"load",
>     G);
> if(P)for(yd in P)Sa(p,yd,P[yd]);p.options=a;
> p.series=Ga;
> p.addSeries=function(m,i,y){
>     var x;
>     if(m){
>         fc(y,p);
>         i=B(i,true);
>         Pa(p,"addSeries",{
>             options:m
>         },function(){
>             x=g(m);
>             x.isDirty=true;
>             p.isDirtyLegend=true;
>             i&&p.redraw()
>             })
>         }
>         return x
>     };
1817,1823c1817,1823
<         p.animation=B(u.animation,true);
<         p.destroy=K;
<         p.get=function(m){
<             var i,y,x;
<             for(i=0;i<bb.length;i++)if(bb[i].options.id===m)return bb[i];for(i=0;i<Ga.length;i++)if(Ga[i].options.id===m)return Ga[i];for(i=0;i<Ga.length;i++){
<                 x=Ga[i].data;
<                 for(y=0;y<x.length;y++)if(x[y].id===m)return x[y]
---
> p.animation=B(u.animation,true);
> p.destroy=K;
> p.get=function(m){
>     var i,y,x;
>     for(i=0;i<bb.length;i++)if(bb[i].options.id===m)return bb[i];for(i=0;i<Ga.length;i++)if(Ga[i].options.id===m)return Ga[i];for(i=0;i<Ga.length;i++){
>         x=Ga[i].data;
>         for(y=0;y<x.length;y++)if(x[y].id===m)return x[y]
1826,1835c1826,1841
<         };
<         p.getSelectedPoints=function(){
<             var m=[];
<             t(Ga,function(i){
<                 m=m.concat(Ad(i.data,function(y){
<                     return y.selected
<                 }))
<             });
<             return m
<         };
---
>     };
> p.getSelectedPoints=function(){
>     var m=[];
>     t(Ga,function(i){
>         m=m.concat(Ad(i.data,function(y){
>             return y.selected
>             }))
>         });
>     return m
>     };
> 
> p.getSelectedSeries=function(){
>     return Ad(Ga,function(m){
>         return m.selected
>         })
>     };
1837,1839c1843,1850
<         p.getSelectedSeries=function(){
<             return Ad(Ga,function(m){
<                 return m.selected
---
> p.hideLoading=function(){
>     ad(dc,{
>         opacity:0
>     },{
>         duration:a.loading.hideDuration,
>         complete:function(){
>             La(dc,{
>                 display:jb
1841c1852,1855
<         };
---
>             }
>         });
> zd=false
> };
1843,1845c1857,1884
<         p.hideLoading=function(){
<             ad(dc,{
<                 opacity:0
---
> p.isInsidePlot=lc;
> p.redraw=j;
> p.setSize=td;
> p.setTitle=n;
> p.showLoading=function(m){
>     var i=a.loading;
>     if(!dc){
>         dc=ib(Rb,{
>             className:"highcharts-loading"
>         },pa(i.style,{
>             left:Z+$a,
>             top:ea+
>             $a,
>             width:Ba+$a,
>             height:xa+$a,
>             zIndex:10,
>             display:jb
>         }),ya);
>         Td=ib("span",null,i.labelStyle,dc)
>         }
>         Td.innerHTML=m||a.lang.loading;
>     if(!zd){
>         La(dc,{
>             opacity:0,
>             display:""
>         });
>         ad(dc,{
>             opacity:i.style.opacity
1847,1852c1886
<                 duration:a.loading.hideDuration,
<                 complete:function(){
<                     La(dc,{
<                         display:jb
<                     })
<                 }
---
>             duration:i.showDuration
1854,1890c1888,1890
<             zd=false
<         };
< 
<         p.isInsidePlot=lc;
<         p.redraw=j;
<         p.setSize=td;
<         p.setTitle=n;
<         p.showLoading=function(m){
<             var i=a.loading;
<             if(!dc){
<                 dc=ib(Rb,{
<                     className:"highcharts-loading"
<                 },pa(i.style,{
<                     left:Z+$a,
<                     top:ea+
<                     $a,
<                     width:Ba+$a,
<                     height:xa+$a,
<                     zIndex:10,
<                     display:jb
<                 }),ya);
<                 Td=ib("span",null,i.labelStyle,dc)
<             }
<             Td.innerHTML=m||a.lang.loading;
<             if(!zd){
<                 La(dc,{
<                     opacity:0,
<                     display:""
<                 });
<                 ad(dc,{
<                     opacity:i.style.opacity
<                 },{
<                     duration:i.showDuration
<                 });
<                 zd=true
<             }
<         };
---
>         zd=true
>         }
>     };
1892,1901c1892,1901
<         p.pointCount=0;
<         ia()
<     }
<     var wa=document,ab=window,ta=Math,X=ta.round,kb=ta.floor,hd=ta.ceil,Fa=ta.max,qb=ta.min,db=ta.abs,nb=ta.cos,Bb=ta.sin,Zb=ta.PI,Vd=Zb*2/360,qc=navigator.userAgent,Cc=/msie/i.test(qc)&&!ab.opera,Ac=wa.documentMode===8,Od=/AppleWebKit/.test(qc),Sd=/Firefox/.test(qc),
<     zc=!!wa.createElementNS&&!!wa.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,Xc,Nb=wa.documentElement.ontouchstart!==undefined,Pb,Yc,Wd={},sd=0,rb=1,Ic,Va,Oc,Dc,bd,Ua,Rb="div",pc="absolute",Rd="relative",gb="hidden",oc="highcharts-",ub="visible",$a="px",jb="none",Za="M",Ja="L",Xd="rgba(192,192,192,"+(zc?1.0E-6:0.0020)+")",hb="",Ab="hover",Ec,dd,ed,fd,tc,Fc,Gc,Dd,Ed,gd,Fd,Gd,ka=ab.HighchartsAdapter,wb=ka||{},t=wb.each,Ad=wb.grep,nc=wb.map,sa=wb.merge,Yd=wb.hyphenate,Sa=wb.addEvent,
<     Gb=wb.removeEvent,Pa=wb.fireEvent,ad=wb.animate,Uc=wb.stop,vb={};
< 
<     Oc=function(a,b,c){
<         function d(G){
<             return G.toString().replace(/^([0-9])$/,"0$1")
---
> p.pointCount=0;
> ia()
> }
> var wa=document,ab=window,ta=Math,X=ta.round,kb=ta.floor,hd=ta.ceil,Fa=ta.max,qb=ta.min,db=ta.abs,nb=ta.cos,Bb=ta.sin,Zb=ta.PI,Vd=Zb*2/360,qc=navigator.userAgent,Cc=/msie/i.test(qc)&&!ab.opera,Ac=wa.documentMode===8,Od=/AppleWebKit/.test(qc),Sd=/Firefox/.test(qc),
> zc=!!wa.createElementNS&&!!wa.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,Xc,Nb=wa.documentElement.ontouchstart!==undefined,Pb,Yc,Wd={},sd=0,rb=1,Ic,Va,Oc,Dc,bd,Ua,Rb="div",pc="absolute",Rd="relative",gb="hidden",oc="highcharts-",ub="visible",$a="px",jb="none",Za="M",Ja="L",Xd="rgba(192,192,192,"+(zc?1.0E-6:0.0020)+")",hb="",Ab="hover",Ec,dd,ed,fd,tc,Fc,Gc,Dd,Ed,gd,Fd,Gd,ka=ab.HighchartsAdapter,wb=ka||{},t=wb.each,Ad=wb.grep,nc=wb.map,sa=wb.merge,Yd=wb.hyphenate,Sa=wb.addEvent,
> Gb=wb.removeEvent,Pa=wb.fireEvent,ad=wb.animate,Uc=wb.stop,vb={};
> 
> Oc=function(a,b,c){
>     function d(G){
>         return G.toString().replace(/^([0-9])$/,"0$1")
1904,1924c1904,1924
<         a=B(a,"%Y-%m-%d %H:%M:%S");
<         b=new Date(b*rb);
<         var e,f=b[ed](),g=b[fd](),h=b[tc](),j=b[Fc](),l=b[Gc](),n=Va.lang,C=n.weekdays;
<         n=n.months;
<         b={
<             a:C[g].substr(0,3),
<             A:C[g],
<             d:d(h),
<             e:h,
<             b:n[j].substr(0,3),
<             B:n[j],
<             m:d(j+1),
<             y:l.toString().substr(2,2),
<             Y:l,
<             H:d(f),
<             I:d(f%12||12),
<             l:f%12||12,
<             M:d(b[dd]()),
<             p:f<12?"AM":"PM",
<             P:f<12?"am":"pm",
<             S:d(b.getSeconds())
---
>     a=B(a,"%Y-%m-%d %H:%M:%S");
>     b=new Date(b*rb);
>     var e,f=b[ed](),g=b[fd](),h=b[tc](),j=b[Fc](),l=b[Gc](),n=Va.lang,C=n.weekdays;
>     n=n.months;
>     b={
>         a:C[g].substr(0,3),
>         A:C[g],
>         d:d(h),
>         e:h,
>         b:n[j].substr(0,3),
>         B:n[j],
>         m:d(j+1),
>         y:l.toString().substr(2,2),
>         Y:l,
>         H:d(f),
>         I:d(f%12||12),
>         l:f%12||12,
>         M:d(b[dd]()),
>         p:f<12?"AM":"PM",
>         P:f<12?"am":"pm",
>         S:d(b.getSeconds())
1927c1927
<         for(e in b)a=a.replace("%"+e,b[e]);return c?a.substr(0,1).toUpperCase()+a.substr(1):a
---
>     for(e in b)a=a.replace("%"+e,b[e]);return c?a.substr(0,1).toUpperCase()+a.substr(1):a
1930,1935c1930,1935
<     ka&&ka.init&&ka.init();
<     if(!ka&&ab.jQuery){
<         var ob=jQuery;
<         t=function(a,b){
<             for(var c=0,d=a.length;c<d;c++)if(b.call(a[c],a[c],c,a)===false)return c
<         };
---
> ka&&ka.init&&ka.init();
> if(!ka&&ab.jQuery){
>     var ob=jQuery;
>     t=function(a,b){
>         for(var c=0,d=a.length;c<d;c++)if(b.call(a[c],a[c],c,a)===false)return c
>             };
1937,1940c1937,1940
<         Ad=ob.grep;
<         nc=function(a,b){
<             for(var c=[],d=0,e=a.length;d<e;d++)c[d]=b.call(a[d],a[d],d,a);
<             return c
---
>     Ad=ob.grep;
>     nc=function(a,b){
>         for(var c=[],d=0,e=a.length;d<e;d++)c[d]=b.call(a[d],a[d],d,a);
>         return c
1943,1945c1943,1945
<         sa=function(){
<             var a=arguments;
<             return ob.extend(true,null,a[0],a[1],a[2],a[3])
---
>     sa=function(){
>         var a=arguments;
>         return ob.extend(true,null,a[0],a[1],a[2],a[3])
1948,1951c1948,1951
<         Yd=function(a){
<             return a.replace(/([A-Z])/g,function(b,c){
<                 return"-"+
<                 c.toLowerCase()
---
>     Yd=function(a){
>         return a.replace(/([A-Z])/g,function(b,c){
>             return"-"+
>             c.toLowerCase()
1955,1956c1955,1956
<         Sa=function(a,b,c){
<             ob(a).bind(b,c)
---
>     Sa=function(a,b,c){
>         ob(a).bind(b,c)
1959,1961c1959,1961
<         Gb=function(a,b,c){
<             var d=wa.removeEventListener?"removeEventListener":"detachEvent";
<             if(wa[d]&&!a[d])a[d]=function(){};
---
>     Gb=function(a,b,c){
>         var d=wa.removeEventListener?"removeEventListener":"detachEvent";
>         if(wa[d]&&!a[d])a[d]=function(){};
1963c1963
<             ob(a).unbind(b,c)
---
>         ob(a).unbind(b,c)
1966,1971c1966,1971
<         Pa=function(a,b,c,d){
<             var e=ob.Event(b),f="detached"+b;
<             pa(e,c);
<             if(a[b]){
<                 a[f]=a[b];
<                 a[b]=null
---
>     Pa=function(a,b,c,d){
>         var e=ob.Event(b),f="detached"+b;
>         pa(e,c);
>         if(a[b]){
>             a[f]=a[b];
>             a[b]=null
1974,1976c1974,1976
<             if(a[f]){
<                 a[b]=a[f];
<                 a[f]=null
---
>         if(a[f]){
>             a[b]=a[f];
>             a[f]=null
1981,1985c1981,1985
<         ad=function(a,b,c){
<             var d=ob(a);
<             if(b.d){
<                 a.toD=b.d;
<                 b.d=1
---
>     ad=function(a,b,c){
>         var d=ob(a);
>         if(b.d){
>             a.toD=b.d;
>             b.d=1
1988c1988
<             d.animate(b,c)
---
>         d.animate(b,c)
1991,1992c1991,1992
<         Uc=function(a){
<             ob(a).stop()
---
>     Uc=function(a){
>         ob(a).stop()
1995,1998c1995,1998
<         ob.extend(ob.easing,{
<             easeOutQuad:function(a,
<                 b,c,d,e){
<                 return-d*(b/=e)*(b-2)+c
---
>     ob.extend(ob.easing,{
>         easeOutQuad:function(a,
>             b,c,d,e){
>             return-d*(b/=e)*(b-2)+c
2001,2016c2001,2005
<         var fe=jQuery.fx.step._default,ge=jQuery.fx.prototype.cur;
<         ob.fx.step._default=function(a){
<             var b=a.elem;
<             b.attr?b.attr(a.prop,a.now):fe.apply(this,arguments)
<         };
< 
<         ob.fx.step.d=function(a){
<             var b=a.elem;
<             if(!a.started){
<                 var c=bd.init(b,b.d,b.toD);
<                 a.start=c[0];
<                 a.end=c[1];
<                 a.started=true
<             }
<             b.attr("d",bd.step(a.start,a.end,a.pos,b.toD))
<         };
---
> var fe=jQuery.fx.step._default,ge=jQuery.fx.prototype.cur;
> ob.fx.step._default=function(a){
>     var b=a.elem;
>     b.attr?b.attr(a.prop,a.now):fe.apply(this,arguments)
>     };
2018,2020c2007,2013
<         ob.fx.prototype.cur=function(){
<             var a=this.elem;
<             return a.attr?a.attr(this.prop):ge.apply(this,arguments)
---
> ob.fx.step.d=function(a){
>     var b=a.elem;
>     if(!a.started){
>         var c=bd.init(b,b.d,b.toD);
>         a.start=c[0];
>         a.end=c[1];
>         a.started=true
2021a2015,2020
>         b.attr("d",bd.step(a.start,a.end,a.pos,b.toD))
>     };
> 
> ob.fx.prototype.cur=function(){
>     var a=this.elem;
>     return a.attr?a.attr(this.prop):ge.apply(this,arguments)
2023,2032c2022,2032
<     bd={
<         init:function(a,b,c){
<             b=b||"";
<             var d=
<             a.shift,e=b.indexOf("C")>-1,f=e?7:3,g;
<             b=b.split(" ");
<             c=[].concat(c);
<             var h,j,l=function(n){
<                 for(g=n.length;g--;)n[g]===Za&&n.splice(g+1,0,n[g+1],n[g+2],n[g+1],n[g+2])
<             };
---
> }
> bd={
>     init:function(a,b,c){
>         b=b||"";
>         var d=
>         a.shift,e=b.indexOf("C")>-1,f=e?7:3,g;
>         b=b.split(" ");
>         c=[].concat(c);
>         var h,j,l=function(n){
>             for(g=n.length;g--;)n[g]===Za&&n.splice(g+1,0,n[g+1],n[g+2],n[g+1],n[g+2])
>                 };
2034,2036c2034,2036
<             if(e){
<                 l(b);
<                 l(c)
---
>         if(e){
>             l(b);
>             l(c)
2039,2040c2039,2040
<                 h=b.splice(b.length-6,6);
<                 j=c.splice(c.length-6,6)
---
>             h=b.splice(b.length-6,6);
>             j=c.splice(c.length-6,6)
2043,2044c2043,2044
<                 c=[].concat(c).splice(0,f).concat(c);
<                 a.shift=false
---
>             c=[].concat(c).splice(0,f).concat(c);
>             a.shift=false
2047,2050c2047,2050
<                 d=[].concat(b).splice(b.length-f,f);
<                 if(e){
<                     d[f-6]=d[f-2];
<                     d[f-5]=d[f-1]
---
>             d=[].concat(b).splice(b.length-f,f);
>             if(e){
>                 d[f-6]=d[f-2];
>                 d[f-5]=d[f-1]
2055,2056c2055,2056
<                 b=b.concat(h);
<                 c=c.concat(j)
---
>             b=b.concat(h);
>             c=c.concat(j)
2060,2066c2060,2066
<         step:function(a,b,c,d){
<             var e=
<             [],f=a.length;
<             if(c===1)e=d;
<             else if(f===b.length&&c<1)for(;f--;){
<                 d=parseFloat(a[f]);
<                 e[f]=isNaN(d)?a[f]:c*parseFloat(b[f]-d)+d
---
>     step:function(a,b,c,d){
>         var e=
>         [],f=a.length;
>         if(c===1)e=d;
>         else if(f===b.length&&c<1)for(;f--;){
>             d=parseFloat(a[f]);
>             e[f]=isNaN(d)?a[f]:c*parseFloat(b[f]-d)+d
2068c2068
<             return e
---
>         return e
2072,2073c2072,2117
<     ka={
<         enabled:true,
---
> ka={
>     enabled:true,
>     align:"center",
>     x:0,
>     y:15,
>     style:{
>         color:"#666",
>         fontSize:"11px",
>         lineHeight:"14px"
>     }
> };
> 
> Va={
>     colors:["#4572A7","#AA4643","#89A54E","#80699B","#3D96AE","#DB843D","#92A8CD","#A47D7C","#B5CA92"],
>     symbols:["circle","diamond","square","triangle","triangle-down"],
>     lang:{
>         loading:"Loading...",
>         months:["January","February","March","April","May","June","July",
>         "August","September","October","November","December"],
>         weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
>         decimalPoint:".",
>         resetZoom:"Reset zoom",
>         resetZoomTitle:"Reset zoom level 1:1",
>         thousandsSep:","
>     },
>     global:{
>         useUTC:true
>     },
>     chart:{
>         borderColor:"#4572A7",
>         borderRadius:5,
>         defaultSeriesType:"line",
>         ignoreHiddenSeries:true,
>         spacingTop:10,
>         spacingRight:10,
>         spacingBottom:15,
>         spacingLeft:10,
>         style:{
>             fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
>             fontSize:"12px"
>         },
>         backgroundColor:"#FFFFFF",
>         plotBorderColor:"#C0C0C0"
>     },
>     title:{
>         text:"Chart title",
2075d2118
<         x:0,
2078,2080c2121,2122
<             color:"#666",
<             fontSize:"11px",
<             lineHeight:"14px"
---
>             color:"#3E576F",
>             fontSize:"16px"
2082,2098c2124,2155
<     };
< 
<     Va={
<         colors:["#4572A7","#AA4643","#89A54E","#80699B","#3D96AE","#DB843D","#92A8CD","#A47D7C","#B5CA92"],
<         symbols:["circle","diamond","square","triangle","triangle-down"],
<         lang:{
<             loading:"Loading...",
<             months:["January","February","March","April","May","June","July",
<             "August","September","October","November","December"],
<             weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
<             decimalPoint:".",
<             resetZoom:"Reset zoom",
<             resetZoomTitle:"Reset zoom level 1:1",
<             thousandsSep:","
<         },
<         global:{
<             useUTC:true
---
>     },
> subtitle:{
>     text:"",
>     align:"center",
>     y:30,
>     style:{
>         color:"#6D869F"
>     }
> },
> plotOptions:{
>     line:{
>         allowPointSelect:false,
>         showCheckbox:false,
>         animation:{
>             duration:1E3
>         },
>         events:{},
>         lineWidth:2,
>         shadow:true,
>         marker:{
>             enabled:true,
>             lineWidth:0,
>             radius:4,
>             lineColor:"#FFFFFF",
>             states:{
>                 hover:{},
>                 select:{
>                     fillColor:"#FFFFFF",
>                     lineColor:"#000000",
>                     lineWidth:2
>                 }
>             }
2100,2111c2157,2452
<         chart:{
<             borderColor:"#4572A7",
<             borderRadius:5,
<             defaultSeriesType:"line",
<             ignoreHiddenSeries:true,
<             spacingTop:10,
<             spacingRight:10,
<             spacingBottom:15,
<             spacingLeft:10,
<             style:{
<                 fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
<                 fontSize:"12px"
---
> point:{
>     events:{}
> },
> dataLabels:sa(ka,
> 
> {
>     enabled:false,
>     y:-6,
>     formatter:function(){
>         return this.y
>         }
>     }),
> showInLegend:true,
> states:{
>     hover:{
>         marker:{}
> },
> select:{
>     marker:{}
> }
> },
> stickyTracking:true
> }
> },
> labels:{
>     style:{
>         position:pc,
>         color:"#3E576F"
>     }
> },
> legend:{
>     enabled:true,
>     align:"center",
>     layout:"horizontal",
>     labelFormatter:function(){
>         return this.name
>         },
>     borderWidth:1,
>     borderColor:"#909090",
>     borderRadius:5,
>     shadow:false,
>     style:{
>         padding:"5px"
>     },
>     itemStyle:{
>         cursor:"pointer",
>         color:"#3E576F"
>     },
>     itemHoverStyle:{
>         cursor:"pointer",
>         color:"#000000"
>     },
>     itemHiddenStyle:{
>         color:"#C0C0C0"
>     },
>     itemCheckboxStyle:{
>         position:pc,
>         width:"13px",
>         height:"13px"
>     },
>     symbolWidth:16,
>     symbolPadding:5,
>     verticalAlign:"bottom",
>     x:0,
>     y:0
> },
> loading:{
>     hideDuration:100,
>     labelStyle:{
>         fontWeight:"bold",
>         position:Rd,
>         top:"1em"
>     },
>     showDuration:100,
>     style:{
>         position:pc,
>         backgroundColor:"white",
>         opacity:0.5,
>         textAlign:"center"
>     }
> },
> tooltip:{
>     enabled:true,
>     backgroundColor:"rgba(255, 255, 255, .85)",
>     borderWidth:2,
>     borderRadius:5,
>     shadow:true,
>     snap:Nb?25:10,
>     style:{
>         color:"#333333",
>         fontSize:"12px",
>         padding:"5px",
>         whiteSpace:"nowrap"
>     }
> },
> toolbar:{
>     itemStyle:{
>         color:"#4572A7",
>         cursor:"pointer"
>     }
> },
> credits:{
>     enabled:false,
>     text:"Highcharts.com",
>     href:"http://www.highcharts.com",
>     position:{
>         align:"right",
>         x:-10,
>         verticalAlign:"bottom",
>         y:-5
>     },
>     style:{
>         cursor:"pointer",
>         color:"#909090",
>         fontSize:"10px"
>     }
> }
> };
> 
> var Nc={
>     dateTimeLabelFormats:{
>         second:"%H:%M:%S",
>         minute:"%H:%M",
>         hour:"%H:%M",
>         day:"%e. %b",
>         week:"%e. %b",
>         month:"%b '%y",
>         year:"%Y"
>     },
>     endOnTick:false,
>     gridLineColor:"#C0C0C0",
>     labels:ka,
>     lineColor:"#C0D0E0",
>     lineWidth:1,
>     max:null,
>     min:null,
>     minPadding:0.01,
>     maxPadding:0.01,
>     minorGridLineColor:"#E0E0E0",
>     minorGridLineWidth:1,
>     minorTickColor:"#A0A0A0",
>     minorTickLength:2,
>     minorTickPosition:"outside",
>     startOfWeek:1,
>     startOnTick:false,
>     tickColor:"#C0D0E0",
>     tickLength:5,
>     tickmarkPlacement:"between",
>     tickPixelInterval:100,
>     tickPosition:"outside",
>     tickWidth:1,
>     title:{
>         align:"middle",
>         style:{
>             color:"#6D869F",
>             fontWeight:"bold"
>         }
>     },
> type:"linear"
> },jd=sa(Nc,{
>     endOnTick:true,
>     gridLineWidth:1,
>     tickPixelInterval:72,
>     showLastLabel:true,
>     labels:{
>         align:"right",
>         x:-8,
>         y:3
>     },
>     lineWidth:0,
>     maxPadding:0.05,
>     minPadding:0.05,
>     startOnTick:true,
>     tickWidth:0,
>     title:{
>         rotation:270,
>         text:"Y-values"
>     },
>     stackLabels:{
>         enabled:false,
>         formatter:function(){
>             return this.total
>             },
>         style:ka.style
>         }
>     }),be={
>     labels:{
>         align:"right",
>         x:-8,
>         y:null
>     },
>     title:{
>         rotation:270
>     }
> },ae={
>     labels:{
>         align:"left",
>         x:8,
>         y:null
>     },
>     title:{
>         rotation:90
>     }
> },Nd={
>     labels:{
>         align:"center",
>         x:0,
>         y:14
>     },
>     title:{
>         rotation:0
>     }
> },$d=sa(Nd,{
>     labels:{
>         y:-5
>     }
> }),xb=Va.plotOptions;
> ka=xb.line;
> xb.spline=sa(ka);
> xb.scatter=sa(ka,{
>     lineWidth:0,
>     states:{
>         hover:{
>             lineWidth:0
>         }
>     }
> });
> xb.area=sa(ka,{});
> xb.areaspline=sa(xb.area);
> xb.column=sa(ka,{
>     borderColor:"#FFFFFF",
>     borderWidth:1,
>     borderRadius:0,
>     groupPadding:0.2,
>     marker:null,
>     pointPadding:0.1,
>     minPointLength:0,
>     states:{
>         hover:{
>             brightness:0.1,
>             shadow:false
>         },
>         select:{
>             color:"#C0C0C0",
>             borderColor:"#000000",
>             shadow:false
>         }
>     },
> dataLabels:{
>     y:null,
>     verticalAlign:null
> }
> });
> xb.bar=sa(xb.column,{
>     dataLabels:{
>         align:"left",
>         x:5,
>         y:0
>     }
> });
> xb.pie=sa(ka,{
>     borderColor:"#FFFFFF",
>     borderWidth:1,
>     center:["50%","50%"],
>     colorByPoint:true,
>     dataLabels:{
>         distance:30,
>         enabled:true,
>         formatter:function(){
>             return this.point.name
>             },
>         y:5
>     },
>     legendType:"point",
>     marker:null,
>     size:"75%",
>     showInLegend:false,
>     slicedOffset:10,
>     states:{
>         hover:{
>             brightness:0.1,
>             shadow:false
>         }
>     }
> });
> Cd();
> var $b=function(a){
>     var b=[],c;
>     (function(d){
>         if(c=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(d))b=[la(c[1]),la(c[2]),la(c[3]),parseFloat(c[4],10)];
>         else if(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(d))b=[la(c[1],16),la(c[2],16),la(c[3],16),1]
>             })(a);
>     return{
>         get:function(d){
>             return b&&!isNaN(b[0])?d==="rgb"?"rgb("+b[0]+","+b[1]+","+b[2]+
>             ")":d==="a"?b[3]:"rgba("+b.join(",")+")":a
2113,2114c2454,2463
<             backgroundColor:"#FFFFFF",
<             plotBorderColor:"#C0C0C0"
---
>         brighten:function(d){
>             if(ec(d)&&d!==0){
>                 var e;
>                 for(e=0;e<3;e++){
>                     b[e]+=la(d*255);
>                     if(b[e]<0)b[e]=0;
>                     if(b[e]>255)b[e]=255
>                         }
>                     }
>                 return this
2116,2122c2465,2484
<         title:{
<             text:"Chart title",
<             align:"center",
<             y:15,
<             style:{
<                 color:"#3E576F",
<                 fontSize:"16px"
---
>     setOpacity:function(d){
>         b[3]=d;
>         return this
>         }
>     }
> };
> 
> Jc.prototype={
>     init:function(a,b){
>         this.element=wa.createElementNS("http://www.w3.org/2000/svg",b);
>         this.renderer=a
>         },
>     animate:function(a,b,c){
>         if(b=B(b,Dc,true)){
>             b=sa(b);
>             if(c)b.complete=c;
>             ad(this,a,b)
>             }else{
>             this.attr(a);
>             c&&c()
2125,2274c2487,2492
<         subtitle:{
<             text:"",
<             align:"center",
<             y:30,
<             style:{
<                 color:"#6D869F"
<             }
<         },
<         plotOptions:{
<             line:{
<                 allowPointSelect:false,
<                 showCheckbox:false,
<                 animation:{
<                     duration:1E3
<                 },
<                 events:{},
<                 lineWidth:2,
<                 shadow:true,
<                 marker:{
<                     enabled:true,
<                     lineWidth:0,
<                     radius:4,
<                     lineColor:"#FFFFFF",
<                     states:{
<                         hover:{},
<                         select:{
<                             fillColor:"#FFFFFF",
<                             lineColor:"#000000",
<                             lineWidth:2
<                         }
<                     }
<                 },
<                 point:{
<                     events:{}
<                 },
<                 dataLabels:sa(ka,
< 
<                 {
<                         enabled:false,
<                         y:-6,
<                         formatter:function(){
<                             return this.y
<                         }
<                     }),
<                 showInLegend:true,
<                 states:{
<                     hover:{
<                         marker:{}
<                     },
<                     select:{
<                         marker:{}
<                     }
<                 },
<                 stickyTracking:true
<             }
<         },
<         labels:{
<             style:{
<                 position:pc,
<                 color:"#3E576F"
<             }
<         },
<         legend:{
<             enabled:true,
<             align:"center",
<             layout:"horizontal",
<             labelFormatter:function(){
<                 return this.name
<             },
<             borderWidth:1,
<             borderColor:"#909090",
<             borderRadius:5,
<             shadow:false,
<             style:{
<                 padding:"5px"
<             },
<             itemStyle:{
<                 cursor:"pointer",
<                 color:"#3E576F"
<             },
<             itemHoverStyle:{
<                 cursor:"pointer",
<                 color:"#000000"
<             },
<             itemHiddenStyle:{
<                 color:"#C0C0C0"
<             },
<             itemCheckboxStyle:{
<                 position:pc,
<                 width:"13px",
<                 height:"13px"
<             },
<             symbolWidth:16,
<             symbolPadding:5,
<             verticalAlign:"bottom",
<             x:0,
<             y:0
<         },
<         loading:{
<             hideDuration:100,
<             labelStyle:{
<                 fontWeight:"bold",
<                 position:Rd,
<                 top:"1em"
<             },
<             showDuration:100,
<             style:{
<                 position:pc,
<                 backgroundColor:"white",
<                 opacity:0.5,
<                 textAlign:"center"
<             }
<         },
<         tooltip:{
<             enabled:true,
<             backgroundColor:"rgba(255, 255, 255, .85)",
<             borderWidth:2,
<             borderRadius:5,
<             shadow:true,
<             snap:Nb?25:10,
<             style:{
<                 color:"#333333",
<                 fontSize:"12px",
<                 padding:"5px",
<                 whiteSpace:"nowrap"
<             }
<         },
<         toolbar:{
<             itemStyle:{
<                 color:"#4572A7",
<                 cursor:"pointer"
<             }
<         },
<         credits:{
<             enabled:false,
<             text:"Highcharts.com",
<             href:"http://www.highcharts.com",
<             position:{
<                 align:"right",
<                 x:-10,
<                 verticalAlign:"bottom",
<                 y:-5
<             },
<             style:{
<                 cursor:"pointer",
<                 color:"#909090",
<                 fontSize:"10px"
<             }
<         }
<     };
---
> attr:function(a,b){
>     var c,d,e,f,g=this.element,h=g.nodeName,j=
>     this.renderer,l,n=this.shadows,C,G=this;
>     if(Qb(a)&&J(b)){
>         c=a;
>         a={};
2276,2358c2494
<     var Nc={
<         dateTimeLabelFormats:{
<             second:"%H:%M:%S",
<             minute:"%H:%M",
<             hour:"%H:%M",
<             day:"%e. %b",
<             week:"%e. %b",
<             month:"%b '%y",
<             year:"%Y"
<         },
<         endOnTick:false,
<         gridLineColor:"#C0C0C0",
<         labels:ka,
<         lineColor:"#C0D0E0",
<         lineWidth:1,
<         max:null,
<         min:null,
<         minPadding:0.01,
<         maxPadding:0.01,
<         minorGridLineColor:"#E0E0E0",
<         minorGridLineWidth:1,
<         minorTickColor:"#A0A0A0",
<         minorTickLength:2,
<         minorTickPosition:"outside",
<         startOfWeek:1,
<         startOnTick:false,
<         tickColor:"#C0D0E0",
<         tickLength:5,
<         tickmarkPlacement:"between",
<         tickPixelInterval:100,
<         tickPosition:"outside",
<         tickWidth:1,
<         title:{
<             align:"middle",
<             style:{
<                 color:"#6D869F",
<                 fontWeight:"bold"
<             }
<         },
<         type:"linear"
<     },jd=sa(Nc,{
<         endOnTick:true,
<         gridLineWidth:1,
<         tickPixelInterval:72,
<         showLastLabel:true,
<         labels:{
<             align:"right",
<             x:-8,
<             y:3
<         },
<         lineWidth:0,
<         maxPadding:0.05,
<         minPadding:0.05,
<         startOnTick:true,
<         tickWidth:0,
<         title:{
<             rotation:270,
<             text:"Y-values"
<         },
<         stackLabels:{
<             enabled:false,
<             formatter:function(){
<                 return this.total
<             },
<             style:ka.style
<         }
<     }),be={
<         labels:{
<             align:"right",
<             x:-8,
<             y:null
<         },
<         title:{
<             rotation:270
<         }
<     },ae={
<         labels:{
<             align:"left",
<             x:8,
<             y:null
<         },
<         title:{
<             rotation:90
---
>         a[c]=b
2360,2367c2496,2500
<     },Nd={
<         labels:{
<             align:"center",
<             x:0,
<             y:14
<         },
<         title:{
<             rotation:0
---
>         if(Qb(a)){
>         c=a;
>         if(h==="circle")c={
>             x:"cx",
>             y:"cy"
2369,2381c2502,2523
<     },$d=sa(Nd,{
<         labels:{
<             y:-5
<         }
<     }),xb=Va.plotOptions;
<     ka=xb.line;
<     xb.spline=sa(ka);
<     xb.scatter=sa(ka,{
<         lineWidth:0,
<         states:{
<             hover:{
<                 lineWidth:0
<             }
---
>         [c]||c;
>         else if(c==="strokeWidth")c="stroke-width";
>         G=Ca(g,c)||this[c]||0;
>         if(c!=="d"&&c!=="visibility")G=parseFloat(G)
>             }else for(c in a){
>         l=false;
>         d=a[c];
>         if(c==="d"){
>             if(d&&d.join)d=d.join(" ");
>             if(/(NaN| {2}|^$)/.test(d))d="M 0 0";
>             this.d=d
>             }else if(c==="x"&&h==="text"){
>             for(e=0;e<g.childNodes.length;e++){
>                 f=g.childNodes[e];
>                 Ca(f,"x")===Ca(g,"x")&&Ca(f,"x",d)
>                 }
>                 if(this.rotation)Ca(g,"transform",
>                 "rotate("+this.rotation+" "+d+" "+la(a.y||Ca(g,"y"))+")")
>             }else if(c==="fill")d=j.color(d,g,c);
>         else if(h==="circle"&&(c==="x"||c==="y"))c={
>             x:"cx",
>             y:"cy"
2383,2407c2525,2548
<     });
<     xb.area=sa(ka,{});
<     xb.areaspline=sa(xb.area);
<     xb.column=sa(ka,{
<         borderColor:"#FFFFFF",
<         borderWidth:1,
<         borderRadius:0,
<         groupPadding:0.2,
<         marker:null,
<         pointPadding:0.1,
<         minPointLength:0,
<         states:{
<             hover:{
<                 brightness:0.1,
<                 shadow:false
<             },
<             select:{
<                 color:"#C0C0C0",
<                 borderColor:"#000000",
<                 shadow:false
<             }
<         },
<         dataLabels:{
<             y:null,
<             verticalAlign:null
---
>         [c]||c;
>         else if(c==="translateX"||c==="translateY"||c==="rotation"||c==="verticalAlign"){
>             this[c]=d;
>             this.updateTransform();
>             l=true
>             }else if(c==="stroke")d=j.color(d,g,c);
>         else if(c==="dashstyle"){
>             c="stroke-dasharray";
>             d=d&&d.toLowerCase();
>             if(d==="solid")d=jb;
>             else if(d){
>                 d=d.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot",
>                     "1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");
>                 for(e=d.length;e--;)d[e]=la(d[e])*a["stroke-width"];
>                 d=d.join(",")
>                 }
>             }else if(c==="isTracker")this[c]=d;
>         else if(c==="width")d=la(d);
>         else if(c==="align"){
>         c="text-anchor";
>         d={
>             left:"start",
>             center:"middle",
>             right:"end"
2409,2414c2550
<     });
<     xb.bar=sa(xb.column,{
<         dataLabels:{
<             align:"left",
<             x:5,
<             y:0
---
>         [d]
2416,2438c2552,2557
<     });
<     xb.pie=sa(ka,{
<         borderColor:"#FFFFFF",
<         borderWidth:1,
<         center:["50%","50%"],
<         colorByPoint:true,
<         dataLabels:{
<             distance:30,
<             enabled:true,
<             formatter:function(){
<                 return this.point.name
<             },
<             y:5
<         },
<         legendType:"point",
<         marker:null,
<         size:"75%",
<         showInLegend:false,
<         slicedOffset:10,
<         states:{
<             hover:{
<                 brightness:0.1,
<                 shadow:false
---
>         if(c==="strokeWidth")c="stroke-width";
>         if(Od&&c==="stroke-width"&&d===0)d=1.0E-6;
>         if(this.symbolName&&/^(x|y|r|start|end|innerR)/.test(c)){
>         if(!C){
>             this.symbolAttr(a);
>             C=true
2439a2559
>             l=true
2441,2468c2561,2566
<     });
<     Cd();
<     var $b=function(a){
<         var b=[],c;
<         (function(d){
<             if(c=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(d))b=[la(c[1]),la(c[2]),la(c[3]),parseFloat(c[4],10)];
<             else if(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(d))b=[la(c[1],16),la(c[2],16),la(c[3],16),1]
<         })(a);
<         return{
<             get:function(d){
<                 return b&&!isNaN(b[0])?d==="rgb"?"rgb("+b[0]+","+b[1]+","+b[2]+
<                 ")":d==="a"?b[3]:"rgba("+b.join(",")+")":a
<             },
<             brighten:function(d){
<                 if(ec(d)&&d!==0){
<                     var e;
<                     for(e=0;e<3;e++){
<                         b[e]+=la(d*255);
<                         if(b[e]<0)b[e]=0;
<                         if(b[e]>255)b[e]=255
<                     }
<                 }
<                 return this
<             },
<             setOpacity:function(d){
<                 b[3]=d;
<                 return this
<             }
---
>         if(n&&/^(width|height|visibility|x|y|d)$/.test(c))for(e=n.length;e--;)Ca(n[e],c,d);
>         if((c==="width"||c==="height")&&h==="rect"&&d<0)d=0;
>         if(c==="text"){
>         this.textStr=d;
>         this.added&&j.buildText(this)
>         }else l||Ca(g,c,d)
2470,2582c2568,2581
<     };
< 
<     Jc.prototype={
<         init:function(a,b){
<             this.element=wa.createElementNS("http://www.w3.org/2000/svg",b);
<             this.renderer=a
<         },
<         animate:function(a,b,c){
<             if(b=B(b,Dc,true)){
<                 b=sa(b);
<                 if(c)b.complete=c;
<                 ad(this,a,b)
<             }else{
<                 this.attr(a);
<                 c&&c()
<             }
<         },
<         attr:function(a,b){
<             var c,d,e,f,g=this.element,h=g.nodeName,j=
<             this.renderer,l,n=this.shadows,C,G=this;
<             if(Qb(a)&&J(b)){
<                 c=a;
<                 a={};
< 
<                 a[c]=b
<             }
<             if(Qb(a)){
<                 c=a;
<                 if(h==="circle")c={
<                     x:"cx",
<                     y:"cy"
<                 }
<                 [c]||c;
<                 else if(c==="strokeWidth")c="stroke-width";
<                 G=Ca(g,c)||this[c]||0;
<                 if(c!=="d"&&c!=="visibility")G=parseFloat(G)
<             }else for(c in a){
<                 l=false;
<                 d=a[c];
<                 if(c==="d"){
<                     if(d&&d.join)d=d.join(" ");
<                     if(/(NaN| {2}|^$)/.test(d))d="M 0 0";
<                     this.d=d
<                 }else if(c==="x"&&h==="text"){
<                     for(e=0;e<g.childNodes.length;e++){
<                         f=g.childNodes[e];
<                         Ca(f,"x")===Ca(g,"x")&&Ca(f,"x",d)
<                     }
<                     if(this.rotation)Ca(g,"transform",
<                         "rotate("+this.rotation+" "+d+" "+la(a.y||Ca(g,"y"))+")")
<                 }else if(c==="fill")d=j.color(d,g,c);
<                 else if(h==="circle"&&(c==="x"||c==="y"))c={
<                     x:"cx",
<                     y:"cy"
<                 }
<                 [c]||c;
<                 else if(c==="translateX"||c==="translateY"||c==="rotation"||c==="verticalAlign"){
<                     this[c]=d;
<                     this.updateTransform();
<                     l=true
<                 }else if(c==="stroke")d=j.color(d,g,c);
<                 else if(c==="dashstyle"){
<                     c="stroke-dasharray";
<                     d=d&&d.toLowerCase();
<                     if(d==="solid")d=jb;
<                     else if(d){
<                         d=d.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot",
<                             "1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");
<                         for(e=d.length;e--;)d[e]=la(d[e])*a["stroke-width"];
<                         d=d.join(",")
<                     }
<                 }else if(c==="isTracker")this[c]=d;
<                 else if(c==="width")d=la(d);
<                 else if(c==="align"){
<                     c="text-anchor";
<                     d={
<                         left:"start",
<                         center:"middle",
<                         right:"end"
<                     }
<                     [d]
<                 }
<                 if(c==="strokeWidth")c="stroke-width";
<                 if(Od&&c==="stroke-width"&&d===0)d=1.0E-6;
<                 if(this.symbolName&&/^(x|y|r|start|end|innerR)/.test(c)){
<                     if(!C){
<                         this.symbolAttr(a);
<                         C=true
<                     }
<                     l=true
<                 }
<                 if(n&&/^(width|height|visibility|x|y|d)$/.test(c))for(e=n.length;e--;)Ca(n[e],c,d);
<                 if((c==="width"||c==="height")&&h==="rect"&&d<0)d=0;
<                 if(c==="text"){
<                     this.textStr=d;
<                     this.added&&j.buildText(this)
<                 }else l||Ca(g,c,d)
<             }
<             return G
<         },
<         symbolAttr:function(a){
<             var b=this;
<             t(["x","y","r","start","end","width","height","innerR"],function(c){
<                 b[c]=B(a[c],b[c])
<             });
<             b.attr({
<                 d:b.renderer.symbols[b.symbolName](X(b.x*2)/2,X(b.y*2)/2,b.r,{
<                     start:b.start,
<                     end:b.end,
<                     width:b.width,
<                     height:b.height,
<                     innerR:b.innerR
<                 })
---
>         return G
> },
> symbolAttr:function(a){
>     var b=this;
>     t(["x","y","r","start","end","width","height","innerR"],function(c){
>         b[c]=B(a[c],b[c])
>         });
>     b.attr({
>         d:b.renderer.symbols[b.symbolName](X(b.x*2)/2,X(b.y*2)/2,b.r,{
>             start:b.start,
>             end:b.end,
>             width:b.width,
>             height:b.height,
>             innerR:b.innerR
2584,2606c2583,2606
<         },
<         clip:function(a){
<             return this.attr("clip-path","url("+this.renderer.url+"#"+a.id+")")
<         },
<         crisp:function(a,b,c,d,e){
<             var f,g={},h={},j;
<             a=a||this.strokeWidth||0;
<             j=a%2/2;
<             h.x=kb(b||this.x||0)+j;
<             h.y=kb(c||this.y||0)+j;
<             h.width=kb((d||this.width||0)-2*j);
<             h.height=kb((e||this.height||0)-2*j);
<             h.strokeWidth=a;
<             for(f in h)if(this[f]!==h[f])this[f]=g[f]=h[f];return g
<         },
<         css:function(a){
<             var b=this.element;
<             b=a&&a.width&&b.nodeName==="text";
<             var c=a,d;
<             if(a&&a.color)a.fill=a.color;
<             this.styles=a=pa(this.styles,a);
<             if(J(a)){
<                 a=
---
>         })
>     },
> clip:function(a){
>     return this.attr("clip-path","url("+this.renderer.url+"#"+a.id+")")
>     },
> crisp:function(a,b,c,d,e){
>     var f,g={},h={},j;
>     a=a||this.strokeWidth||0;
>     j=a%2/2;
>     h.x=kb(b||this.x||0)+j;
>     h.y=kb(c||this.y||0)+j;
>     h.width=kb((d||this.width||0)-2*j);
>     h.height=kb((e||this.height||0)-2*j);
>     h.strokeWidth=a;
>     for(f in h)if(this[f]!==h[f])this[f]=g[f]=h[f];return g
>     },
> css:function(a){
>     var b=this.element;
>     b=a&&a.width&&b.nodeName==="text";
>     var c=a,d;
>     if(a&&a.color)a.fill=a.color;
>     this.styles=a=pa(this.styles,a);
>     if(J(a)){
>         a=
2608c2608
<                 {};
---
>         {};
2610c2610
<                 for(d in c)a[Yd(d)]=c[d]
---
>         for(d in c)a[Yd(d)]=c[d]
2613,2667c2613,2627
<                 b&&delete a.width;
<                 La(this.element,a)
<             }else this.attr({
<                 style:Zd(a)
<             });
<             b&&this.added&&this.renderer.buildText(this);
<             return this
<         },
<         on:function(a,b){
<             var c=b;
<             if(Nb&&a==="click"){
<                 a="touchstart";
<                 c=function(d){
<                     d.preventDefault();
<                     b()
<                 }
<             }
<             this.element["on"+a]=c;
<             return this
<         },
<         translate:function(a,b){
<             return this.attr({
<                 translateX:a,
<                 translateY:b
<             })
<         },
<         invert:function(){
<             this.inverted=true;
<             this.updateTransform();
<             return this
<         },
<         updateTransform:function(){
<             var a=this.translateX||0,b=this.translateY||
<             0,c=this.inverted,d=this.rotation,e=[];
<             if(c){
<                 a+=this.attr("width");
<                 b+=this.attr("height")
<             }
<             if(a||b)e.push("translate("+a+","+b+")");
<             if(c)e.push("rotate(90) scale(-1,1)");else d&&e.push("rotate("+d+" "+this.x+" "+this.y+")");
<             e.length&&Ca(this.element,"transform",e.join(" "))
<         },
<         toFront:function(){
<             var a=this.element;
<             a.parentNode.appendChild(a);
<             return this
<         },
<         align:function(a,b,c){
<             if(a){
<                 this.alignOptions=a;
<                 this.alignByTranslate=b;
<                 c||this.renderer.alignedObjects.push(this)
<             }else{
<                 a=this.alignOptions;
<                 b=this.alignByTranslate
---
>         b&&delete a.width;
>         La(this.element,a)
>         }else this.attr({
>         style:Zd(a)
>         });
>     b&&this.added&&this.renderer.buildText(this);
>     return this
>     },
> on:function(a,b){
>     var c=b;
>     if(Nb&&a==="click"){
>         a="touchstart";
>         c=function(d){
>             d.preventDefault();
>             b()
2669,2687c2629,2731
<             c=
<             B(c,this.renderer);
<             var d=a.align,e=a.verticalAlign,f=(c.x||0)+(a.x||0),g=(c.y||0)+(a.y||0),h={};
< 
<             if(/^(right|center)$/.test(d))f+=(c.width-(a.width||0))/{
<                 right:1,
<                 center:2
<             }
<             [d];
<             h[b?"translateX":"x"]=X(f);
<             if(/^(bottom|middle)$/.test(e))g+=(c.height-(a.height||0))/({
<                 bottom:1,
<                 middle:2
<             }
<             [e]||1);
<             h[b?"translateY":"y"]=X(g);
<             this[this.placed?"animate":"attr"](h);
<             this.placed=true;
<             this.alignAttr=h;
---
>         }
>     this.element["on"+a]=c;
> return this
> },
> translate:function(a,b){
>     return this.attr({
>         translateX:a,
>         translateY:b
>     })
>     },
> invert:function(){
>     this.inverted=true;
>     this.updateTransform();
>     return this
>     },
> updateTransform:function(){
>     var a=this.translateX||0,b=this.translateY||
>     0,c=this.inverted,d=this.rotation,e=[];
>     if(c){
>         a+=this.attr("width");
>         b+=this.attr("height")
>         }
>         if(a||b)e.push("translate("+a+","+b+")");
>     if(c)e.push("rotate(90) scale(-1,1)");else d&&e.push("rotate("+d+" "+this.x+" "+this.y+")");
>     e.length&&Ca(this.element,"transform",e.join(" "))
>     },
> toFront:function(){
>     var a=this.element;
>     a.parentNode.appendChild(a);
>     return this
>     },
> align:function(a,b,c){
>     if(a){
>         this.alignOptions=a;
>         this.alignByTranslate=b;
>         c||this.renderer.alignedObjects.push(this)
>         }else{
>         a=this.alignOptions;
>         b=this.alignByTranslate
>         }
>         c=
>     B(c,this.renderer);
>     var d=a.align,e=a.verticalAlign,f=(c.x||0)+(a.x||0),g=(c.y||0)+(a.y||0),h={};
> 
>     if(/^(right|center)$/.test(d))f+=(c.width-(a.width||0))/{
>         right:1,
>         center:2
>     }
>     [d];
>     h[b?"translateX":"x"]=X(f);
>     if(/^(bottom|middle)$/.test(e))g+=(c.height-(a.height||0))/({
>         bottom:1,
>         middle:2
>     }
>     [e]||1);
>     h[b?"translateY":"y"]=X(g);
>     this[this.placed?"animate":"attr"](h);
>     this.placed=true;
>     this.alignAttr=h;
>     return this
>     },
> getBBox:function(){
>     var a,b,c,d=this.rotation,e=d*Vd;
>     try{
>         a=pa({},this.element.getBBox())
>         }catch(f){
>         a={
>             width:0,
>             height:0
>         }
>     }
>     b=a.width;
> c=a.height;
> if(d){
>     a.width=db(c*Bb(e))+db(b*nb(e));
>     a.height=db(c*nb(e))+db(b*Bb(e))
>     }
>     return a
> },
> show:function(){
>     return this.attr({
>         visibility:ub
>     })
>     },
> hide:function(){
>     return this.attr({
>         visibility:gb
>     })
>     },
> add:function(a){
>     var b=this.renderer,c=a||b,d=c.element||b.box,e=d.childNodes,f=this.element,g=Ca(f,"zIndex");
>     this.parentInverted=a&&a.inverted;
>     this.textStr!==undefined&&b.buildText(this);
>     if(g){
>         c.handleZ=true;
>         g=la(g)
>         }
>         if(c.handleZ)for(c=0;c<e.length;c++){
>         a=e[c];
>         b=Ca(a,"zIndex");
>         if(a!==f&&
>             (la(b)>g||!J(g)&&J(b))){
>             d.insertBefore(f,a);
2689,2733d2732
<         },
<         getBBox:function(){
<             var a,b,c,d=this.rotation,e=d*Vd;
<             try{
<                 a=pa({},this.element.getBBox())
<             }catch(f){
<                 a={
<                     width:0,
<                     height:0
<                 }
<             }
<             b=a.width;
<             c=a.height;
<             if(d){
<                 a.width=db(c*Bb(e))+db(b*nb(e));
<                 a.height=db(c*nb(e))+db(b*Bb(e))
<             }
<             return a
<         },
<         show:function(){
<             return this.attr({
<                 visibility:ub
<             })
<         },
<         hide:function(){
<             return this.attr({
<                 visibility:gb
<             })
<         },
<         add:function(a){
<             var b=this.renderer,c=a||b,d=c.element||b.box,e=d.childNodes,f=this.element,g=Ca(f,"zIndex");
<             this.parentInverted=a&&a.inverted;
<             this.textStr!==undefined&&b.buildText(this);
<             if(g){
<                 c.handleZ=true;
<                 g=la(g)
<             }
<             if(c.handleZ)for(c=0;c<e.length;c++){
<                 a=e[c];
<                 b=Ca(a,"zIndex");
<                 if(a!==f&&
<                     (la(b)>g||!J(g)&&J(b))){
<                     d.insertBefore(f,a);
<                     return this
<                 }
2735,2745c2734,2765
<             d.appendChild(f);
<             this.added=true;
<             return this
<         },
<         destroy:function(){
<             var a=this.element||{},b=this.shadows,c=a.parentNode,d;
<             a.onclick=a.onmouseout=a.onmouseover=a.onmousemove=null;
<             Uc(this);
<             c&&c.removeChild(a);
<             b&&t(b,function(e){
<                 (c=e.parentNode)&&c.removeChild(e)
---
>         }
>     d.appendChild(f);
> this.added=true;
> return this
> },
> destroy:function(){
>     var a=this.element||{},b=this.shadows,c=a.parentNode,d;
>     a.onclick=a.onmouseout=a.onmouseover=a.onmousemove=null;
>     Uc(this);
>     c&&c.removeChild(a);
>     b&&t(b,function(e){
>         (c=e.parentNode)&&c.removeChild(e)
>         });
>     rc(this.renderer.alignedObjects,this);
>     for(d in this)delete this[d];return null
>     },
> empty:function(){
>     for(var a=this.element,b=a.childNodes,c=b.length;c--;)a.removeChild(b[c])
>         },
> shadow:function(a,
>     b){
>     var c=[],d,e,f=this.element,g=this.parentInverted?"(-1,-1)":"(1,1)";
>     if(a){
>         for(d=1;d<=3;d++){
>             e=f.cloneNode(0);
>             Ca(e,{
>                 isShadow:"true",
>                 stroke:"rgb(0, 0, 0)",
>                 "stroke-opacity":0.05*d,
>                 "stroke-width":7-2*d,
>                 transform:"translate"+g,
>                 fill:jb
2747,2770c2767,2768
<             rc(this.renderer.alignedObjects,this);
<             for(d in this)delete this[d];return null
<         },
<         empty:function(){
<             for(var a=this.element,b=a.childNodes,c=b.length;c--;)a.removeChild(b[c])
<         },
<         shadow:function(a,
<             b){
<             var c=[],d,e,f=this.element,g=this.parentInverted?"(-1,-1)":"(1,1)";
<             if(a){
<                 for(d=1;d<=3;d++){
<                     e=f.cloneNode(0);
<                     Ca(e,{
<                         isShadow:"true",
<                         stroke:"rgb(0, 0, 0)",
<                         "stroke-opacity":0.05*d,
<                         "stroke-width":7-2*d,
<                         transform:"translate"+g,
<                         fill:jb
<                     });
<                     b?b.element.appendChild(e):f.parentNode.insertBefore(e,f);
<                     c.push(e)
<                 }
<                 this.shadows=c
---
>             b?b.element.appendChild(e):f.parentNode.insertBefore(e,f);
>             c.push(e)
2772c2770
<             return this
---
>             this.shadows=c
2774c2772,2774
<     };
---
>         return this
>     }
> };
2776,2777c2776,2777
<     var Wc=function(){
<         this.init.apply(this,arguments)
---
> var Wc=function(){
>     this.init.apply(this,arguments)
2780,2819c2780,2819
<     Wc.prototype={
<         Element:Jc,
<         init:function(a,b,c,d){
<             var e=location,f;
<             f=this.createElement("svg").attr({
<                 xmlns:"http://www.w3.org/2000/svg",
<                 version:"1.1"
<             });
<             a.appendChild(f.element);
<             this.box=f.element;
<             this.boxWrapper=f;
<             this.alignedObjects=[];
<             this.url=Cc?"":e.href.replace(/#.*?$/,"");
<             this.defs=this.createElement("defs").add();
<             this.forExport=d;
<             this.setSize(b,c,false)
<         },
<         createElement:function(a){
<             var b=new this.Element;
<             b.init(this,a);
<             return b
<         },
<         buildText:function(a){
<             for(var b=a.element,c=B(a.textStr,"").toString().replace(/<(b|strong)>/g,'<span style="font-weight:bold">').replace(/<(i|em)>/g,'<span style="font-style:italic">').replace(/<a/g,
<                 "<span").replace(/<\/(b|strong|i|em|a)>/g,"</span>").split(/<br.*?>/g),d=b.childNodes,e=/style="([^"]+)"/,f=/href="([^"]+)"/,g=Ca(b,"x"),h=a.styles,j=Sd&&h&&h["-hc-direction"]==="rtl"&&!this.forExport&&la(qc.split("Firefox/")[1])<4,l,n=h&&la(h.width),C=h&&h["line-height"],G,fa=d.length;fa--;)b.removeChild(d[fa]);
<             n&&!a.added&&this.box.appendChild(b);
<             t(c,function(K,ia){
<                 var u,P=0,O;
<                 K=K.replace(/<span/g,"|||<span").replace(/<\/span>/g,"</span>|||");
<                 u=K.split("|||");
<                 t(u,function(Q){
<                     if(Q!==""||u.length===
<                         1){
<                         var H={},S=wa.createElementNS("http://www.w3.org/2000/svg","tspan");
<                         e.test(Q)&&Ca(S,"style",Q.match(e)[1].replace(/(;| |^)color([ :])/,"$1fill$2"));
<                         if(f.test(Q)){
<                             Ca(S,"onclick",'location.href="'+Q.match(f)[1]+'"');
<                             La(S,{
<                                 cursor:"pointer"
<                             })
---
> Wc.prototype={
>     Element:Jc,
>     init:function(a,b,c,d){
>         var e=location,f;
>         f=this.createElement("svg").attr({
>             xmlns:"http://www.w3.org/2000/svg",
>             version:"1.1"
>         });
>         a.appendChild(f.element);
>         this.box=f.element;
>         this.boxWrapper=f;
>         this.alignedObjects=[];
>         this.url=Cc?"":e.href.replace(/#.*?$/,"");
>         this.defs=this.createElement("defs").add();
>         this.forExport=d;
>         this.setSize(b,c,false)
>         },
>     createElement:function(a){
>         var b=new this.Element;
>         b.init(this,a);
>         return b
>         },
>     buildText:function(a){
>         for(var b=a.element,c=B(a.textStr,"").toString().replace(/<(b|strong)>/g,'<span style="font-weight:bold">').replace(/<(i|em)>/g,'<span style="font-style:italic">').replace(/<a/g,
>             "<span").replace(/<\/(b|strong|i|em|a)>/g,"</span>").split(/<br.*?>/g),d=b.childNodes,e=/style="([^"]+)"/,f=/href="([^"]+)"/,g=Ca(b,"x"),h=a.styles,j=Sd&&h&&h["-hc-direction"]==="rtl"&&!this.forExport&&la(qc.split("Firefox/")[1])<4,l,n=h&&la(h.width),C=h&&h["line-height"],G,fa=d.length;fa--;)b.removeChild(d[fa]);
>         n&&!a.added&&this.box.appendChild(b);
>         t(c,function(K,ia){
>             var u,P=0,O;
>             K=K.replace(/<span/g,"|||<span").replace(/<\/span>/g,"</span>|||");
>             u=K.split("|||");
>             t(u,function(Q){
>                 if(Q!==""||u.length===
>                     1){
>                     var H={},S=wa.createElementNS("http://www.w3.org/2000/svg","tspan");
>                     e.test(Q)&&Ca(S,"style",Q.match(e)[1].replace(/(;| |^)color([ :])/,"$1fill$2"));
>                     if(f.test(Q)){
>                         Ca(S,"onclick",'location.href="'+Q.match(f)[1]+'"');
>                         La(S,{
>                             cursor:"pointer"
>                         })
2822,2825c2822,2825
<                         if(j){
<                             l=[];
<                             for(fa=Q.length;fa--;)l.push(Q.charAt(fa));
<                             Q=l.join("")
---
>                     if(j){
>                         l=[];
>                         for(fa=Q.length;fa--;)l.push(Q.charAt(fa));
>                         Q=l.join("")
2828,2868c2828,2833
<                         if(P)H.dx=3;else H.x=g;
<                         if(!P){
<                             if(ia){
<                                 !zc&&a.renderer.forExport&&La(S,{
<                                     display:"block"
<                                 });
<                                 O=ab.getComputedStyle&&ab.getComputedStyle(G,null).getPropertyValue("line-height");
<                                 if(!O||isNaN(O))O=C||G.offsetHeight||18;
<                                 Ca(S,"dy",O)
<                             }
<                             G=S
<                         }
<                         Ca(S,H);
<                         b.appendChild(S);
<                         P++;
<                         if(n){
<                             Q=Q.replace(/-/g,"- ").split(" ");
<                             for(var Ta,cb=[];Q.length||cb.length;){
<                                 Ta=b.getBBox().width;
<                                 H=Ta>n;
<                                 if(!H||Q.length===1){
<                                     Q=cb;
<                                     cb=[];
<                                     if(Q.length){
<                                         S=wa.createElementNS("http://www.w3.org/2000/svg","tspan");
<                                         Ca(S,{
<                                             dy:C||16,
<                                             x:g
<                                         });
<                                         b.appendChild(S);
<                                         if(Ta>n)n=Ta
<                                     }
<                                 }
<                                 else{
<                                     S.removeChild(S.firstChild);
<                                     cb.unshift(Q.pop())
<                                 }
<                                 Q.length&&S.appendChild(wa.createTextNode(Q.join(" ").replace(/- /g,
<                                     "-")))
<                             }
<                         }
---
>                     if(P)H.dx=3;else H.x=g;if(!P){
>                     if(ia){
>                     !zc&&a.renderer.forExport&&La(S,{
>                         display:"block"
>                         });
>                     O=ab.getComputedStyle&&ab.getComputedStyle(G,null).getPropertyValue("line-height");if(!O||isNaN(O))O=C||G.offsetHeight||18;Ca(S,"dy",O)
2870,2979c2835,2846
<                 })
<             })
<         },
<         crispLine:function(a,b){
<             if(a[1]===a[4])a[1]=a[4]=X(a[1])+b%2/2;
<             if(a[2]===a[5])a[2]=a[5]=X(a[2])+b%2/2;
<             return a
<         },
<         path:function(a){
<             return this.createElement("path").attr({
<                 d:a,
<                 fill:jb
<             })
<         },
<         circle:function(a,b,c){
<             a=Kb(a)?a:{
<                 x:a,
<                 y:b,
<                 r:c
<             };
<             return this.createElement("circle").attr(a)
<         },
<         arc:function(a,b,c,d,e,f){
<             if(Kb(a)){
<                 b=a.y;
<                 c=a.r;
<                 d=a.innerR;
<                 e=a.start;
<                 f=a.end;
<                 a=a.x
<             }
<             return this.symbol("arc",a||0,b||0,c||0,{
<                 innerR:d||0,
<                 start:e||0,
<                 end:f||0
<             })
<         },
<         rect:function(a,b,c,d,e,f){
<             if(Kb(a)){
<                 b=a.y;
<                 c=a.width;
<                 d=a.height;
<                 e=a.r;
<                 f=a.strokeWidth;
<                 a=a.x
<             }
<             e=this.createElement("rect").attr({
<                 rx:e,
<                 ry:e,
<                 fill:jb
<             });
<             return e.attr(e.crisp(f,a,b,Fa(c,0),Fa(d,0)))
<         },
<         setSize:function(a,b,c){
<             var d=this.alignedObjects,e=d.length;
<             this.width=a;
<             this.height=b;
<             for(this.boxWrapper[B(c,true)?"animate":"attr"]({
<                 width:a,
<                 height:b
<             });e--;)d[e].align()
<         },
<         g:function(a){
<             return this.createElement("g").attr(J(a)&&{
<                 "class":oc+a
<             })
<         },
<         image:function(a,b,c,d,e){
<             var f={
<                 preserveAspectRatio:jb
<             };
<             arguments.length>1&&pa(f,{
<                 x:b,
<                 y:c,
<                 width:d,
<                 height:e
<             });
<             f=
<             this.createElement("image").attr(f);
<             f.element.setAttributeNS?f.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):f.element.setAttribute("hc-svg-href",a);
<             return f
<         },
<         symbol:function(a,b,c,d,e){
<             var f,g=this.symbols[a];
<             g=g&&g(X(b),X(c),d,e);
<             var h=/^url\((.*?)\)$/,j;
<             if(g){
<                 f=this.path(g);
<                 pa(f,{
<                     symbolName:a,
<                     x:b,
<                     y:c,
<                     r:d
<                 });
<                 e&&pa(f,e)
<             }else if(h.test(a)){
<                 var l=function(n,C){
<                     n.attr({
<                         width:C[0],
<                         height:C[1]
<                     }).translate(-X(C[0]/2),-X(C[1]/2))
<                 };
< 
<                 j=a.match(h)[1];
<                 a=Wd[j];
<                 f=this.image(j).attr({
<                     x:b,
<                     y:c
<                 });
<                 if(a)l(f,a);
---
>                     G=S
>                     }
>                     Ca(S,H);b.appendChild(S);P++;if(n){
>                     Q=Q.replace(/-/g,"- ").split(" ");for(var Ta,cb=[];Q.length||cb.length;){
>                     Ta=b.getBBox().width;H=Ta>n;if(!H||Q.length===1){
>                     Q=cb;cb=[];if(Q.length){
>                     S=wa.createElementNS("http://www.w3.org/2000/svg","tspan");Ca(S,{
>                         dy:C||16,
>         x:g
>                         });b.appendChild(S);if(Ta>n)n=Ta
>                     }
>                 }
2981,2990c2848,2851
<                     f.attr({
<                         width:0,
<                         height:0
<                     });
<                     ib("img",{
<                         onload:function(){
<                             l(f,Wd[j]=[this.width,this.height])
<                         },
<                         src:j
<                     })
---
>                 S.removeChild(S.firstChild);cb.unshift(Q.pop())
>                 }
>                 Q.length&&S.appendChild(wa.createTextNode(Q.join(" ").replace(/- /g,
>                     "-")))
2992,3014d2852
<             }else f=this.circle(b,c,d);
<             return f
<         },
<         symbols:{
<             square:function(a,b,c){
<                 c=0.707*c;
<                 return[Za,a-c,b-c,Ja,a+c,b-c,a+c,b+c,a-c,b+c,"Z"]
<             },
<             triangle:function(a,b,c){
<                 return[Za,a,b-1.33*c,Ja,a+c,b+0.67*c,a-c,b+0.67*c,"Z"]
<             },
<             "triangle-down":function(a,b,c){
<                 return[Za,a,b+1.33*c,Ja,a-c,b-0.67*c,a+c,b-0.67*c,"Z"]
<             },
<             diamond:function(a,b,c){
<                 return[Za,a,b-c,Ja,a+c,b,a,b+c,a-c,b,"Z"]
<             },
<             arc:function(a,b,c,
<                 d){
<                 var e=d.start,f=d.end-1.0E-6,g=d.innerR,h=nb(e),j=Bb(e),l=nb(f);
<                 f=Bb(f);
<                 d=d.end-e<Zb?0:1;
<                 return[Za,a+c*h,b+c*j,"A",c,c,0,d,1,a+c*l,b+c*f,Ja,a+g*l,b+g*f,"A",g,g,0,d,0,a+g*h,b+g*j,"Z"]
3016,3077c2854,2909
<         },
<         clipRect:function(a,b,c,d){
<             var e=oc+sd++,f=this.createElement("clipPath").attr({
<                 id:e
<             }).add(this.defs);
<             a=this.rect(a,b,c,d,0).add(f);
<             a.id=e;
<             return a
<         },
<         color:function(a,b,c){
<             var d,e=/^rgba/;
<             if(a&&a.linearGradient){
<                 var f=this;
<                 b=a.linearGradient;
<                 c=oc+sd++;
<                 var g,h,j;
<                 g=f.createElement("linearGradient").attr({
<                     id:c,
<                     gradientUnits:"userSpaceOnUse",
<                     x1:b[0],
<                     y1:b[1],
<                     x2:b[2],
<                     y2:b[3]
<                 }).add(f.defs);
<                 t(a.stops,function(l){
<                     if(e.test(l[1])){
<                         d=$b(l[1]);
<                         h=d.get("rgb");
<                         j=d.get("a")
<                     }else{
<                         h=l[1];
<                         j=1
<                     }
<                     f.createElement("stop").attr({
<                         offset:l[0],
<                         "stop-color":h,
<                         "stop-opacity":j
<                     }).add(g)
<                 });
<                 return"url("+this.url+"#"+c+")"
<             }else if(e.test(a)){
<                 d=$b(a);
<                 Ca(b,c+"-opacity",d.get("a"));
<                 return d.get("rgb")
<             }else return a
<         },
<         text:function(a,b,c){
<             var d=Va.chart.style;
<             b=X(B(b,0));
<             c=X(B(c,0));
<             a=this.createElement("text").attr({
<                 x:b,
<                 y:c,
<                 text:a
<             }).css({
<                 "font-family":d.fontFamily,
<                 "font-size":d.fontSize
<             });
<             a.x=b;
<             a.y=c;
<             return a
<         }
---
>             }
>         })
>         })
>     },
> crispLine:function(a,b){
>     if(a[1]===a[4])a[1]=a[4]=X(a[1])+b%2/2;if(a[2]===a[5])a[2]=a[5]=X(a[2])+b%2/2;return a
>     },
> path:function(a){
>     return this.createElement("path").attr({
>         d:a,
>     fill:jb
>         })
>     },
> circle:function(a,b,c){
>     a=Kb(a)?a:{
>     x:a,
>     y:b,
>     r:c
>     };
>     return this.createElement("circle").attr(a)
>     },
> arc:function(a,b,c,d,e,f){
>     if(Kb(a)){
>     b=a.y;c=a.r;d=a.innerR;e=a.start;f=a.end;a=a.x
>     }
>     return this.symbol("arc",a||0,b||0,c||0,{
>         innerR:d||0,
>     start:e||0,
>     end:f||0
>         })
>     },
> rect:function(a,b,c,d,e,f){
>     if(Kb(a)){
>     b=a.y;c=a.width;
>     d=a.height;e=a.r;f=a.strokeWidth;a=a.x
>     }
>     e=this.createElement("rect").attr({
>         rx:e,
>     ry:e,
>     fill:jb
>         });return e.attr(e.crisp(f,a,b,Fa(c,0),Fa(d,0)))
>     },
> setSize:function(a,b,c){
>     var d=this.alignedObjects,e=d.length;this.width=a;this.height=b;for(this.boxWrapper[B(c,true)?"animate":"attr"]({
>         width:a,
>     height:b
>         });e--;)d[e].align()
>     },
> g:function(a){
>     return this.createElement("g").attr(J(a)&&{
>         "class":oc+a
>         })
>     },
> image:function(a,b,c,d,e){
>     var f={
>     preserveAspectRatio:jb
3078a2911,3040
>     arguments.length>1&&pa(f,{
>         x:b,
>     y:c,
>     width:d,
>     height:e
>         });f=
>     this.createElement("image").attr(f);f.element.setAttributeNS?f.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):f.element.setAttribute("hc-svg-href",a);return f
>     },
> symbol:function(a,b,c,d,e){
>     var f,g=this.symbols[a];g=g&&g(X(b),X(c),d,e);var h=/^url\((.*?)\)$/,j;if(g){
>     f=this.path(g);pa(f,{
>         symbolName:a,
>     x:b,
>     y:c,
>     r:d
>         });e&&pa(f,e)
>     }else if(h.test(a)){
>     var l=function(n,C){
>         n.attr({
>             width:C[0],
>             height:C[1]
>             }).translate(-X(C[0]/2),-X(C[1]/2))
>         };
> 
>     j=a.match(h)[1];
>     a=Wd[j];
>     f=this.image(j).attr({
>         x:b,
>         y:c
>     });
>     if(a)l(f,a);
>     else{
>         f.attr({
>             width:0,
>             height:0
>         });
>         ib("img",{
>             onload:function(){
>                 l(f,Wd[j]=[this.width,this.height])
>                 },
>             src:j
>         })
>         }
>     }else f=this.circle(b,c,d);
> return f
> },
> symbols:{
>     square:function(a,b,c){
>         c=0.707*c;
>         return[Za,a-c,b-c,Ja,a+c,b-c,a+c,b+c,a-c,b+c,"Z"]
>         },
>     triangle:function(a,b,c){
>         return[Za,a,b-1.33*c,Ja,a+c,b+0.67*c,a-c,b+0.67*c,"Z"]
>         },
>     "triangle-down":function(a,b,c){
>         return[Za,a,b+1.33*c,Ja,a-c,b-0.67*c,a+c,b-0.67*c,"Z"]
>         },
>     diamond:function(a,b,c){
>         return[Za,a,b-c,Ja,a+c,b,a,b+c,a-c,b,"Z"]
>         },
>     arc:function(a,b,c,
>         d){
>         var e=d.start,f=d.end-1.0E-6,g=d.innerR,h=nb(e),j=Bb(e),l=nb(f);
>         f=Bb(f);
>         d=d.end-e<Zb?0:1;
>         return[Za,a+c*h,b+c*j,"A",c,c,0,d,1,a+c*l,b+c*f,Ja,a+g*l,b+g*f,"A",g,g,0,d,0,a+g*h,b+g*j,"Z"]
>         }
>     },
> clipRect:function(a,b,c,d){
>     var e=oc+sd++,f=this.createElement("clipPath").attr({
>         id:e
>     }).add(this.defs);
>     a=this.rect(a,b,c,d,0).add(f);
>     a.id=e;
>     return a
>     },
> color:function(a,b,c){
>     var d,e=/^rgba/;
>     if(a&&a.linearGradient){
>         var f=this;
>         b=a.linearGradient;
>         c=oc+sd++;
>         var g,h,j;
>         g=f.createElement("linearGradient").attr({
>             id:c,
>             gradientUnits:"userSpaceOnUse",
>             x1:b[0],
>             y1:b[1],
>             x2:b[2],
>             y2:b[3]
>             }).add(f.defs);
>         t(a.stops,function(l){
>             if(e.test(l[1])){
>                 d=$b(l[1]);
>                 h=d.get("rgb");
>                 j=d.get("a")
>                 }else{
>                 h=l[1];
>                 j=1
>                 }
>                 f.createElement("stop").attr({
>                 offset:l[0],
>                 "stop-color":h,
>                 "stop-opacity":j
>             }).add(g)
>             });
>         return"url("+this.url+"#"+c+")"
>         }else if(e.test(a)){
>         d=$b(a);
>         Ca(b,c+"-opacity",d.get("a"));
>         return d.get("rgb")
>         }else return a
>         },
> text:function(a,b,c){
>     var d=Va.chart.style;
>     b=X(B(b,0));
>     c=X(B(c,0));
>     a=this.createElement("text").attr({
>         x:b,
>         y:c,
>         text:a
>     }).css({
>         "font-family":d.fontFamily,
>         "font-size":d.fontSize
>         });
>     a.x=b;
>     a.y=c;
>     return a
>     }
> };
3080,3090c3042,3052
<     Xc=Wc;
<     if(!zc){
<         wb=yb(Jc,{
<             init:function(a,b){
<                 var c=["<",b,' filled="f" stroked="f"'],d=["position: ",pc,";"];
<                 if(b==="shape"||b===Rb)d.push("left:0;top:0;width:10px;height:10px;");
<                 if(Ac)d.push("visibility: ",b===Rb?gb:ub);
<                 c.push(' style="',d.join(""),'"/>');
<                 if(b){
<                     c=b===Rb||b==="span"||b==="img"?c.join(""):a.prepVML(c);
<                     this.element=ib(c)
---
> Xc=Wc;
> if(!zc){
>     wb=yb(Jc,{
>         init:function(a,b){
>             var c=["<",b,' filled="f" stroked="f"'],d=["position: ",pc,";"];
>             if(b==="shape"||b===Rb)d.push("left:0;top:0;width:10px;height:10px;");
>             if(Ac)d.push("visibility: ",b===Rb?gb:ub);
>             c.push(' style="',d.join(""),'"/>');
>             if(b){
>                 c=b===Rb||b==="span"||b==="img"?c.join(""):a.prepVML(c);
>                 this.element=ib(c)
3094,3105c3056,3067
<             add:function(a){
<                 var b=this.renderer,c=this.element,d=b.box;
<                 d=a?a.element||a:d;
<                 a&&a.inverted&&b.invertChild(c,d);
<                 Ac&&d.gVis===
<                 gb&&La(c,{
<                     visibility:gb
<                 });
<                 d.appendChild(c);
<                 this.added=true;
<                 this.alignOnAdd&&this.updateTransform();
<                 return this
---
>         add:function(a){
>             var b=this.renderer,c=this.element,d=b.box;
>             d=a?a.element||a:d;
>             a&&a.inverted&&b.invertChild(c,d);
>             Ac&&d.gVis===
>             gb&&La(c,{
>                 visibility:gb
>             });
>             d.appendChild(c);
>             this.added=true;
>             this.alignOnAdd&&this.updateTransform();
>             return this
3107,3111c3069,3073
<             attr:function(a,b){
<                 var c,d,e,f=this.element||{},g=f.style,h=f.nodeName,j=this.renderer,l=this.symbolName,n,C,G=this.shadows,fa=this;
<                 if(Qb(a)&&J(b)){
<                     c=a;
<                     a={};
---
>         attr:function(a,b){
>             var c,d,e,f=this.element||{},g=f.style,h=f.nodeName,j=this.renderer,l=this.symbolName,n,C,G=this.shadows,fa=this;
>             if(Qb(a)&&J(b)){
>                 c=a;
>                 a={};
3113c3075
<                     a[c]=b
---
>                 a[c]=b
3116,3117c3078,3079
<                     c=a;
<                     fa=c==="strokeWidth"||c==="stroke-width"?this.strokeweight:this[c]
---
>                 c=a;
>                 fa=c==="strokeWidth"||c==="stroke-width"?this.strokeweight:this[c]
3119,3124c3081,3086
<                     d=a[c];
<                     n=false;
<                     if(l&&/^(x|y|r|start|end|width|height|innerR)/.test(c)){
<                         if(!C){
<                             this.symbolAttr(a);
<                             C=true
---
>                 d=a[c];
>                 n=false;
>                 if(l&&/^(x|y|r|start|end|width|height|innerR)/.test(c)){
>                     if(!C){
>                         this.symbolAttr(a);
>                         C=true
3128,3136c3090,3098
<                         d=
<                         d||[];
<                         this.d=d.join(" ");
<                         e=d.length;
<                         for(n=[];e--;)n[e]=ec(d[e])?X(d[e]*10)-5:d[e]==="Z"?"x":d[e];
<                         d=n.join(" ")||"x";
<                         f.path=d;
<                         if(G)for(e=G.length;e--;)G[e].path=d;
<                         n=true
---
>                     d=
>                     d||[];
>                     this.d=d.join(" ");
>                     e=d.length;
>                     for(n=[];e--;)n[e]=ec(d[e])?X(d[e]*10)-5:d[e]==="Z"?"x":d[e];
>                     d=n.join(" ")||"x";
>                     f.path=d;
>                     if(G)for(e=G.length;e--;)G[e].path=d;
>                     n=true
3138,3147c3100,3109
<                         if(Ac&&c==="visibility"&&h==="DIV"){
<                             f.gVis=d;
<                             n=f.childNodes;
<                             for(e=n.length;e--;)La(n[e],{
<                                 visibility:d
<                             });
<                             if(d===ub)d=null
<                         }
<                         if(d)g[c]=d;
<                         n=true
---
>                     if(Ac&&c==="visibility"&&h==="DIV"){
>                         f.gVis=d;
>                         n=f.childNodes;
>                         for(e=n.length;e--;)La(n[e],{
>                             visibility:d
>                         });
>                         if(d===ub)d=null
>                             }
>                             if(d)g[c]=d;
>                     n=true
3149,3151c3111,3113
<                         if(this.updateClipping){
<                             this[c]=d;
<                             this.updateClipping()
---
>                     if(this.updateClipping){
>                         this[c]=d;
>                         this.updateClipping()
3153c3115
<                         n=true
---
>                     n=true
3155,3161c3117,3123
<                         this[c]=d;
<                         if(f.tagName===
<                             "SPAN")this.updateTransform();else g[{
<                             x:"left",
<                             y:"top"
<                         }
<                         [c]]=d
---
>                     this[c]=d;
>                     if(f.tagName===
>                         "SPAN")this.updateTransform();else g[{
>                         x:"left",
>                         y:"top"
>                     }
>                     [c]]=d
3163,3165c3125,3127
<                     else if(c==="stroke"){
<                         d=j.color(d,f,c);
<                         c="strokecolor"
---
>                 else if(c==="stroke"){
>                     d=j.color(d,f,c);
>                     c="strokecolor"
3167,3174c3129,3136
<                         f.stroked=d?true:false;
<                         c="strokeweight";
<                         this[c]=d;
<                         if(ec(d))d+=$a
<                     }else if(c==="dashstyle"){
<                         (f.getElementsByTagName("stroke")[0]||ib(j.prepVML(["<stroke/>"]),null,null,f))[c]=d||"solid";
<                         this.dashstyle=d;
<                         n=true
---
>                     f.stroked=d?true:false;
>                     c="strokeweight";
>                     this[c]=d;
>                     if(ec(d))d+=$a
>                         }else if(c==="dashstyle"){
>                     (f.getElementsByTagName("stroke")[0]||ib(j.prepVML(["<stroke/>"]),null,null,f))[c]=d||"solid";
>                     this.dashstyle=d;
>                     n=true
3176,3185c3138,3147
<                         else{
<                             f.filled=d!==jb?true:false;
<                             d=j.color(d,f,c);
<                             c="fillcolor"
<                         }else if(c===
<                         "translateX"||c==="translateY"||c==="rotation"||c==="align"){
<                         if(c==="align")c="textAlign";
<                         this[c]=d;
<                         this.updateTransform();
<                         n=true
---
>                     else{
>                     f.filled=d!==jb?true:false;
>                     d=j.color(d,f,c);
>                     c="fillcolor"
>                     }else if(c===
>                     "translateX"||c==="translateY"||c==="rotation"||c==="align"){
>                     if(c==="align")c="textAlign";
>                     this[c]=d;
>                     this.updateTransform();
>                     n=true
3187,3189c3149,3151
<                         this.bBox=null;
<                         f.innerHTML=d;
<                         n=true
---
>                     this.bBox=null;
>                     f.innerHTML=d;
>                     n=true
3192,3255c3154
<                     if(!n)if(Ac)f[c]=d;else Ca(f,c,d)
<                 }
<                 return fa
<             },
<             clip:function(a){
<                 var b=this,c=a.members;
<                 c.push(b);
<                 b.destroyClip=function(){
<                     rc(c,b)
<                 };
< 
<                 return b.css(a.getCSS(b.inverted))
<             },
<             css:function(a){
<                 var b=this.element;
<                 if(b=a&&b.tagName==="SPAN"&&a.width){
<                     delete a.width;
<                     this.textWidth=
<                     b;
<                     this.updateTransform()
<                 }
<                 this.styles=pa(this.styles,a);
<                 La(this.element,a);
<                 return this
<             },
<             destroy:function(){
<                 this.destroyClip&&this.destroyClip();
<                 Jc.prototype.destroy.apply(this)
<             },
<             empty:function(){
<                 for(var a=this.element.childNodes,b=a.length,c;b--;){
<                     c=a[b];
<                     c.parentNode.removeChild(c)
<                 }
<             },
<             getBBox:function(){
<                 var a=this.element,b=this.bBox;
<                 if(!b){
<                     if(a.nodeName==="text")a.style.position=pc;
<                     b=this.bBox={
<                         x:a.offsetLeft,
<                         y:a.offsetTop,
<                         width:a.offsetWidth,
<                         height:a.offsetHeight
<                     }
<                 }
<                 return b
<             },
<             on:function(a,b){
<                 this.element["on"+
<                 a]=function(){
<                     var c=ab.event;
<                     c.target=c.srcElement;
<                     b(c)
<                 };
< 
<                 return this
<             },
<             updateTransform:function(){
<                 if(this.added){
<                     var a=this,b=a.element,c=a.translateX||0,d=a.translateY||0,e=a.x||0,f=a.y||0,g=a.textAlign||"left",h={
<                         left:0,
<                         center:0.5,
<                         right:1
---
>                 if(!n)if(Ac)f[c]=d;else Ca(f,c,d)
3257,3437c3156
<                     [g],j=g&&g!=="left";
<                     if(c||d)a.css({
<                         marginLeft:c,
<                         marginTop:d
<                     });
<                     a.inverted&&t(b.childNodes,function(P){
<                         a.renderer.invertChild(P,b)
<                     });
<                     if(b.tagName==="SPAN"){
<                         var l,n;
<                         c=a.rotation;
<                         var C;
<                         l=0;
<                         d=1;
<                         var G=0,fa;
<                         C=la(a.textWidth);
<                         var K=a.xCorr||0,ia=a.yCorr||0,u=[c,g,b.innerHTML,
<                         a.textWidth].join(",");
<                         if(u!==a.cTT){
<                             if(J(c)){
<                                 l=c*Vd;
<                                 d=nb(l);
<                                 G=Bb(l);
<                                 La(b,{
<                                     filter:c?["progid:DXImageTransform.Microsoft.Matrix(M11=",d,", M12=",-G,", M21=",G,", M22=",d,", sizingMethod='auto expand')"].join(""):jb
<                                 })
<                             }
<                             l=b.offsetWidth;
<                             n=b.offsetHeight;
<                             if(l>C){
<                                 La(b,{
<                                     width:C+$a,
<                                     display:"block",
<                                     whiteSpace:"normal"
<                                 });
<                                 l=C
<                             }
<                             C=X((la(b.style.fontSize)||12)*1.2);
<                             K=d<0&&-l;
<                             ia=G<0&&-n;
<                             fa=d*G<0;
<                             K+=G*C*(fa?1-h:h);
<                             ia-=d*C*(c?fa?h:1-h:1);
<                             if(j){
<                                 K-=l*h*(d<0?-1:1);
<                                 if(c)ia-=n*h*(G<0?-1:1);
<                                 La(b,{
<                                     textAlign:g
<                                 })
<                             }
<                             a.xCorr=K;
<                             a.yCorr=ia
<                         }
<                         La(b,{
<                             left:e+K,
<                             top:f+ia
<                         });
<                         a.cTT=u
<                     }
<                 }else this.alignOnAdd=true
<             },
<             shadow:function(a,b){
<                 var c=[],d,e=this.element,f=this.renderer,g,h=e.style,j,l=e.path;
<                 if(l&&typeof l.value!=="string")l="x";
<                 if(a){
<                     for(d=1;d<=3;d++){
<                         j=['<shape isShadow="true" strokeweight="',7-2*d,'" filled="false" path="',l,'" coordsize="100,100" style="',e.style.cssText,'" />'];
<                         g=ib(f.prepVML(j),null,{
<                             left:la(h.left)+1,
<                             top:la(h.top)+1
<                         });
<                         j=['<stroke color="black" opacity="',0.05*d,'"/>'];
<                         ib(f.prepVML(j),null,null,g);
<                         b?b.element.appendChild(g):
<                         e.parentNode.insertBefore(g,e);
<                         c.push(g)
<                     }
<                     this.shadows=c
<                 }
<                 return this
<             }
<         });
<         ka=function(){
<             this.init.apply(this,arguments)
<         };
< 
<         ka.prototype=sa(Wc.prototype,{
<             Element:wb,
<             isIE8:qc.indexOf("MSIE 8.0")>-1,
<             init:function(a,b,c){
<                 var d;
<                 this.alignedObjects=[];
<                 d=this.createElement(Rb);
<                 a.appendChild(d.element);
<                 this.box=d.element;
<                 this.boxWrapper=d;
<                 this.setSize(b,c,false);
<                 if(!wa.namespaces.hcv){
<                     wa.namespaces.add("hcv","urn:schemas-microsoft-com:vml");
<                     wa.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
<                 }
<             },
<             clipRect:function(a,b,c,d){
<                 var e=this.createElement();
<                 return pa(e,{
<                     members:[],
<                     left:a,
<                     top:b,
<                     width:c,
<                     height:d,
<                     getCSS:function(f){
<                         var g=this.top,h=this.left,j=h+this.width,l=g+this.height;
<                         g={
<                             clip:"rect("+X(f?h:g)+"px,"+X(f?l:j)+"px,"+X(f?j:l)+"px,"+X(f?g:h)+"px)"
<                         };
<                         !f&&Ac&&pa(g,{
<                             width:j+$a,
<                             height:l+$a
<                         });
<                         return g
<                     },
<                     updateClipping:function(){
<                         t(e.members,function(f){
<                             f.css(e.getCSS(f.inverted))
<                         })
<                     }
<                 })
<             },
<             color:function(a,b,c){
<                 var d,e=/^rgba/;
<                 if(a&&a.linearGradient){
<                     var f,g,h=a.linearGradient,j,l,n,C;
<                     t(a.stops,
<                         function(G,fa){
<                             if(e.test(G[1])){
<                                 d=$b(G[1]);
<                                 f=d.get("rgb");
<                                 g=d.get("a")
<                             }else{
<                                 f=G[1];
<                                 g=1
<                             }
<                             if(fa){
<                                 n=f;
<                                 C=g
<                             }else{
<                                 j=f;
<                                 l=g
<                             }
<                         });
<                     a=90-ta.atan((h[3]-h[1])/(h[2]-h[0]))*180/Zb;
<                     c=["<",c,' colors="0% ',j,",100% ",n,'" angle="',a,'" opacity="',C,'" o:opacity2="',l,'" type="gradient" focus="100%" />'];
<                     ib(this.prepVML(c),null,null,b)
<                 }
<                 else if(e.test(a)&&b.tagName!=="IMG"){
<                     d=$b(a);
<                     c=["<",c,' opacity="',d.get("a"),'"/>'];
<                     ib(this.prepVML(c),null,null,b);
<                     return d.get("rgb")
<                 }else return a
<             },
<             prepVML:function(a){
<                 var b=this.isIE8;
<                 a=a.join("");
<                 if(b){
<                     a=a.replace("/>",' xmlns="urn:schemas-microsoft-com:vml" />');
<                     a=a.indexOf('style="')===-1?a.replace("/>",' style="display:inline-block;behavior:url(#default#VML);" />'):a.replace('style="','style="display:inline-block;behavior:url(#default#VML);')
<                 }else a=a.replace("<","<hcv:");
<                 return a
<             },
<             text:function(a,b,c){
<                 var d=Va.chart.style;
<                 return this.createElement("span").attr({
<                     text:a,
<                     x:X(b),
<                     y:X(c)
<                 }).css({
<                     whiteSpace:"nowrap",
<                     fontFamily:d.fontFamily,
<                     fontSize:d.fontSize
<                 })
---
>                     return fa
3439,3456c3158,3162
<             path:function(a){
<                 return this.createElement("shape").attr({
<                     coordsize:"100 100",
<                     d:a
<                 })
<             },
<             circle:function(a,b,c){
<                 return this.symbol("circle").attr({
<                     x:a,
<                     y:b,
<                     r:c
<                 })
<             },
<             g:function(a){
<                 var b;
<                 if(a)b={
<                     className:oc+a,
<                     "class":oc+a
---
>         clip:function(a){
>             var b=this,c=a.members;
>             c.push(b);
>             b.destroyClip=function(){
>                 rc(c,b)
3459,3484c3165
<                 return this.createElement(Rb).attr(b)
<             },
<             image:function(a,b,c,d,e){
<                 var f=this.createElement("img").attr({
<                     src:a
<                 });
<                 arguments.length>1&&f.css({
<                     left:b,
<                     top:c,
<                     width:d,
<                     height:e
<                 });
<                 return f
<             },
<             rect:function(a,b,c,d,e,f){
<                 if(Kb(a)){
<                     b=a.y;
<                     c=a.width;
<                     d=a.height;
<                     e=a.r;
<                     f=a.strokeWidth;
<                     a=a.x
<                 }
<                 var g=this.symbol("rect");
<                 g.r=e;
<                 return g.attr(g.crisp(f,a,b,Fa(c,0),Fa(d,0)))
---
>             return b.css(a.getCSS(b.inverted))
3486,3593c3167,3173
<             invertChild:function(a,
<                 b){
<                 var c=b.style;
<                 La(a,{
<                     flip:"x",
<                     left:la(c.width)-10,
<                     top:la(c.height)-10,
<                     rotation:-90
<                 })
<             },
<             symbols:{
<                 arc:function(a,b,c,d){
<                     var e=d.start,f=d.end,g=nb(e),h=Bb(e),j=nb(f),l=Bb(f);
<                     d=d.innerR;
<                     var n=0.07/c,C=d&&0.1/d||0;
<                     if(f-e===0)return["x"];
<                     else if(2*Zb-f+e<n)j=-n;
<                     else if(f-e<C)j=nb(e+C);
<                     return["wa",a-c,b-c,a+c,b+c,a+c*g,b+c*h,a+c*j,b+c*l,"at",a-d,b-d,a+d,b+d,a+d*j,b+d*l,a+d*g,b+d*h,"x","e"]
<                 },
<                 circle:function(a,b,c){
<                     return["wa",a-c,b-c,a+c,b+c,a+c,b,a+c,b,"e"]
<                 },
<                 rect:function(a,b,c,d){
<                     if(!J(d))return[];
<                     var e=
<                     d.width;
<                     d=d.height;
<                     var f=a+e,g=b+d;
<                     c=qb(c,e,d);
<                     return[Za,a+c,b,Ja,f-c,b,"wa",f-2*c,b,f,b+2*c,f-c,b,f,b+c,Ja,f,g-c,"wa",f-2*c,g-2*c,f,g,f,g-c,f-c,g,Ja,a+c,g,"wa",a,g-2*c,a+2*c,g,a+c,g,a,g-c,Ja,a,b+c,"wa",a,b,a+2*c,b+2*c,a,b+c,a+c,b,"x","e"]
<                 }
<             }
<         });
<         Xc=ka
<     }
<     Hd.prototype.callbacks=[];
<     var Bc=function(){};
< 
<     Bc.prototype={
<         init:function(a,b){
<             var c;
<             this.series=a;
<             this.applyOptions(b);
<             this.pointAttr={};
< 
<             if(a.options.colorByPoint){
<                 c=a.chart.options.colors;
<                 if(!this.options)this.options={};
< 
<                 this.color=this.options.color=
<                 this.color||c[Pb++];
<                 if(Pb>=c.length)Pb=0
<             }
<             a.chart.pointCount++;
<             return this
<         },
<         applyOptions:function(a){
<             var b=this.series;
<             this.config=a;
<             if(ec(a)||a===null)this.y=a;
<             else if(Kb(a)&&!ec(a.length)){
<                 pa(this,a);
<                 this.options=a
<             }else if(Qb(a[0])){
<                 this.name=a[0];
<                 this.y=a[1]
<             }
<             else if(ec(a[0])){
<                 this.x=a[0];
<                 this.y=a[1]
<             }
<             if(this.x===Ua)this.x=b.autoIncrement()
<         },
<         destroy:function(){
<             var a=this,b=a.series,c;
<             b.chart.pointCount--;
<             a===b.chart.hoverPoint&&a.onMouseOut();
<             b.chart.hoverPoints=null;
<             Gb(a);
<             t(["graphic","tracker",
<                 "group","dataLabel","connector"],function(d){
<                     a[d]&&a[d].destroy()
<                 });
<             a.legendItem&&a.series.chart.legend.destroyItem(a);
<             for(c in a)a[c]=null
<         },
<         getLabelConfig:function(){
<             return{
<                 x:this.category,
<                 y:this.y,
<                 series:this.series,
<                 point:this,
<                 percentage:this.percentage,
<                 total:this.total||this.stackTotal
<             }
<         },
<         select:function(a,b){
<             var c=this,d=c.series.chart;
<             c.selected=a=B(a,!c.selected);
<             c.firePointEvent(a?"select":"unselect");
<             c.setState(a&&"select");
<             b||t(d.getSelectedPoints(),function(e){
<                 if(e.selected&&e!==c){
<                     e.selected=
<                     false;
<                     e.setState(hb);
<                     e.firePointEvent("unselect")
---
>         css:function(a){
>             var b=this.element;
>             if(b=a&&b.tagName==="SPAN"&&a.width){
>                 delete a.width;
>                 this.textWidth=
>                 b;
>                 this.updateTransform()
3595,3624c3175,3186
<             })
<         },
<         onMouseOver:function(){
<             var a=this.series.chart,b=a.tooltip,c=a.hoverPoint;
<             c&&c!==this&&c.onMouseOut();
<             this.firePointEvent("mouseOver");
<             b&&!b.shared&&b.refresh(this);
<             this.setState(Ab);
<             a.hoverPoint=this
<         },
<         onMouseOut:function(){
<             this.firePointEvent("mouseOut");
<             this.setState();
<             this.series.chart.hoverPoint=null
<         },
<         tooltipFormatter:function(a){
<             var b=this.series;
<             return['<span style="color:'+b.color+'">',this.name||b.name,"</span>: ",!a?"<b>x = "+(this.name||
<                 this.x)+",</b> ":"","<b>",!a?"y = ":"",this.y,"</b>"].join("")
<         },
<         update:function(a,b,c){
<             var d=this,e=d.series,f=d.graphic,g=e.chart;
<             b=B(b,true);
<             d.firePointEvent("update",{
<                 options:a
<             },function(){
<                 d.applyOptions(a);
<                 if(Kb(a)){
<                     e.getAttribs();
<                     f&&f.attr(d.pointAttr[e.state])
---
>                 this.styles=pa(this.styles,a);
>             La(this.element,a);
>             return this
>             },
>         destroy:function(){
>             this.destroyClip&&this.destroyClip();
>             Jc.prototype.destroy.apply(this)
>             },
>         empty:function(){
>             for(var a=this.element.childNodes,b=a.length,c;b--;){
>                 c=a[b];
>                 c.parentNode.removeChild(c)
3626,3646c3188,3207
<                 e.isDirty=true;
<                 b&&g.redraw(c)
<             })
<         },
<         remove:function(a,b){
<             var c=this,d=c.series,e=d.chart,f=d.data;
<             fc(b,e);
<             a=B(a,true);
<             c.firePointEvent("remove",null,function(){
<                 rc(f,c);
<                 c.destroy();
<                 d.isDirty=true;
<                 a&&e.redraw()
<             })
<         },
<         firePointEvent:function(a,
<             b,c){
<             var d=this,e=this.series.options;
<             if(e.point.events[a]||d.options&&d.options.events&&d.options.events[a])this.importEvents();
<             if(a==="click"&&e.allowPointSelect)c=function(f){
<                 d.select(null,f.ctrlKey||f.metaKey||f.shiftKey)
---
>             },
>     getBBox:function(){
>         var a=this.element,b=this.bBox;
>         if(!b){
>             if(a.nodeName==="text")a.style.position=pc;
>             b=this.bBox={
>                 x:a.offsetLeft,
>                 y:a.offsetTop,
>                 width:a.offsetWidth,
>                 height:a.offsetHeight
>                 }
>             }
>         return b
>     },
>     on:function(a,b){
>         this.element["on"+
>         a]=function(){
>             var c=ab.event;
>             c.target=c.srcElement;
>             b(c)
3649,3656c3210
<             Pa(this,a,b,c)
<         },
<         importEvents:function(){
<             if(!this.hasImportedEvents){
<                 var a=sa(this.series.options.point,this.options).events,b;
<                 this.events=a;
<                 for(b in a)Sa(this,b,a[b]);this.hasImportedEvents=true
<             }
---
>         return this
3658,3667c3212,3270
<         setState:function(a){
<             var b=this.series,c=b.options.states,d=xb[b.type].marker&&
<             b.options.marker,e=d&&!d.enabled,f=(d=d&&d.states[a])&&d.enabled===false,g=b.stateMarkerGraphic,h=b.chart,j=this.pointAttr;
<             a=a||hb;
<             if(!(a===this.state||this.selected&&a!=="select"||c[a]&&c[a].enabled===false||a&&(f||e&&!d.enabled))){
<                 if(this.graphic)this.graphic.attr(j[a]);
<                 else{
<                     if(a){
<                         if(!g)b.stateMarkerGraphic=g=h.renderer.circle(0,0,j[a].r).attr(j[a]).add(b.group);
<                         g.translate(this.plotX,this.plotY)
---
>     updateTransform:function(){
>         if(this.added){
>             var a=this,b=a.element,c=a.translateX||0,d=a.translateY||0,e=a.x||0,f=a.y||0,g=a.textAlign||"left",h={
>                 left:0,
>                 center:0.5,
>                 right:1
>             }
>             [g],j=g&&g!=="left";
>             if(c||d)a.css({
>                 marginLeft:c,
>                 marginTop:d
>             });
>             a.inverted&&t(b.childNodes,function(P){
>                 a.renderer.invertChild(P,b)
>                 });
>             if(b.tagName==="SPAN"){
>                 var l,n;
>                 c=a.rotation;
>                 var C;
>                 l=0;
>                 d=1;
>                 var G=0,fa;
>                 C=la(a.textWidth);
>                 var K=a.xCorr||0,ia=a.yCorr||0,u=[c,g,b.innerHTML,
>                 a.textWidth].join(",");
>                 if(u!==a.cTT){
>                     if(J(c)){
>                         l=c*Vd;
>                         d=nb(l);
>                         G=Bb(l);
>                         La(b,{
>                             filter:c?["progid:DXImageTransform.Microsoft.Matrix(M11=",d,", M12=",-G,", M21=",G,", M22=",d,", sizingMethod='auto expand')"].join(""):jb
>                             })
>                         }
>                         l=b.offsetWidth;
>                     n=b.offsetHeight;
>                     if(l>C){
>                         La(b,{
>                             width:C+$a,
>                             display:"block",
>                             whiteSpace:"normal"
>                         });
>                         l=C
>                         }
>                         C=X((la(b.style.fontSize)||12)*1.2);
>                     K=d<0&&-l;
>                     ia=G<0&&-n;
>                     fa=d*G<0;
>                     K+=G*C*(fa?1-h:h);
>                     ia-=d*C*(c?fa?h:1-h:1);
>                     if(j){
>                         K-=l*h*(d<0?-1:1);
>                         if(c)ia-=n*h*(G<0?-1:1);
>                         La(b,{
>                             textAlign:g
>                         })
>                         }
>                         a.xCorr=K;
>                     a.yCorr=ia
3669c3272,3276
<                     if(g)g[a?"show":"hide"]()
---
>                     La(b,{
>                     left:e+K,
>                     top:f+ia
>                     });
>                 a.cTT=u
3671c3278,3294
<                 this.state=a
---
>             }else this.alignOnAdd=true
>         },
> shadow:function(a,b){
>     var c=[],d,e=this.element,f=this.renderer,g,h=e.style,j,l=e.path;
>     if(l&&typeof l.value!=="string")l="x";
>     if(a){
>         for(d=1;d<=3;d++){
>             j=['<shape isShadow="true" strokeweight="',7-2*d,'" filled="false" path="',l,'" coordsize="100,100" style="',e.style.cssText,'" />'];
>             g=ib(f.prepVML(j),null,{
>                 left:la(h.left)+1,
>                 top:la(h.top)+1
>                 });
>             j=['<stroke color="black" opacity="',0.05*d,'"/>'];
>             ib(f.prepVML(j),null,null,g);
>             b?b.element.appendChild(g):
>             e.parentNode.insertBefore(g,e);
>             c.push(g)
3672a3296
>             this.shadows=c
3673a3298,3302
>         return this
>     }
> });
> ka=function(){
>     this.init.apply(this,arguments)
3676,3797c3305,3342
<     var pb=function(){};
< 
<     pb.prototype={
<         isCartesian:true,
<         type:"line",
<         pointClass:Bc,
<         pointAttrToOptions:{
<             stroke:"lineColor",
<             "stroke-width":"lineWidth",
<             fill:"fillColor",
<             r:"radius"
<         },
<         init:function(a,b){
<             var c,d;
<             d=a.series.length;
<             this.chart=a;
<             b=this.setOptions(b);
<             pa(this,{
<                 index:d,
<                 options:b,
<                 name:b.name||"Series "+(d+1),
<                 state:hb,
<                 pointAttr:{},
<                 visible:b.visible!==false,
<                 selected:b.selected===true
<             });
<             d=b.events;
<             for(c in d)Sa(this,c,d[c]);if(d&&d.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=true;
<             this.getColor();
<             this.getSymbol();
<             this.setData(b.data,
<                 false)
<         },
<         autoIncrement:function(){
<             var a=this.options,b=this.xIncrement;
<             b=B(b,a.pointStart,0);
<             this.pointInterval=B(this.pointInterval,a.pointInterval,1);
<             this.xIncrement=b+this.pointInterval;
<             return b
<         },
<         cleanData:function(){
<             var a=this.chart,b=this.data,c,d,e=a.smallestInterval,f,g;
<             b.sort(function(h,j){
<                 return h.x-j.x
<             });
<             if(this.options.connectNulls)for(g=b.length-1;g>=0;g--)b[g].y===null&&b[g-1]&&b[g+1]&&b.splice(g,1);
<             for(g=b.length-1;g>=0;g--)if(b[g-1]){
<                 f=b[g].x-b[g-1].x;
<                 if(f>0&&(d===Ua||f<d)){
<                     d=f;
<                     c=g
<                 }
<             }
<             if(e===
<                 Ua||d<e)a.smallestInterval=d;
<             this.closestPoints=c
<         },
<         getSegments:function(){
<             var a=-1,b=[],c=this.data;
<             t(c,function(d,e){
<                 if(d.y===null){
<                     e>a+1&&b.push(c.slice(a+1,e));
<                     a=e
<                 }else e===c.length-1&&b.push(c.slice(a+1,e+1))
<             });
<             this.segments=b
<         },
<         setOptions:function(a){
<             var b=this.chart.options.plotOptions;
<             return sa(b[this.type],b.series,a)
<         },
<         getColor:function(){
<             var a=this.chart.options.colors;
<             this.color=this.options.color||a[Pb++]||"#0000ff";
<             if(Pb>=a.length)Pb=0
<         },
<         getSymbol:function(){
<             var a=this.chart.options.symbols;
<             this.symbol=this.options.marker.symbol||a[Yc++];
<             if(Yc>=a.length)Yc=0
<         },
<         addPoint:function(a,b,c,d){
<             var e=this.data,f=this.graph,g=this.area,h=this.chart;
<             a=(new this.pointClass).init(this,a);
<             fc(d,h);
<             if(f&&c)f.shift=c;
<             if(g){
<                 g.shift=c;
<                 g.isArea=true
<             }
<             b=B(b,true);
<             e.push(a);
<             c&&e[0].remove(false);
<             this.getAttribs();
<             this.isDirty=true;
<             b&&h.redraw()
<         },
<         setData:function(a,b){
<             var c=this,d=c.data,e=c.initialColor,f=c.chart,g=d&&d.length||0;
<             c.xIncrement=null;
<             if(J(e))Pb=e;
<             for(a=nc(sc(a||[]),function(h){
<                 return(new c.pointClass).init(c,
<                     h)
<             });g--;)d[g].destroy();
<             c.data=a;
<             c.cleanData();
<             c.getSegments();
<             c.getAttribs();
<             c.isDirty=true;
<             f.isDirtyBox=true;
<             B(b,true)&&f.redraw(false)
<         },
<         remove:function(a,b){
<             var c=this,d=c.chart;
<             a=B(a,true);
<             if(!c.isRemoving){
<                 c.isRemoving=true;
<                 Pa(c,"remove",null,function(){
<                     c.destroy();
<                     d.isDirtyLegend=d.isDirtyBox=true;
<                     a&&d.redraw(b)
---
> ka.prototype=sa(Wc.prototype,{
>     Element:wb,
>     isIE8:qc.indexOf("MSIE 8.0")>-1,
>     init:function(a,b,c){
>         var d;
>         this.alignedObjects=[];
>         d=this.createElement(Rb);
>         a.appendChild(d.element);
>         this.box=d.element;
>         this.boxWrapper=d;
>         this.setSize(b,c,false);
>         if(!wa.namespaces.hcv){
>             wa.namespaces.add("hcv","urn:schemas-microsoft-com:vml");
>             wa.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
>             }
>         },
> clipRect:function(a,b,c,d){
>     var e=this.createElement();
>     return pa(e,{
>         members:[],
>         left:a,
>         top:b,
>         width:c,
>         height:d,
>         getCSS:function(f){
>             var g=this.top,h=this.left,j=h+this.width,l=g+this.height;
>             g={
>                 clip:"rect("+X(f?h:g)+"px,"+X(f?l:j)+"px,"+X(f?j:l)+"px,"+X(f?g:h)+"px)"
>                 };
>             !f&&Ac&&pa(g,{
>                 width:j+$a,
>                 height:l+$a
>                 });
>             return g
>             },
>         updateClipping:function(){
>             t(e.members,function(f){
>                 f.css(e.getCSS(f.inverted))
3800,3814c3345,3359
<             c.isRemoving=false
<         },
<         translate:function(){
<             for(var a=this.chart,b=this.options.stacking,c=this.xAxis.categories,d=this.yAxis,e=this.data,f=e.length;f--;){
<                 var g=e[f],h=g.x,j=g.y,l=g.low,
<                 n=d.stacks[(j<0?"-":"")+this.stackKey];
<                 g.plotX=this.xAxis.translate(h);
<                 if(b&&this.visible&&n&&n[h]){
<                     l=n[h];
<                     h=l.total;
<                     l.cum=l=l.cum-j;
<                     j=l+j;
<                     if(b==="percent"){
<                         l=h?l*100/h:0;
<                         j=h?j*100/h:0
---
>         })
> },
> color:function(a,b,c){
>     var d,e=/^rgba/;
>     if(a&&a.linearGradient){
>         var f,g,h=a.linearGradient,j,l,n,C;
>         t(a.stops,
>             function(G,fa){
>                 if(e.test(G[1])){
>                     d=$b(G[1]);
>                     f=d.get("rgb");
>                     g=d.get("a")
>                     }else{
>                     f=G[1];
>                     g=1
3816,3822c3361,3514
<                     g.percentage=h?g.y*100/h:0;
<                     g.stackTotal=h
<                 }
<                 if(J(l))g.yBottom=d.translate(l,0,1,0,1);
<                 if(j!==null)g.plotY=d.translate(j,0,1,0,1);
<                 g.clientX=a.inverted?a.plotHeight-g.plotX:g.plotX;
<                 g.category=c&&c[g.x]!==Ua?c[g.x]:g.x
---
>                     if(fa){
>                     n=f;
>                     C=g
>                     }else{
>                     j=f;
>                     l=g
>                     }
>                 });
>     a=90-ta.atan((h[3]-h[1])/(h[2]-h[0]))*180/Zb;
>     c=["<",c,' colors="0% ',j,",100% ",n,'" angle="',a,'" opacity="',C,'" o:opacity2="',l,'" type="gradient" focus="100%" />'];
>     ib(this.prepVML(c),null,null,b)
>     }
>     else if(e.test(a)&&b.tagName!=="IMG"){
>     d=$b(a);
>     c=["<",c,' opacity="',d.get("a"),'"/>'];
>     ib(this.prepVML(c),null,null,b);
>     return d.get("rgb")
>     }else return a
>     },
> prepVML:function(a){
>     var b=this.isIE8;
>     a=a.join("");
>     if(b){
>         a=a.replace("/>",' xmlns="urn:schemas-microsoft-com:vml" />');
>         a=a.indexOf('style="')===-1?a.replace("/>",' style="display:inline-block;behavior:url(#default#VML);" />'):a.replace('style="','style="display:inline-block;behavior:url(#default#VML);')
>         }else a=a.replace("<","<hcv:");
>     return a
>     },
> text:function(a,b,c){
>     var d=Va.chart.style;
>     return this.createElement("span").attr({
>         text:a,
>         x:X(b),
>         y:X(c)
>         }).css({
>         whiteSpace:"nowrap",
>         fontFamily:d.fontFamily,
>         fontSize:d.fontSize
>         })
>     },
> path:function(a){
>     return this.createElement("shape").attr({
>         coordsize:"100 100",
>         d:a
>     })
>     },
> circle:function(a,b,c){
>     return this.symbol("circle").attr({
>         x:a,
>         y:b,
>         r:c
>     })
>     },
> g:function(a){
>     var b;
>     if(a)b={
>         className:oc+a,
>         "class":oc+a
>         };
> 
>     return this.createElement(Rb).attr(b)
>     },
> image:function(a,b,c,d,e){
>     var f=this.createElement("img").attr({
>         src:a
>     });
>     arguments.length>1&&f.css({
>         left:b,
>         top:c,
>         width:d,
>         height:e
>     });
>     return f
>     },
> rect:function(a,b,c,d,e,f){
>     if(Kb(a)){
>         b=a.y;
>         c=a.width;
>         d=a.height;
>         e=a.r;
>         f=a.strokeWidth;
>         a=a.x
>         }
>         var g=this.symbol("rect");
>     g.r=e;
>     return g.attr(g.crisp(f,a,b,Fa(c,0),Fa(d,0)))
>     },
> invertChild:function(a,
>     b){
>     var c=b.style;
>     La(a,{
>         flip:"x",
>         left:la(c.width)-10,
>         top:la(c.height)-10,
>         rotation:-90
>     })
>     },
> symbols:{
>     arc:function(a,b,c,d){
>         var e=d.start,f=d.end,g=nb(e),h=Bb(e),j=nb(f),l=Bb(f);
>         d=d.innerR;
>         var n=0.07/c,C=d&&0.1/d||0;
>         if(f-e===0)return["x"];
>         else if(2*Zb-f+e<n)j=-n;
>         else if(f-e<C)j=nb(e+C);
>         return["wa",a-c,b-c,a+c,b+c,a+c*g,b+c*h,a+c*j,b+c*l,"at",a-d,b-d,a+d,b+d,a+d*j,b+d*l,a+d*g,b+d*h,"x","e"]
>         },
>     circle:function(a,b,c){
>         return["wa",a-c,b-c,a+c,b+c,a+c,b,a+c,b,"e"]
>         },
>     rect:function(a,b,c,d){
>         if(!J(d))return[];
>         var e=
>         d.width;
>         d=d.height;
>         var f=a+e,g=b+d;
>         c=qb(c,e,d);
>         return[Za,a+c,b,Ja,f-c,b,"wa",f-2*c,b,f,b+2*c,f-c,b,f,b+c,Ja,f,g-c,"wa",f-2*c,g-2*c,f,g,f,g-c,f-c,g,Ja,a+c,g,"wa",a,g-2*c,a+2*c,g,a+c,g,a,g-c,Ja,a,b+c,"wa",a,b,a+2*c,b+2*c,a,b+c,a+c,b,"x","e"]
>         }
>     }
> });
> Xc=ka
> }
> Hd.prototype.callbacks=[];
> var Bc=function(){};
> 
> Bc.prototype={
>     init:function(a,b){
>         var c;
>         this.series=a;
>         this.applyOptions(b);
>         this.pointAttr={};
> 
>         if(a.options.colorByPoint){
>             c=a.chart.options.colors;
>             if(!this.options)this.options={};
> 
>             this.color=this.options.color=
>             this.color||c[Pb++];
>             if(Pb>=c.length)Pb=0
>                 }
>                 a.chart.pointCount++;
>         return this
>         },
>     applyOptions:function(a){
>         var b=this.series;
>         this.config=a;
>         if(ec(a)||a===null)this.y=a;
>         else if(Kb(a)&&!ec(a.length)){
>             pa(this,a);
>             this.options=a
>             }else if(Qb(a[0])){
>             this.name=a[0];
>             this.y=a[1]
3824,3846c3516,3518
<         },
<         setTooltipPoints:function(a){
<             var b=this.chart,c=b.inverted,d=[],e=X((c?b.plotTop:b.plotLeft)+b.plotSizeX),
<             f,g,h=[];
<             if(a)this.tooltipPoints=null;
<             t(this.segments,function(j){
<                 d=d.concat(j)
<             });
<             if(this.xAxis&&this.xAxis.reversed)d=d.reverse();
<             t(d,function(j,l){
<                 f=d[l-1]?d[l-1]._high+1:0;
<                 for(g=j._high=d[l+1]?kb((j.plotX+(d[l+1]?d[l+1].plotX:e))/2):e;f<=g;)h[c?e-f++:f++]=j
<             });
<             this.tooltipPoints=h
<         },
<         onMouseOver:function(){
<             var a=this.chart,b=a.hoverSeries;
<             if(!(!Nb&&a.mouseIsDown)){
<                 b&&b!==this&&b.onMouseOut();
<                 this.options.events.mouseOver&&Pa(this,"mouseOver");
<                 this.tracker&&this.tracker.toFront();
<                 this.setState(Ab);
<                 a.hoverSeries=this
---
>             else if(ec(a[0])){
>             this.x=a[0];
>             this.y=a[1]
3848,3859c3520,3609
<         },
<         onMouseOut:function(){
<             var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;
<             d&&d.onMouseOut();
<             this&&a.events.mouseOut&&Pa(this,"mouseOut");
<             c&&!a.stickyTracking&&c.hide();
<             this.setState();
<             b.hoverSeries=null
<         },
<         animate:function(a){
<             var b=this.chart,c=this.clipRect,d=this.options.animation;
<             if(d&&!Kb(d))d={};
---
>             if(this.x===Ua)this.x=b.autoIncrement()
>             },
>     destroy:function(){
>         var a=this,b=a.series,c;
>         b.chart.pointCount--;
>         a===b.chart.hoverPoint&&a.onMouseOut();
>         b.chart.hoverPoints=null;
>         Gb(a);
>         t(["graphic","tracker",
>             "group","dataLabel","connector"],function(d){
>                 a[d]&&a[d].destroy()
>                 });
>         a.legendItem&&a.series.chart.legend.destroyItem(a);
>         for(c in a)a[c]=null
>             },
>     getLabelConfig:function(){
>         return{
>             x:this.category,
>             y:this.y,
>             series:this.series,
>             point:this,
>             percentage:this.percentage,
>             total:this.total||this.stackTotal
>             }
>         },
> select:function(a,b){
>     var c=this,d=c.series.chart;
>     c.selected=a=B(a,!c.selected);
>     c.firePointEvent(a?"select":"unselect");
>     c.setState(a&&"select");
>     b||t(d.getSelectedPoints(),function(e){
>         if(e.selected&&e!==c){
>             e.selected=
>             false;
>             e.setState(hb);
>             e.firePointEvent("unselect")
>             }
>         })
> },
> onMouseOver:function(){
>     var a=this.series.chart,b=a.tooltip,c=a.hoverPoint;
>     c&&c!==this&&c.onMouseOut();
>     this.firePointEvent("mouseOver");
>     b&&!b.shared&&b.refresh(this);
>     this.setState(Ab);
>     a.hoverPoint=this
>     },
> onMouseOut:function(){
>     this.firePointEvent("mouseOut");
>     this.setState();
>     this.series.chart.hoverPoint=null
>     },
> tooltipFormatter:function(a){
>     var b=this.series;
>     return['<span style="color:'+b.color+'">',this.name||b.name,"</span>: ",!a?"<b>x = "+(this.name||
>         this.x)+",</b> ":"","<b>",!a?"y = ":"",this.y,"</b>"].join("")
>     },
> update:function(a,b,c){
>     var d=this,e=d.series,f=d.graphic,g=e.chart;
>     b=B(b,true);
>     d.firePointEvent("update",{
>         options:a
>     },function(){
>         d.applyOptions(a);
>         if(Kb(a)){
>             e.getAttribs();
>             f&&f.attr(d.pointAttr[e.state])
>             }
>             e.isDirty=true;
>         b&&g.redraw(c)
>         })
>     },
> remove:function(a,b){
>     var c=this,d=c.series,e=d.chart,f=d.data;
>     fc(b,e);
>     a=B(a,true);
>     c.firePointEvent("remove",null,function(){
>         rc(f,c);
>         c.destroy();
>         d.isDirty=true;
>         a&&e.redraw()
>         })
>     },
> firePointEvent:function(a,
>     b,c){
>     var d=this,e=this.series.options;
>     if(e.point.events[a]||d.options&&d.options.events&&d.options.events[a])this.importEvents();
>     if(a==="click"&&e.allowPointSelect)c=function(f){
>         d.select(null,f.ctrlKey||f.metaKey||f.shiftKey)
>         };
3860a3611,3626
>     Pa(this,a,b,c)
>     },
> importEvents:function(){
>     if(!this.hasImportedEvents){
>         var a=sa(this.series.options.point,this.options).events,b;
>         this.events=a;
>         for(b in a)Sa(this,b,a[b]);this.hasImportedEvents=true
>         }
>     },
> setState:function(a){
>     var b=this.series,c=b.options.states,d=xb[b.type].marker&&
>     b.options.marker,e=d&&!d.enabled,f=(d=d&&d.states[a])&&d.enabled===false,g=b.stateMarkerGraphic,h=b.chart,j=this.pointAttr;
>     a=a||hb;
>     if(!(a===this.state||this.selected&&a!=="select"||c[a]&&c[a].enabled===false||a&&(f||e&&!d.enabled))){
>         if(this.graphic)this.graphic.attr(j[a]);
>         else{
3862,3864c3628,3629
<                 if(!c.isAnimating){
<                     c.attr("width",0);
<                     c.isAnimating=true
---
>                 if(!g)b.stateMarkerGraphic=g=h.renderer.circle(0,0,j[a].r).attr(j[a]).add(b.group);
>                 g.translate(this.plotX,this.plotY)
3866,3888c3631
<             }else{
<                 c.animate({
<                     width:b.plotSizeX
<                 },d);
<                 this.animate=null
<             }
<         },
<         drawPoints:function(){
<             var a,b=this.data,c=this.chart,
<             d,e,f,g,h,j;
<             if(this.options.marker.enabled)for(f=b.length;f--;){
<                 g=b[f];
<                 d=g.plotX;
<                 e=g.plotY;
<                 j=g.graphic;
<                 if(e!==Ua&&!isNaN(e)){
<                     a=g.pointAttr[g.selected?"select":hb];
<                     h=a.r;
<                     if(j)j.animate({
<                         x:d,
<                         y:e,
<                         r:h
<                     });else g.graphic=c.renderer.symbol(B(g.marker&&g.marker.symbol,this.symbol),d,e,h).attr(a).add(this.group)
---
>                 if(g)g[a?"show":"hide"]()
3890,3899c3633,3636
<             }
<         },
<         convertAttribs:function(a,b,c,d){
<             var e=this.pointAttrToOptions,f,g,h={};
< 
<             a=a||{};
< 
<             b=b||{};
< 
<             c=c||{};
---
>                 this.state=a
>         }
>     }
> };
3901c3638
<             d=d||{};
---
> var pb=function(){};
3903,3940c3640,3915
<             for(f in e){
<                 g=e[f];
<                 h[f]=B(a[g],b[f],c[f],d[f])
<             }
<             return h
<         },
<         getAttribs:function(){
<             var a=this,
<             b=xb[a.type].marker?a.options.marker:a.options,c=b.states,d=c[Ab],e,f=a.color,g={
<                 stroke:f,
<                 fill:f
<             },h=a.data,j=[],l,n=a.pointAttrToOptions,C;
<             if(a.options.marker){
<                 d.radius=d.radius||b.radius+2;
<                 d.lineWidth=d.lineWidth||b.lineWidth+1
<             }else d.color=d.color||$b(d.color||f).brighten(d.brightness).get();
<             j[hb]=a.convertAttribs(b,g);
<             t([Ab,"select"],function(G){
<                 j[G]=a.convertAttribs(c[G],j[hb])
<             });
<             a.pointAttr=j;
<             for(f=h.length;f--;){
<                 g=h[f];
<                 if((b=g.options&&g.options.marker||g.options)&&b.enabled===false)b.radius=
<                     0;
<                 e=false;
<                 if(g.options)for(C in n)if(J(b[n[C]]))e=true;if(e){
<                     l=[];
<                     c=b.states||{};
< 
<                     e=c[Ab]=c[Ab]||{};
< 
<                     if(!a.options.marker)e.color=$b(e.color||g.options.color).brighten(e.brightness||d.brightness).get();
<                     l[hb]=a.convertAttribs(b,j[hb]);
<                     l[Ab]=a.convertAttribs(c[Ab],j[Ab],l[hb]);
<                     l.select=a.convertAttribs(c.select,j.select,l[hb])
<                 }else l=j;
<                 g.pointAttr=l
---
> pb.prototype={
>     isCartesian:true,
>     type:"line",
>     pointClass:Bc,
>     pointAttrToOptions:{
>         stroke:"lineColor",
>         "stroke-width":"lineWidth",
>         fill:"fillColor",
>         r:"radius"
>     },
>     init:function(a,b){
>         var c,d;
>         d=a.series.length;
>         this.chart=a;
>         b=this.setOptions(b);
>         pa(this,{
>             index:d,
>             options:b,
>             name:b.name||"Series "+(d+1),
>             state:hb,
>             pointAttr:{},
>             visible:b.visible!==false,
>             selected:b.selected===true
>             });
>         d=b.events;
>         for(c in d)Sa(this,c,d[c]);if(d&&d.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=true;
>         this.getColor();
>         this.getSymbol();
>         this.setData(b.data,
>             false)
>         },
>     autoIncrement:function(){
>         var a=this.options,b=this.xIncrement;
>         b=B(b,a.pointStart,0);
>         this.pointInterval=B(this.pointInterval,a.pointInterval,1);
>         this.xIncrement=b+this.pointInterval;
>         return b
>         },
>     cleanData:function(){
>         var a=this.chart,b=this.data,c,d,e=a.smallestInterval,f,g;
>         b.sort(function(h,j){
>             return h.x-j.x
>             });
>         if(this.options.connectNulls)for(g=b.length-1;g>=0;g--)b[g].y===null&&b[g-1]&&b[g+1]&&b.splice(g,1);
>         for(g=b.length-1;g>=0;g--)if(b[g-1]){
>             f=b[g].x-b[g-1].x;
>             if(f>0&&(d===Ua||f<d)){
>                 d=f;
>                 c=g
>                 }
>             }
>         if(e===
>         Ua||d<e)a.smallestInterval=d;
>     this.closestPoints=c
>     },
> getSegments:function(){
>     var a=-1,b=[],c=this.data;
>     t(c,function(d,e){
>         if(d.y===null){
>             e>a+1&&b.push(c.slice(a+1,e));
>             a=e
>             }else e===c.length-1&&b.push(c.slice(a+1,e+1))
>             });
>     this.segments=b
>     },
> setOptions:function(a){
>     var b=this.chart.options.plotOptions;
>     return sa(b[this.type],b.series,a)
>     },
> getColor:function(){
>     var a=this.chart.options.colors;
>     this.color=this.options.color||a[Pb++]||"#0000ff";
>     if(Pb>=a.length)Pb=0
>         },
> getSymbol:function(){
>     var a=this.chart.options.symbols;
>     this.symbol=this.options.marker.symbol||a[Yc++];
>     if(Yc>=a.length)Yc=0
>         },
> addPoint:function(a,b,c,d){
>     var e=this.data,f=this.graph,g=this.area,h=this.chart;
>     a=(new this.pointClass).init(this,a);
>     fc(d,h);
>     if(f&&c)f.shift=c;
>     if(g){
>         g.shift=c;
>         g.isArea=true
>         }
>         b=B(b,true);
>     e.push(a);
>     c&&e[0].remove(false);
>     this.getAttribs();
>     this.isDirty=true;
>     b&&h.redraw()
>     },
> setData:function(a,b){
>     var c=this,d=c.data,e=c.initialColor,f=c.chart,g=d&&d.length||0;
>     c.xIncrement=null;
>     if(J(e))Pb=e;
>     for(a=nc(sc(a||[]),function(h){
>         return(new c.pointClass).init(c,
>             h)
>         });g--;)d[g].destroy();
>     c.data=a;
>     c.cleanData();
>     c.getSegments();
>     c.getAttribs();
>     c.isDirty=true;
>     f.isDirtyBox=true;
>     B(b,true)&&f.redraw(false)
>     },
> remove:function(a,b){
>     var c=this,d=c.chart;
>     a=B(a,true);
>     if(!c.isRemoving){
>         c.isRemoving=true;
>         Pa(c,"remove",null,function(){
>             c.destroy();
>             d.isDirtyLegend=d.isDirtyBox=true;
>             a&&d.redraw(b)
>             })
>         }
>         c.isRemoving=false
>     },
> translate:function(){
>     for(var a=this.chart,b=this.options.stacking,c=this.xAxis.categories,d=this.yAxis,e=this.data,f=e.length;f--;){
>         var g=e[f],h=g.x,j=g.y,l=g.low,
>         n=d.stacks[(j<0?"-":"")+this.stackKey];
>         g.plotX=this.xAxis.translate(h);
>         if(b&&this.visible&&n&&n[h]){
>             l=n[h];
>             h=l.total;
>             l.cum=l=l.cum-j;
>             j=l+j;
>             if(b==="percent"){
>                 l=h?l*100/h:0;
>                 j=h?j*100/h:0
>                 }
>                 g.percentage=h?g.y*100/h:0;
>             g.stackTotal=h
>             }
>             if(J(l))g.yBottom=d.translate(l,0,1,0,1);
>         if(j!==null)g.plotY=d.translate(j,0,1,0,1);
>         g.clientX=a.inverted?a.plotHeight-g.plotX:g.plotX;
>         g.category=c&&c[g.x]!==Ua?c[g.x]:g.x
>         }
>     },
> setTooltipPoints:function(a){
>     var b=this.chart,c=b.inverted,d=[],e=X((c?b.plotTop:b.plotLeft)+b.plotSizeX),
>     f,g,h=[];
>     if(a)this.tooltipPoints=null;
>     t(this.segments,function(j){
>         d=d.concat(j)
>         });
>     if(this.xAxis&&this.xAxis.reversed)d=d.reverse();
>     t(d,function(j,l){
>         f=d[l-1]?d[l-1]._high+1:0;
>         for(g=j._high=d[l+1]?kb((j.plotX+(d[l+1]?d[l+1].plotX:e))/2):e;f<=g;)h[c?e-f++:f++]=j
>             });
>     this.tooltipPoints=h
>     },
> onMouseOver:function(){
>     var a=this.chart,b=a.hoverSeries;
>     if(!(!Nb&&a.mouseIsDown)){
>         b&&b!==this&&b.onMouseOut();
>         this.options.events.mouseOver&&Pa(this,"mouseOver");
>         this.tracker&&this.tracker.toFront();
>         this.setState(Ab);
>         a.hoverSeries=this
>         }
>     },
> onMouseOut:function(){
>     var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;
>     d&&d.onMouseOut();
>     this&&a.events.mouseOut&&Pa(this,"mouseOut");
>     c&&!a.stickyTracking&&c.hide();
>     this.setState();
>     b.hoverSeries=null
>     },
> animate:function(a){
>     var b=this.chart,c=this.clipRect,d=this.options.animation;
>     if(d&&!Kb(d))d={};
> 
>     if(a){
>         if(!c.isAnimating){
>             c.attr("width",0);
>             c.isAnimating=true
>             }
>         }else{
>     c.animate({
>         width:b.plotSizeX
>         },d);
>     this.animate=null
>     }
> },
> drawPoints:function(){
>     var a,b=this.data,c=this.chart,
>     d,e,f,g,h,j;
>     if(this.options.marker.enabled)for(f=b.length;f--;){
>         g=b[f];
>         d=g.plotX;
>         e=g.plotY;
>         j=g.graphic;
>         if(e!==Ua&&!isNaN(e)){
>             a=g.pointAttr[g.selected?"select":hb];
>             h=a.r;
>             if(j)j.animate({
>                 x:d,
>                 y:e,
>                 r:h
>             });else g.graphic=c.renderer.symbol(B(g.marker&&g.marker.symbol,this.symbol),d,e,h).attr(a).add(this.group)
>                 }
>             }
>     },
> convertAttribs:function(a,b,c,d){
>     var e=this.pointAttrToOptions,f,g,h={};
> 
>     a=a||{};
> 
>     b=b||{};
> 
>     c=c||{};
> 
>     d=d||{};
> 
>     for(f in e){
>         g=e[f];
>         h[f]=B(a[g],b[f],c[f],d[f])
>         }
>         return h
>     },
> getAttribs:function(){
>     var a=this,
>     b=xb[a.type].marker?a.options.marker:a.options,c=b.states,d=c[Ab],e,f=a.color,g={
>         stroke:f,
>         fill:f
>     },h=a.data,j=[],l,n=a.pointAttrToOptions,C;
>     if(a.options.marker){
>         d.radius=d.radius||b.radius+2;
>         d.lineWidth=d.lineWidth||b.lineWidth+1
>         }else d.color=d.color||$b(d.color||f).brighten(d.brightness).get();
>     j[hb]=a.convertAttribs(b,g);
>     t([Ab,"select"],function(G){
>         j[G]=a.convertAttribs(c[G],j[hb])
>         });
>     a.pointAttr=j;
>     for(f=h.length;f--;){
>         g=h[f];
>         if((b=g.options&&g.options.marker||g.options)&&b.enabled===false)b.radius=
>             0;
>         e=false;
>         if(g.options)for(C in n)if(J(b[n[C]]))e=true;if(e){
>             l=[];
>             c=b.states||{};
> 
>             e=c[Ab]=c[Ab]||{};
> 
>             if(!a.options.marker)e.color=$b(e.color||g.options.color).brighten(e.brightness||d.brightness).get();
>             l[hb]=a.convertAttribs(b,j[hb]);
>             l[Ab]=a.convertAttribs(c[Ab],j[Ab],l[hb]);
>             l.select=a.convertAttribs(c.select,j.select,l[hb])
>             }else l=j;
>         g.pointAttr=l
>         }
>     },
> destroy:function(){
>     var a=this,b=a.chart,c=/\/5[0-9\.]+ (Safari|Mobile)\//.test(qc),d,e;
>     Gb(a);
>     a.legendItem&&a.chart.legend.destroyItem(a);
>     t(a.data,function(f){
>         f.destroy()
>         });
>     t(["area","graph","dataLabelsGroup","group","tracker"],function(f){
>         if(a[f]){
>             d=c&&f==="group"?"hide":"destroy";
>             a[f][d]()
3942,3953c3917,3935
<         },
<         destroy:function(){
<             var a=this,b=a.chart,c=/\/5[0-9\.]+ (Safari|Mobile)\//.test(qc),d,e;
<             Gb(a);
<             a.legendItem&&a.chart.legend.destroyItem(a);
<             t(a.data,function(f){
<                 f.destroy()
<             });
<             t(["area","graph","dataLabelsGroup","group","tracker"],function(f){
<                 if(a[f]){
<                     d=c&&f==="group"?"hide":"destroy";
<                     a[f][d]()
---
>         });
> if(b.hoverSeries===a)b.hoverSeries=null;
> rc(b.series,a);
> for(e in a)delete a[e]
> },
> drawDataLabels:function(){
>     if(this.options.dataLabels.enabled){
>         var a=this,b,c,d=a.data,e=a.options.dataLabels,f,g=a.dataLabelsGroup,h=a.chart,j=h.inverted,l=a.type,n;
>         n=a.options.stacking;
>         var C=l==="column"||l==="bar",G=e.verticalAlign===null,fa=e.y===null;
>         if(C)if(n){
>             if(G)e=sa(e,{
>                 verticalAlign:"middle"
>             });
>             if(fa)e=sa(e,{
>                 y:{
>                     top:14,
>                     middle:4,
>                     bottom:-6
3954a3937,3942
>                 [e.verticalAlign]
>                 })
>             }
>             else{
>             if(G)e=sa(e,{
>                 verticalAlign:"top"
3956,3975c3944,3981
<             if(b.hoverSeries===a)b.hoverSeries=null;
<             rc(b.series,a);
<             for(e in a)delete a[e]
<         },
<         drawDataLabels:function(){
<             if(this.options.dataLabels.enabled){
<                 var a=this,b,c,d=a.data,e=a.options.dataLabels,f,g=a.dataLabelsGroup,h=a.chart,j=h.inverted,l=a.type,n;
<                 n=a.options.stacking;
<                 var C=l==="column"||l==="bar",G=e.verticalAlign===null,fa=e.y===null;
<                 if(C)if(n){
<                     if(G)e=sa(e,{
<                         verticalAlign:"middle"
<                     });
<                     if(fa)e=sa(e,{
<                         y:{
<                             top:14,
<                             middle:4,
<                             bottom:-6
<                         }
<                         [e.verticalAlign]
---
>             if(fa)e=sa(e,{
>                 y:-6
>             })
>             }
>             if(!g)g=a.dataLabelsGroup=h.renderer.g("data-labels").attr({
>             visibility:a.visible?ub:gb,
>             zIndex:6
>         }).translate(h.plotLeft,h.plotTop).add();
>         n=e.color;
>         if(n==="auto")n=null;
>         e.style.color=B(n,a.color);
>         t(d,function(K){
>             var ia=K.barX,u=ia&&ia+K.barW/2||K.plotX||-999,P=B(K.plotY,-999),O=K.dataLabel,Q=e.align;
>             f=e.formatter.call(K.getLabelConfig());
>             b=(j?h.plotWidth-P:u)+e.x;
>             c=(j?h.plotHeight-
>                 u:P)+e.y;
>             if(l==="column")b+={
>                 left:-1,
>                 right:1
>             }
>             [Q]*K.barW/2||0;
>             if(O){
>                 if(j&&!e.y)c=c+la(O.styles.lineHeight)*0.9-O.getBBox().height/2;
>                 O.attr({
>                     text:f
>                 }).animate({
>                     x:b,
>                     y:c
>                 })
>                 }else if(J(f)){
>                 O=K.dataLabel=h.renderer.text(f,b,c).attr({
>                     align:Q,
>                     rotation:e.rotation,
>                     zIndex:1
>                 }).css(e.style).add(g);
>                 j&&!e.y&&O.attr({
>                     y:c+la(O.styles.lineHeight)*0.9-O.getBBox().height/2
3978,3983c3984,3992
<                 else{
<                     if(G)e=sa(e,{
<                         verticalAlign:"top"
<                     });
<                     if(fa)e=sa(e,{
<                         y:-6
---
>                 if(C&&a.options.stacking){
>                 u=K.barY;
>                 P=K.barW;
>                 K=K.barH;
>                 O.align(e,null,{
>                     x:j?h.plotWidth-u-K:ia,
>                     y:j?h.plotHeight-ia-P:u,
>                     width:j?K:P,
>                     height:j?P:K
3986,4055c3995,4007
<                 if(!g)g=a.dataLabelsGroup=h.renderer.g("data-labels").attr({
<                     visibility:a.visible?ub:gb,
<                     zIndex:6
<                 }).translate(h.plotLeft,h.plotTop).add();
<                 n=e.color;
<                 if(n==="auto")n=null;
<                 e.style.color=B(n,a.color);
<                 t(d,function(K){
<                     var ia=K.barX,u=ia&&ia+K.barW/2||K.plotX||-999,P=B(K.plotY,-999),O=K.dataLabel,Q=e.align;
<                     f=e.formatter.call(K.getLabelConfig());
<                     b=(j?h.plotWidth-P:u)+e.x;
<                     c=(j?h.plotHeight-
<                         u:P)+e.y;
<                     if(l==="column")b+={
<                         left:-1,
<                         right:1
<                     }
<                     [Q]*K.barW/2||0;
<                     if(O){
<                         if(j&&!e.y)c=c+la(O.styles.lineHeight)*0.9-O.getBBox().height/2;
<                         O.attr({
<                             text:f
<                         }).animate({
<                             x:b,
<                             y:c
<                         })
<                     }else if(J(f)){
<                         O=K.dataLabel=h.renderer.text(f,b,c).attr({
<                             align:Q,
<                             rotation:e.rotation,
<                             zIndex:1
<                         }).css(e.style).add(g);
<                         j&&!e.y&&O.attr({
<                             y:c+la(O.styles.lineHeight)*0.9-O.getBBox().height/2
<                         })
<                     }
<                     if(C&&a.options.stacking){
<                         u=K.barY;
<                         P=K.barW;
<                         K=K.barH;
<                         O.align(e,null,{
<                             x:j?h.plotWidth-u-K:ia,
<                             y:j?h.plotHeight-ia-P:u,
<                             width:j?K:P,
<                             height:j?P:K
<                         })
<                     }
<                 })
<             }
<         },
<         drawGraph:function(){
<             var a=this,b=a.options,c=a.graph,d=[],e,f=a.area,g=a.group,h=b.lineColor||a.color,j=b.lineWidth,l=b.dashStyle,n,C=a.chart.renderer,G=a.yAxis.getThreshold(b.threshold||0),fa=/^area/.test(a.type),K=[],ia=[];
<             t(a.segments,function(u){
<                 n=[];
<                 t(u,function(H,S){
<                     if(a.getPointSpline)n.push.apply(n,a.getPointSpline(u,H,S));
<                     else{
<                         n.push(S?Ja:Za);
<                         S&&b.step&&n.push(H.plotX,u[S-1].plotY);
<                         n.push(H.plotX,H.plotY)
<                     }
<                 });
<                 if(u.length>1)d=d.concat(n);else K.push(u[0]);
<                 if(fa){
<                     var P=[],O,Q=n.length;
<                     for(O=
<                         0;O<Q;O++)P.push(n[O]);
<                     Q===3&&P.push(Ja,n[1],n[2]);
<                     if(b.stacking&&a.type!=="areaspline")for(O=u.length-1;O>=0;O--)P.push(u[O].plotX,u[O].yBottom);else P.push(Ja,u[u.length-1].plotX,G,Ja,u[0].plotX,G);
<                     ia=ia.concat(P)
---
>             })
>     }
> },
> drawGraph:function(){
>     var a=this,b=a.options,c=a.graph,d=[],e,f=a.area,g=a.group,h=b.lineColor||a.color,j=b.lineWidth,l=b.dashStyle,n,C=a.chart.renderer,G=a.yAxis.getThreshold(b.threshold||0),fa=/^area/.test(a.type),K=[],ia=[];
>     t(a.segments,function(u){
>         n=[];
>         t(u,function(H,S){
>             if(a.getPointSpline)n.push.apply(n,a.getPointSpline(u,H,S));
>             else{
>                 n.push(S?Ja:Za);
>                 S&&b.step&&n.push(H.plotX,u[S-1].plotY);
>                 n.push(H.plotX,H.plotY)
4058,4075c4010,4031
<             a.graphPath=d;
<             a.singlePoints=K;
<             if(fa){
<                 e=B(b.fillColor,$b(a.color).setOpacity(b.fillOpacity||0.75).get());
<                 if(f)f.animate({
<                     d:ia
<                 });else a.area=a.chart.renderer.path(ia).attr({
<                     fill:e
<                 }).add(g)
<             }
<             if(c)c.animate({
<                 d:d
<             });
<             else if(j){
<                 c={
<                     stroke:h,
<                     "stroke-width":j
<                 };
---
>     if(u.length>1)d=d.concat(n);else K.push(u[0]);
>         if(fa){
>         var P=[],O,Q=n.length;
>         for(O=
>             0;O<Q;O++)P.push(n[O]);
>         Q===3&&P.push(Ja,n[1],n[2]);
>         if(b.stacking&&a.type!=="areaspline")for(O=u.length-1;O>=0;O--)P.push(u[O].plotX,u[O].yBottom);else P.push(Ja,u[u.length-1].plotX,G,Ja,u[0].plotX,G);ia=ia.concat(P)
>         }
>     });a.graphPath=d;a.singlePoints=K;if(fa){
>     e=B(b.fillColor,$b(a.color).setOpacity(b.fillOpacity||0.75).get());if(f)f.animate({
>         d:ia
>         });else a.area=a.chart.renderer.path(ia).attr({
>     fill:e
>     }).add(g)
>     }
>     if(c)c.animate({
>         d:d
>         });else if(j){
>     c={
>         stroke:h,
>         "stroke-width":j
>     };
4077,4088c4033,4044
<                 if(l)c.dashstyle=l;
<                 a.graph=C.path(d).attr(c).add(g).shadow(b.shadow)
<             }
<         },
<         render:function(){
<             var a=this,b=a.chart,c,d,e=a.options,f=e.animation,g=f&&a.animate;
<             f=g?f&&f.duration||500:0;
<             var h=a.clipRect;
<             d=b.renderer;
<             if(!h){
<                 h=a.clipRect=!b.hasRendered&&b.clipRect?b.clipRect:d.clipRect(0,0,b.plotSizeX,b.plotSizeY);
<                 if(!b.clipRect)b.clipRect=h
---
>     if(l)c.dashstyle=l;
>     a.graph=C.path(d).attr(c).add(g).shadow(b.shadow)
>     }
> },
> render:function(){
>     var a=this,b=a.chart,c,d,e=a.options,f=e.animation,g=f&&a.animate;
>     f=g?f&&f.duration||500:0;
>     var h=a.clipRect;
>     d=b.renderer;
>     if(!h){
>         h=a.clipRect=!b.hasRendered&&b.clipRect?b.clipRect:d.clipRect(0,0,b.plotSizeX,b.plotSizeY);
>         if(!b.clipRect)b.clipRect=h
4091,4254c4047,4057
<                 c=a.group=d.g("series");
<                 if(b.inverted){
<                     d=function(){
<                         c.attr({
<                             width:b.plotWidth,
<                             height:b.plotHeight
<                         }).invert()
<                     };
< 
<                     d();
<                     Sa(b,"resize",d)
<                 }
<                 c.clip(a.clipRect).attr({
<                     visibility:a.visible?ub:gb,
<                     zIndex:e.zIndex
<                 }).translate(b.plotLeft,b.plotTop).add(b.seriesGroup)
<             }
<             a.drawDataLabels();
<             g&&a.animate(true);
<             a.drawGraph&&a.drawGraph();
<             a.drawPoints();
<             a.options.enableMouseTracking!==false&&a.drawTracker();
<             g&&a.animate();
<             setTimeout(function(){
<                 h.isAnimating=false;
<                 if((c=a.group)&&h!==b.clipRect&&h.renderer){
<                     c.clip(a.clipRect=b.clipRect);
<                     h.destroy()
<                 }
<             },f);
<             a.isDirty=false
<         },
<         redraw:function(){
<             var a=this.chart,b=this.group;
<             if(b){
<                 a.inverted&&b.attr({
<                     width:a.plotWidth,
<                     height:a.plotHeight
<                 });
<                 b.animate({
<                     translateX:a.plotLeft,
<                     translateY:a.plotTop
<                 })
<             }
<             this.translate();
<             this.setTooltipPoints(true);
<             this.render()
<         },
<         setState:function(a){
<             var b=this.options,c=this.graph,d=b.states;
<             b=b.lineWidth;
<             a=a||hb;
<             if(this.state!==a){
<                 this.state=a;
<                 if(!(d[a]&&d[a].enabled===false)){
<                     if(a)b=d[a].lineWidth||b+1;
<                     if(c&&!c.dashstyle)c.attr({
<                         "stroke-width":b
<                     },a?0:500)
<                 }
<             }
<         },
<         setVisible:function(a,b){
<             var c=this.chart,d=this.legendItem,e=this.group,f=this.tracker,g=this.dataLabelsGroup,h,j=this.data,l=c.options.chart.ignoreHiddenSeries;
<             h=this.visible;
<             h=(this.visible=a=a===Ua?!h:a)?"show":"hide";
<             e&&e[h]();
<             if(f)f[h]();else for(e=j.length;e--;){
<                 f=
<                 j[e];
<                 f.tracker&&f.tracker[h]()
<             }
<             g&&g[h]();
<             d&&c.legend.colorizeItem(this,a);
<             this.isDirty=true;
<             this.options.stacking&&t(c.series,function(n){
<                 if(n.options.stacking&&n.visible)n.isDirty=true
<             });
<             if(l)c.isDirtyBox=true;
<             b!==false&&c.redraw();
<             Pa(this,h)
<         },
<         show:function(){
<             this.setVisible(true)
<         },
<         hide:function(){
<             this.setVisible(false)
<         },
<         select:function(a){
<             this.selected=a=a===Ua?!this.selected:a;
<             if(this.checkbox)this.checkbox.checked=a;
<             Pa(this,a?"select":"unselect")
<         },
<         drawTracker:function(){
<             var a=this,b=a.options,
<             c=[].concat(a.graphPath),d=c.length,e=a.chart,f=e.options.tooltip.snap,g=a.tracker,h=b.cursor;
<             h=h&&{
<                 cursor:h
<             };
<             var j=a.singlePoints,l;
<             if(d)for(l=d+1;l--;){
<                 c[l]===Za&&c.splice(l+1,0,c[l+1]-f,c[l+2],Ja);
<                 if(l&&c[l]===Za||l===d)c.splice(l,0,Ja,c[l-2]+f,c[l-1])
<             }
<             for(l=0;l<j.length;l++){
<                 d=j[l];
<                 c.push(Za,d.plotX-f,d.plotY,Ja,d.plotX+f,d.plotY)
<             }
<             if(g)g.attr({
<                 d:c
<             });else a.tracker=e.renderer.path(c).attr({
<                 isTracker:true,
<                 stroke:Xd,
<                 fill:jb,
<                 "stroke-width":b.lineWidth+2*f,
<                 visibility:a.visible?ub:gb,
<                 zIndex:1
<             }).on(Nb?
<                 "touchstart":"mouseover",function(){
<                     e.hoverSeries!==a&&a.onMouseOver()
<                 }).on("mouseout",function(){
<                 b.stickyTracking||a.onMouseOut()
<             }).css(h).add(e.trackerGroup)
<         }
<     };
<     ka=yb(pb);
<     vb.line=ka;
<     ka=yb(pb,{
<         type:"area"
<     });
<     vb.area=ka;
<     ka=yb(pb,{
<         type:"spline",
<         getPointSpline:function(a,b,c){
<             var d=b.plotX,e=b.plotY,f=a[c-1],g=a[c+1],h,j,l,n;
<             if(c&&c<a.length-1){
<                 a=f.plotY;
<                 l=g.plotX;
<                 g=g.plotY;
<                 var C;
<                 h=(1.5*d+f.plotX)/2.5;
<                 j=(1.5*e+a)/2.5;
<                 l=(1.5*d+l)/2.5;
<                 n=(1.5*e+g)/2.5;
<                 C=(n-j)*(l-d)/(l-h)+e-n;
<                 j+=C;
<                 n+=C;
<                 if(j>a&&j>e){
<                     j=Fa(a,
<                         e);
<                     n=2*e-j
<                 }else if(j<a&&j<e){
<                     j=qb(a,e);
<                     n=2*e-j
<                 }
<                 if(n>g&&n>e){
<                     n=Fa(g,e);
<                     j=2*e-n
<                 }else if(n<g&&n<e){
<                     n=qb(g,e);
<                     j=2*e-n
<                 }
<                 b.rightContX=l;
<                 b.rightContY=n
---
>         c=a.group=d.g("series");
>         if(b.inverted){
>             d=function(){
>                 c.attr({
>                     width:b.plotWidth,
>                     height:b.plotHeight
>                     }).invert()
>                 };
> 
>             d();
>             Sa(b,"resize",d)
4256,4260c4059,4062
<             if(c){
<                 b=["C",f.rightContX||f.plotX,f.rightContY||f.plotY,h||d,j||e,d,e];
<                 f.rightContX=f.rightContY=null
<             }else b=[Za,d,e];
<             return b
---
>             c.clip(a.clipRect).attr({
>             visibility:a.visible?ub:gb,
>             zIndex:e.zIndex
>             }).translate(b.plotLeft,b.plotTop).add(b.seriesGroup)
4262,4282c4064,4088
<     });
<     vb.spline=ka;
<     ka=yb(ka,{
<         type:"areaspline"
<     });
<     vb.areaspline=ka;
<     var cd=yb(pb,{
<         type:"column",
<         pointAttrToOptions:{
<             stroke:"borderColor",
<             "stroke-width":"borderWidth",
<             fill:"color",
<             r:"borderRadius"
<         },
<         init:function(){
<             pb.prototype.init.apply(this,
<                 arguments);
<             var a=this,b=a.chart;
<             b.hasColumn=true;
<             b.hasRendered&&t(b.series,function(c){
<                 if(c.type===a.type)c.isDirty=true
---
>         a.drawDataLabels();
>     g&&a.animate(true);
>     a.drawGraph&&a.drawGraph();
>     a.drawPoints();
>     a.options.enableMouseTracking!==false&&a.drawTracker();
>     g&&a.animate();
>     setTimeout(function(){
>         h.isAnimating=false;
>         if((c=a.group)&&h!==b.clipRect&&h.renderer){
>             c.clip(a.clipRect=b.clipRect);
>             h.destroy()
>             }
>         },f);
> a.isDirty=false
> },
> redraw:function(){
>     var a=this.chart,b=this.group;
>     if(b){
>         a.inverted&&b.attr({
>             width:a.plotWidth,
>             height:a.plotHeight
>             });
>         b.animate({
>             translateX:a.plotLeft,
>             translateY:a.plotTop
4283a4090,4209
>         }
>         this.translate();
>     this.setTooltipPoints(true);
>     this.render()
>     },
> setState:function(a){
>     var b=this.options,c=this.graph,d=b.states;
>     b=b.lineWidth;
>     a=a||hb;
>     if(this.state!==a){
>         this.state=a;
>         if(!(d[a]&&d[a].enabled===false)){
>             if(a)b=d[a].lineWidth||b+1;
>             if(c&&!c.dashstyle)c.attr({
>                 "stroke-width":b
>             },a?0:500)
>             }
>             }
> },
> setVisible:function(a,b){
>     var c=this.chart,d=this.legendItem,e=this.group,f=this.tracker,g=this.dataLabelsGroup,h,j=this.data,l=c.options.chart.ignoreHiddenSeries;
>     h=this.visible;
>     h=(this.visible=a=a===Ua?!h:a)?"show":"hide";
>     e&&e[h]();
>     if(f)f[h]();else for(e=j.length;e--;){
>     f=
>     j[e];f.tracker&&f.tracker[h]()
>     }
>     g&&g[h]();d&&c.legend.colorizeItem(this,a);this.isDirty=true;this.options.stacking&&t(c.series,function(n){
>         if(n.options.stacking&&n.visible)n.isDirty=true
>         });if(l)c.isDirtyBox=true;b!==false&&c.redraw();Pa(this,h)
>     },
> show:function(){
>     this.setVisible(true)
>     },
> hide:function(){
>     this.setVisible(false)
>     },
> select:function(a){
>     this.selected=a=a===Ua?!this.selected:a;if(this.checkbox)this.checkbox.checked=a;Pa(this,a?"select":"unselect")
>     },
> drawTracker:function(){
>     var a=this,b=a.options,
>     c=[].concat(a.graphPath),d=c.length,e=a.chart,f=e.options.tooltip.snap,g=a.tracker,h=b.cursor;h=h&&{
>     cursor:h
>     };
>     var j=a.singlePoints,l;if(d)for(l=d+1;l--;){
>     c[l]===Za&&c.splice(l+1,0,c[l+1]-f,c[l+2],Ja);if(l&&c[l]===Za||l===d)c.splice(l,0,Ja,c[l-2]+f,c[l-1])
>     }
>     for(l=0;l<j.length;l++){
>     d=j[l];c.push(Za,d.plotX-f,d.plotY,Ja,d.plotX+f,d.plotY)
>     }
>     if(g)g.attr({
>         d:c
>         });else a.tracker=e.renderer.path(c).attr({
>     isTracker:true,
>         stroke:Xd,
>         fill:jb,
>         "stroke-width":b.lineWidth+2*f,
>         visibility:a.visible?ub:gb,
>         zIndex:1
>     }).on(Nb?
>     "touchstart":"mouseover",function(){
>     e.hoverSeries!==a&&a.onMouseOver()
>     }).on("mouseout",function(){
>     b.stickyTracking||a.onMouseOut()
>     }).css(h).add(e.trackerGroup)
>     }
> };
> ka=yb(pb);vb.line=ka;ka=yb(pb,{
>     type:"area"
>     });vb.area=ka;ka=yb(pb,{
>     type:"spline",
>     getPointSpline:function(a,b,c){
>     var d=b.plotX,e=b.plotY,f=a[c-1],g=a[c+1],h,j,l,n;if(c&&c<a.length-1){
>     a=f.plotY;l=g.plotX;g=g.plotY;var C;h=(1.5*d+f.plotX)/2.5;j=(1.5*e+a)/2.5;l=(1.5*d+l)/2.5;n=(1.5*e+g)/2.5;C=(n-j)*(l-d)/(l-h)+e-n;j+=C;n+=C;if(j>a&&j>e){
>     j=Fa(a,
>         e);n=2*e-j
>     }else if(j<a&&j<e){
>     j=qb(a,e);
>     n=2*e-j
>     }
>     if(n>g&&n>e){
>     n=Fa(g,e);
>     j=2*e-n
>     }else if(n<g&&n<e){
>     n=qb(g,e);
>     j=2*e-n
>     }
>     b.rightContX=l;
> b.rightContY=n
> }
> if(c){
>     b=["C",f.rightContX||f.plotX,f.rightContY||f.plotY,h||d,j||e,d,e];
>     f.rightContX=f.rightContY=null
>     }else b=[Za,d,e];
>     return b
>     }
> });
> vb.spline=ka;
> ka=yb(ka,{
>     type:"areaspline"
> });
> vb.areaspline=ka;
> var cd=yb(pb,{
>     type:"column",
>     pointAttrToOptions:{
>         stroke:"borderColor",
>         "stroke-width":"borderWidth",
>         fill:"color",
>         r:"borderRadius"
>     },
>     init:function(){
>         pb.prototype.init.apply(this,
>             arguments);
>         var a=this,b=a.chart;
>         b.hasColumn=true;
>         b.hasRendered&&t(b.series,function(c){
>             if(c.type===a.type)c.isDirty=true
>                 })
4285,4293c4211,4219
<         translate:function(){
<             var a=this,b=a.chart,c=a.options,d=c.stacking,e=c.borderWidth,f=0,g=a.xAxis.reversed,h=a.xAxis.categories,j={},l,n;
<             pb.prototype.translate.apply(a);
<             t(b.series,function(H){
<                 if(H.type===a.type&&H.visible){
<                     if(H.options.stacking){
<                         l=H.stackKey;
<                         if(j[l]===Ua)j[l]=f++;
<                         n=j[l]
---
>     translate:function(){
>         var a=this,b=a.chart,c=a.options,d=c.stacking,e=c.borderWidth,f=0,g=a.xAxis.reversed,h=a.xAxis.categories,j={},l,n;
>         pb.prototype.translate.apply(a);
>         t(b.series,function(H){
>             if(H.type===a.type&&H.visible){
>                 if(H.options.stacking){
>                     l=H.stackKey;
>                     if(j[l]===Ua)j[l]=f++;
>                     n=j[l]
4295c4221
<                     H.columnIndex=n
---
>                 H.columnIndex=n
4298,4312c4224,4274
<             var C=a.data,G=a.closestPoints;
<             h=db(C[1]?C[G].plotX-C[G-1].plotX:
<                 b.plotSizeX/(h&&h.length||1));
<             G=h*c.groupPadding;
<             var fa=(h-2*G)/f,K=c.pointWidth,ia=J(K)?(fa-K)/2:fa*c.pointPadding,u=Fa(B(K,fa-2*ia),1),P=ia+(G+((g?f-a.columnIndex:a.columnIndex)||0)*fa-h/2)*(g?-1:1),O=a.yAxis.getThreshold(c.threshold||0),Q=B(c.minPointLength,5);
<             t(C,function(H){
<                 var S=H.plotY,Ta=H.yBottom||O,cb=H.plotX+P,Ib=hd(qb(S,Ta)),Jb=hd(Fa(S,Ta)-Ib),Ob=a.yAxis.stacks[(H.y<0?"-":"")+a.stackKey],Hb;
<                 d&&a.visible&&Ob&&Ob[H.x]&&Ob[H.x].setOffset(P,u);
<                 if(db(Jb)<Q){
<                     if(Q){
<                         Jb=Q;
<                         Ib=db(Ib-O)>Q?Ta-Q:O-
<                         (S<=O?Q:0)
<                     }
<                     Hb=Ib-3
---
>     var C=a.data,G=a.closestPoints;
>     h=db(C[1]?C[G].plotX-C[G-1].plotX:
>         b.plotSizeX/(h&&h.length||1));
>     G=h*c.groupPadding;
>     var fa=(h-2*G)/f,K=c.pointWidth,ia=J(K)?(fa-K)/2:fa*c.pointPadding,u=Fa(B(K,fa-2*ia),1),P=ia+(G+((g?f-a.columnIndex:a.columnIndex)||0)*fa-h/2)*(g?-1:1),O=a.yAxis.getThreshold(c.threshold||0),Q=B(c.minPointLength,5);
>     t(C,function(H){
>         var S=H.plotY,Ta=H.yBottom||O,cb=H.plotX+P,Ib=hd(qb(S,Ta)),Jb=hd(Fa(S,Ta)-Ib),Ob=a.yAxis.stacks[(H.y<0?"-":"")+a.stackKey],Hb;
>         d&&a.visible&&Ob&&Ob[H.x]&&Ob[H.x].setOffset(P,u);
>         if(db(Jb)<Q){
>             if(Q){
>                 Jb=Q;
>                 Ib=db(Ib-O)>Q?Ta-Q:O-
>                 (S<=O?Q:0)
>                 }
>                 Hb=Ib-3
>             }
>             pa(H,{
>             barX:cb,
>             barY:Ib,
>             barW:u,
>             barH:Jb
>         });
>         H.shapeType="rect";
>         S=pa(b.renderer.Element.prototype.crisp.apply({},[e,cb,Ib,u,Jb]),{
>             r:c.borderRadius
>             });
>         if(e%2){
>             S.y-=1;
>             S.height+=1
>             }
>             H.shapeArgs=S;
>         H.trackerArgs=J(Hb)&&sa(H.shapeArgs,{
>             height:Fa(6,Jb+3),
>             y:Hb
>         })
>         })
>     },
> getSymbol:function(){},
>     drawGraph:function(){},
>     drawPoints:function(){
>     var a=this,b=a.options,c=a.chart.renderer,d,e;
>     t(a.data,function(f){
>         var g=f.plotY;
>         if(g!==Ua&&!isNaN(g)&&f.y!==null){
>             d=f.graphic;
>             e=f.shapeArgs;
>             if(d){
>                 Uc(d);
>                 d.animate(e)
>                 }else f.graphic=
>                 c[f.shapeType](e).attr(f.pointAttr[f.selected?"select":hb]).add(a.group).shadow(b.shadow)
4314,4332d4275
<                 pa(H,{
<                     barX:cb,
<                     barY:Ib,
<                     barW:u,
<                     barH:Jb
<                 });
<                 H.shapeType="rect";
<                 S=pa(b.renderer.Element.prototype.crisp.apply({},[e,cb,Ib,u,Jb]),{
<                     r:c.borderRadius
<                 });
<                 if(e%2){
<                     S.y-=1;
<                     S.height+=1
<                 }
<                 H.shapeArgs=S;
<                 H.trackerArgs=J(Hb)&&sa(H.shapeArgs,{
<                     height:Fa(6,Jb+3),
<                     y:Hb
<                 })
4334,4348c4277,4299
<         },
<         getSymbol:function(){},
<         drawGraph:function(){},
<         drawPoints:function(){
<             var a=this,b=a.options,c=a.chart.renderer,d,e;
<             t(a.data,function(f){
<                 var g=f.plotY;
<                 if(g!==Ua&&!isNaN(g)&&f.y!==null){
<                     d=f.graphic;
<                     e=f.shapeArgs;
<                     if(d){
<                         Uc(d);
<                         d.animate(e)
<                     }else f.graphic=
<                         c[f.shapeType](e).attr(f.pointAttr[f.selected?"select":hb]).add(a.group).shadow(b.shadow)
---
> },
> drawTracker:function(){
>     var a=this,b=a.chart,c=b.renderer,d,e,f=+new Date,g=a.options.cursor,h=g&&{
>         cursor:g
>     },j;
>     t(a.data,function(l){
>         e=l.tracker;
>         d=l.trackerArgs||l.shapeArgs;
>         delete d.strokeWidth;
>         if(l.y!==null)if(e)e.attr(d);else l.tracker=c[l.shapeType](d).attr({
>             isTracker:f,
>             fill:Xd,
>             visibility:a.visible?ub:gb,
>             zIndex:1
>         }).on(Nb?"touchstart":"mouseover",function(n){
>             j=n.relatedTarget||n.fromElement;
>             b.hoverSeries!==
>             a&&Ca(j,"isTracker")!==f&&a.onMouseOver();
>             l.onMouseOver()
>             }).on("mouseout",function(n){
>             if(!a.options.stickyTracking){
>                 j=n.relatedTarget||n.toElement;
>                 Ca(j,"isTracker")!==f&&a.onMouseOut()
4349a4301
>             }).css(h).add(l.group||b.trackerGroup)
4351,4402c4303,4319
<         },
<         drawTracker:function(){
<             var a=this,b=a.chart,c=b.renderer,d,e,f=+new Date,g=a.options.cursor,h=g&&{
<                 cursor:g
<             },j;
<             t(a.data,function(l){
<                 e=l.tracker;
<                 d=l.trackerArgs||l.shapeArgs;
<                 delete d.strokeWidth;
<                 if(l.y!==null)if(e)e.attr(d);else l.tracker=c[l.shapeType](d).attr({
<                     isTracker:f,
<                     fill:Xd,
<                     visibility:a.visible?ub:gb,
<                     zIndex:1
<                 }).on(Nb?"touchstart":"mouseover",function(n){
<                     j=n.relatedTarget||n.fromElement;
<                     b.hoverSeries!==
<                     a&&Ca(j,"isTracker")!==f&&a.onMouseOver();
<                     l.onMouseOver()
<                 }).on("mouseout",function(n){
<                     if(!a.options.stickyTracking){
<                         j=n.relatedTarget||n.toElement;
<                         Ca(j,"isTracker")!==f&&a.onMouseOut()
<                     }
<                 }).css(h).add(l.group||b.trackerGroup)
<             })
<         },
<         animate:function(a){
<             var b=this,c=b.data;
<             if(!a){
<                 t(c,function(d){
<                     var e=d.graphic;
<                     d=d.shapeArgs;
<                     if(e){
<                         e.attr({
<                             height:0,
<                             y:b.yAxis.translate(0,0,1)
<                         });
<                         e.animate({
<                             height:d.height,
<                             y:d.y
<                         },b.options.animation)
<                     }
<                 });
<                 b.animate=null
<             }
<         },
<         remove:function(){
<             var a=this,b=a.chart;
<             b.hasRendered&&
<             t(b.series,function(c){
<                 if(c.type===a.type)c.isDirty=true
---
> },
> animate:function(a){
>     var b=this,c=b.data;
>     if(!a){
>         t(c,function(d){
>             var e=d.graphic;
>             d=d.shapeArgs;
>             if(e){
>                 e.attr({
>                     height:0,
>                     y:b.yAxis.translate(0,0,1)
>                     });
>                 e.animate({
>                     height:d.height,
>                     y:d.y
>                     },b.options.animation)
>                 }
4404,4412c4321,4338
<             pb.prototype.remove.apply(a,arguments)
<         }
<     });
<     vb.column=cd;
<     ka=yb(cd,{
<         type:"bar",
<         init:function(a){
<             a.inverted=this.inverted=true;
<             cd.prototype.init.apply(this,arguments)
---
>     b.animate=null
>     }
> },
> remove:function(){
>     var a=this,b=a.chart;
>     b.hasRendered&&
>     t(b.series,function(c){
>         if(c.type===a.type)c.isDirty=true
>             });
>     pb.prototype.remove.apply(a,arguments)
>     }
> });
> vb.column=cd;
> ka=yb(cd,{
>     type:"bar",
>     init:function(a){
>         a.inverted=this.inverted=true;
>         cd.prototype.init.apply(this,arguments)
4415,4426c4341,4352
<     vb.bar=ka;
<     ka=yb(pb,{
<         type:"scatter",
<         translate:function(){
<             var a=this;
<             pb.prototype.translate.apply(a);
<             t(a.data,function(b){
<                 b.shapeType="circle";
<                 b.shapeArgs={
<                     x:b.plotX,
<                     y:b.plotY,
<                     r:a.chart.options.tooltip.snap
---
> vb.bar=ka;
> ka=yb(pb,{
>     type:"scatter",
>     translate:function(){
>         var a=this;
>         pb.prototype.translate.apply(a);
>         t(a.data,function(b){
>             b.shapeType="circle";
>             b.shapeArgs={
>                 x:b.plotX,
>                 y:b.plotY,
>                 r:a.chart.options.tooltip.snap
4429,4455c4355,4381
<         },
<         drawTracker:function(){
<             var a=this,b=a.options.cursor,c=b&&{
<                 cursor:b
<             },
<             d;
<             t(a.data,function(e){
<                 (d=e.graphic)&&d.attr({
<                     isTracker:true
<                 }).on("mouseover",function(){
<                     a.onMouseOver();
<                     e.onMouseOver()
<                 }).on("mouseout",function(){
<                     a.options.stickyTracking||a.onMouseOut()
<                 }).css(c)
<             })
<         },
<         cleanData:function(){}
<     });
<     vb.scatter=ka;
<     ka=yb(Bc,{
<         init:function(){
<             Bc.prototype.init.apply(this,arguments);
<             var a=this,b;
<             pa(a,{
<                 visible:a.visible!==false,
<                 name:B(a.name,"Slice")
---
>     },
> drawTracker:function(){
>     var a=this,b=a.options.cursor,c=b&&{
>         cursor:b
>     },
>     d;
>     t(a.data,function(e){
>         (d=e.graphic)&&d.attr({
>             isTracker:true
>         }).on("mouseover",function(){
>             a.onMouseOver();
>             e.onMouseOver()
>             }).on("mouseout",function(){
>             a.options.stickyTracking||a.onMouseOut()
>             }).css(c)
>         })
>     },
> cleanData:function(){}
> });
> vb.scatter=ka;
> ka=yb(Bc,{
>     init:function(){
>         Bc.prototype.init.apply(this,arguments);
>         var a=this,b;
>         pa(a,{
>             visible:a.visible!==false,
>             name:B(a.name,"Slice")
4457,4458c4383,4384
<             b=function(){
<                 a.slice()
---
>         b=function(){
>             a.slice()
4461,4473c4387,4389
<             Sa(a,"select",b);
<             Sa(a,"unselect",b);
<             return a
<         },
<         setVisible:function(a){
<             var b=this.series.chart,c=this.tracker,
<             d=this.dataLabel,e=this.connector,f;
<             f=(this.visible=a=a===Ua?!this.visible:a)?"show":"hide";
<             this.group[f]();
<             c&&c[f]();
<             d&&d[f]();
<             e&&e[f]();
<             this.legendItem&&b.legend.colorizeItem(this,a)
---
>         Sa(a,"select",b);
>         Sa(a,"unselect",b);
>         return a
4475,4482c4391,4408
<         slice:function(a,b,c){
<             var d=this.series.chart,e=this.slicedTranslation;
<             fc(c,d);
<             B(b,true);
<             a=this.sliced=J(a)?a:!this.sliced;
<             a={
<                 translateX:a?e[0]:d.plotLeft,
<                 translateY:a?e[1]:d.plotTop
---
>     setVisible:function(a){
>         var b=this.series.chart,c=this.tracker,
>         d=this.dataLabel,e=this.connector,f;
>         f=(this.visible=a=a===Ua?!this.visible:a)?"show":"hide";
>         this.group[f]();
>         c&&c[f]();
>         d&&d[f]();
>         e&&e[f]();
>         this.legendItem&&b.legend.colorizeItem(this,a)
>         },
>     slice:function(a,b,c){
>         var d=this.series.chart,e=this.slicedTranslation;
>         fc(c,d);
>         B(b,true);
>         a=this.sliced=J(a)?a:!this.sliced;
>         a={
>             translateX:a?e[0]:d.plotLeft,
>             translateY:a?e[1]:d.plotTop
4485,4486c4411,4412
<             this.group.animate(a);
<             this.shadowGroup&&this.shadowGroup.animate(a)
---
>         this.group.animate(a);
>         this.shadowGroup&&this.shadowGroup.animate(a)
4489,4516c4415,4442
<     ka=yb(pb,{
<         type:"pie",
<         isCartesian:false,
<         pointClass:ka,
<         pointAttrToOptions:{
<             stroke:"borderColor",
<             "stroke-width":"borderWidth",
<             fill:"color"
<         },
<         getColor:function(){
<             this.initialColor=Pb
<         },
<         animate:function(){
<             var a=this;
<             t(a.data,function(b){
<                 var c=b.graphic;
<                 b=b.shapeArgs;
<                 var d=-Zb/2;
<                 if(c){
<                     c.attr({
<                         r:0,
<                         start:d,
<                         end:d
<                     });
<                     c.animate({
<                         r:b.r,
<                         start:b.start,
<                         end:b.end
---
> ka=yb(pb,{
>     type:"pie",
>     isCartesian:false,
>     pointClass:ka,
>     pointAttrToOptions:{
>         stroke:"borderColor",
>         "stroke-width":"borderWidth",
>         fill:"color"
>     },
>     getColor:function(){
>         this.initialColor=Pb
>         },
>     animate:function(){
>         var a=this;
>         t(a.data,function(b){
>             var c=b.graphic;
>             b=b.shapeArgs;
>             var d=-Zb/2;
>             if(c){
>                 c.attr({
>                     r:0,
>                     start:d,
>                     end:d
>                 });
>                 c.animate({
>                     r:b.r,
>                     start:b.start,
>                     end:b.end
4520,4531c4446,4457
<             a.animate=null
<         },
<         translate:function(){
<             var a=0,b=-0.25,c=this.options,d=c.slicedOffset,e=d+c.borderWidth,f=c.center.concat([c.size,c.innerSize||0]),g=this.chart,h=g.plotWidth,j=g.plotHeight,l,n,C,G=this.data,fa=2*Zb,K,ia=qb(h,
<                 j),u,P,O,Q=c.dataLabels.distance;
<             f=nc(f,function(H,S){
<                 return(u=/%$/.test(H))?[h,j,ia,ia][S]*la(H)/100:H
<             });
<             this.getX=function(H,S){
<                 C=ta.asin((H-f[1])/(f[2]/2+Q));
<                 return f[0]+(S?-1:1)*nb(C)*(f[2]/2+Q)
<             };
---
>     a.animate=null
>     },
> translate:function(){
>     var a=0,b=-0.25,c=this.options,d=c.slicedOffset,e=d+c.borderWidth,f=c.center.concat([c.size,c.innerSize||0]),g=this.chart,h=g.plotWidth,j=g.plotHeight,l,n,C,G=this.data,fa=2*Zb,K,ia=qb(h,
>         j),u,P,O,Q=c.dataLabels.distance;
>     f=nc(f,function(H,S){
>         return(u=/%$/.test(H))?[h,j,ia,ia][S]*la(H)/100:H
>         });
>     this.getX=function(H,S){
>         C=ta.asin((H-f[1])/(f[2]/2+Q));
>         return f[0]+(S?-1:1)*nb(C)*(f[2]/2+Q)
>         };
4533,4550c4459,4476
<             this.center=f;
<             t(G,function(H){
<                 a+=H.y
<             });
<             t(G,function(H){
<                 K=a?H.y/a:0;
<                 l=X(b*fa*1E3)/1E3;
<                 b+=K;
<                 n=X(b*fa*1E3)/1E3;
<                 H.shapeType="arc";
<                 H.shapeArgs={
<                     x:f[0],
<                     y:f[1],
<                     r:f[2]/2,
<                     innerR:f[3]/2,
<                     start:l,
<                     end:n
<                 };
---
>     this.center=f;
>     t(G,function(H){
>         a+=H.y
>         });
>     t(G,function(H){
>         K=a?H.y/a:0;
>         l=X(b*fa*1E3)/1E3;
>         b+=K;
>         n=X(b*fa*1E3)/1E3;
>         H.shapeType="arc";
>         H.shapeArgs={
>             x:f[0],
>             y:f[1],
>             r:f[2]/2,
>             innerR:f[3]/2,
>             start:l,
>             end:n
>         };
4552,4627c4478,4564
<                 C=(n+l)/2;
<                 H.slicedTranslation=nc([nb(C)*d+g.plotLeft,Bb(C)*d+g.plotTop],X);
<                 P=nb(C)*f[2]/2;
<                 O=Bb(C)*f[2]/2;
<                 H.tooltipPos=
<                 [f[0]+P*0.7,f[1]+O*0.7];
<                 H.labelPos=[f[0]+P+nb(C)*Q,f[1]+O+Bb(C)*Q,f[0]+P+nb(C)*e,f[1]+O+Bb(C)*e,f[0]+P,f[1]+O,Q<0?"center":C<fa/4?"left":"right",C];
<                 H.percentage=K*100;
<                 H.total=a
<             });
<             this.setTooltipPoints()
<         },
<         render:function(){
<             this.drawPoints();
<             this.options.enableMouseTracking!==false&&this.drawTracker();
<             this.drawDataLabels();
<             this.options.animation&&this.animate&&this.animate();
<             this.isDirty=false
<         },
<         drawPoints:function(){
<             var a=this.chart,b=a.renderer,c,d,e,f=this.options.shadow,g,h;
<             t(this.data,function(j){
<                 d=
<                 j.graphic;
<                 h=j.shapeArgs;
<                 e=j.group;
<                 g=j.shadowGroup;
<                 if(f&&!g)g=j.shadowGroup=b.g("shadow").attr({
<                     zIndex:4
<                 }).add();
<                 if(!e)e=j.group=b.g("point").attr({
<                     zIndex:5
<                 }).add();
<                 c=j.sliced?j.slicedTranslation:[a.plotLeft,a.plotTop];
<                 e.translate(c[0],c[1]);
<                 g&&g.translate(c[0],c[1]);
<                 if(d)d.animate(h);else j.graphic=b.arc(h).attr(pa(j.pointAttr[hb],{
<                     "stroke-linejoin":"round"
<                 })).add(j.group).shadow(f,g);
<                 j.visible===false&&j.setVisible(false)
<             })
<         },
<         drawDataLabels:function(){
<             var a=this.data,b,c=this.chart,d=this.options.dataLabels,
<             e=B(d.connectorPadding,10),f=B(d.connectorWidth,1),g,h,j=d.distance>0,l,n,C=this.center[1],G=[[],[],[],[]],fa,K,ia,u,P,O,Q,H=4,S;
<             pb.prototype.drawDataLabels.apply(this);
<             t(a,function(Ta){
<                 var cb=Ta.labelPos[7];
<                 G[cb<0?0:cb<Zb/2?1:cb<Zb?2:3].push(Ta)
<             });
<             G[1].reverse();
<             G[3].reverse();
<             for(Q=function(Ta,cb){
<                 return Ta.y>cb.y
<             };
<             H--;){
<                 a=0;
<                 b=[].concat(G[H]);
<                 b.sort(Q);
<                 for(S=b.length;S--;)b[S].rank=S;
<                 for(u=0;u<2;u++){
<                     n=(O=H%3)?9999:-9999;
<                     P=O?-1:1;
<                     for(S=0;S<G[H].length;S++){
<                         b=G[H][S];
<                         if(g=b.dataLabel){
<                             h=b.labelPos;
<                             ia=ub;
<                             fa=h[0];
<                             K=h[1];
<                             l||(l=g&&g.getBBox().height);
<                             if(j)if(u&&b.rank<a)ia=gb;
<                                 else if(!O&&K<n+l||O&&K>n-l){
<                                     K=n+P*l;
<                                     fa=this.getX(K,H>1);
<                                     if(!O&&K+l>C||O&&K-l<C)if(u)ia=gb;else a++
---
>         C=(n+l)/2;
>         H.slicedTranslation=nc([nb(C)*d+g.plotLeft,Bb(C)*d+g.plotTop],X);
>         P=nb(C)*f[2]/2;
>         O=Bb(C)*f[2]/2;
>         H.tooltipPos=
>         [f[0]+P*0.7,f[1]+O*0.7];
>         H.labelPos=[f[0]+P+nb(C)*Q,f[1]+O+Bb(C)*Q,f[0]+P+nb(C)*e,f[1]+O+Bb(C)*e,f[0]+P,f[1]+O,Q<0?"center":C<fa/4?"left":"right",C];
>         H.percentage=K*100;
>         H.total=a
>         });
>     this.setTooltipPoints()
>     },
> render:function(){
>     this.drawPoints();
>     this.options.enableMouseTracking!==false&&this.drawTracker();
>     this.drawDataLabels();
>     this.options.animation&&this.animate&&this.animate();
>     this.isDirty=false
>     },
> drawPoints:function(){
>     var a=this.chart,b=a.renderer,c,d,e,f=this.options.shadow,g,h;
>     t(this.data,function(j){
>         d=
>         j.graphic;
>         h=j.shapeArgs;
>         e=j.group;
>         g=j.shadowGroup;
>         if(f&&!g)g=j.shadowGroup=b.g("shadow").attr({
>             zIndex:4
>         }).add();
>         if(!e)e=j.group=b.g("point").attr({
>             zIndex:5
>         }).add();
>         c=j.sliced?j.slicedTranslation:[a.plotLeft,a.plotTop];
>         e.translate(c[0],c[1]);
>         g&&g.translate(c[0],c[1]);
>         if(d)d.animate(h);else j.graphic=b.arc(h).attr(pa(j.pointAttr[hb],{
>             "stroke-linejoin":"round"
>         })).add(j.group).shadow(f,g);
>         j.visible===false&&j.setVisible(false)
>         })
>     },
> drawDataLabels:function(){
>     var a=this.data,b,c=this.chart,d=this.options.dataLabels,
>     e=B(d.connectorPadding,10),f=B(d.connectorWidth,1),g,h,j=d.distance>0,l,n,C=this.center[1],G=[[],[],[],[]],fa,K,ia,u,P,O,Q,H=4,S;
>     pb.prototype.drawDataLabels.apply(this);
>     t(a,function(Ta){
>         var cb=Ta.labelPos[7];
>         G[cb<0?0:cb<Zb/2?1:cb<Zb?2:3].push(Ta)
>         });
>     G[1].reverse();
>     G[3].reverse();
>     for(Q=function(Ta,cb){
>         return Ta.y>cb.y
>         };
>         H--;){
>         a=0;
>         b=[].concat(G[H]);
>         b.sort(Q);
>         for(S=b.length;S--;)b[S].rank=S;
>         for(u=0;u<2;u++){
>             n=(O=H%3)?9999:-9999;
>             P=O?-1:1;
>             for(S=0;S<G[H].length;S++){
>                 b=G[H][S];
>                 if(g=b.dataLabel){
>                     h=b.labelPos;
>                     ia=ub;
>                     fa=h[0];
>                     K=h[1];
>                     l||(l=g&&g.getBBox().height);
>                     if(j)if(u&&b.rank<a)ia=gb;
>                         else if(!O&&K<n+l||O&&K>n-l){
>                         K=n+P*l;
>                         fa=this.getX(K,H>1);
>                         if(!O&&K+l>C||O&&K-l<C)if(u)ia=gb;else a++
>                     }
>                     if(b.visible===false)ia=gb;
>                     if(ia===ub)n=K;
>                     if(u){
>                         g.attr({
>                             visibility:ia,
>                             align:h[6]
>                             })[g.moved?"animate":"attr"]({
>                             x:fa+d.x+({
>                                 left:e,
>                                 right:-e
4629,4641c4566,4575
<                             if(b.visible===false)ia=gb;
<                             if(ia===ub)n=K;
<                             if(u){
<                                 g.attr({
<                                     visibility:ia,
<                                     align:h[6]
<                                 })[g.moved?"animate":"attr"]({
<                                     x:fa+d.x+({
<                                         left:e,
<                                         right:-e
<                                     }
<                                     [h[6]]||0),
<                                     y:K+d.y
---
>                                 [h[6]]||0),
>                             y:K+d.y
>                             });
>                         g.moved=true;
>                         if(j&&f){
>                             g=b.connector;
>                             h=[Za,fa+(h[6]==="left"?5:-5),K,Ja,fa,K,Ja,h[2],h[3],Ja,h[4],h[5]];
>                             if(g){
>                                 g.animate({
>                                     d:h
4643,4658c4577,4584
<                                 g.moved=true;
<                                 if(j&&f){
<                                     g=b.connector;
<                                     h=[Za,fa+(h[6]==="left"?5:-5),K,Ja,fa,K,Ja,h[2],h[3],Ja,h[4],h[5]];
<                                     if(g){
<                                         g.animate({
<                                             d:h
<                                         });
<                                         g.attr("visibility",ia)
<                                     }else b.connector=
<                                         g=this.chart.renderer.path(h).attr({
<                                             "stroke-width":f,
<                                             stroke:d.connectorColor||"#606060",
<                                             visibility:ia,
<                                             zIndex:3
<                                         }).translate(c.plotLeft,c.plotTop).add()
---
>                                 g.attr("visibility",ia)
>                                 }else b.connector=
>                                 g=this.chart.renderer.path(h).attr({
>                                     "stroke-width":f,
>                                     stroke:d.connectorColor||"#606060",
>                                     visibility:ia,
>                                     zIndex:3
>                                 }).translate(c.plotLeft,c.plotTop).add()
4661,4662d4586
<                         }
<                     }
4665,4698c4589
<         },
<         drawTracker:cd.prototype.drawTracker,
<         getSymbol:function(){}
<     });
<     vb.pie=ka;
<     ab.Highcharts={
<         Chart:Hd,
<         dateFormat:Oc,
<         pathAnim:bd,
<         getOptions:function(){
<             return Va
<         },
<         numberFormat:Bd,
<         Point:Bc,
<         Color:$b,
<         Renderer:Xc,
<         seriesTypes:vb,
<         setOptions:function(a){
<             Va=sa(Va,a);
<             Cd();
<             return Va
<         },
<         Series:pb,
<         addEvent:Sa,
<         createElement:ib,
<         discardElement:Hc,
<         css:La,
<         each:t,
<         extend:pa,
<         map:nc,
<         merge:sa,
<         pick:B,
<         extendClass:yb,
<         version:"2.1.5"
---
>         }
4699a4591,4625
> },
> drawTracker:cd.prototype.drawTracker,
> getSymbol:function(){}
> });
> vb.pie=ka;
> ab.Highcharts={
>     Chart:Hd,
>     dateFormat:Oc,
>     pathAnim:bd,
>     getOptions:function(){
>         return Va
>         },
>     numberFormat:Bd,
>     Point:Bc,
>     Color:$b,
>     Renderer:Xc,
>     seriesTypes:vb,
>     setOptions:function(a){
>         Va=sa(Va,a);
>         Cd();
>         return Va
>         },
>     Series:pb,
>     addEvent:Sa,
>     createElement:ib,
>     discardElement:Hc,
>     css:La,
>     each:t,
>     extend:pa,
>     map:nc,
>     merge:sa,
>     pick:B,
>     extendClass:yb,
>     version:"2.1.5"
> }
diff -r --exclude=.svn v550/public/highcharts/js/highcharts.src.js v537/public/highcharts/js/highcharts.src.js
17,68c17,68
<     // encapsulated variables
<     var doc = document,
<     win = window,
<     math = Math,
<     mathRound = math.round,
<     mathFloor = math.floor,
<     mathCeil = math.ceil,
<     mathMax = math.max,
<     mathMin = math.min,
<     mathAbs = math.abs,
<     mathCos = math.cos,
<     mathSin = math.sin,
<     mathPI = math.PI,
<     deg2rad = mathPI * 2 / 360,
< 	
< 	
<     // some variables
<     userAgent = navigator.userAgent,
<     isIE = /msie/i.test(userAgent) && !win.opera,
<     docMode8 = doc.documentMode === 8,
<     isWebKit = /AppleWebKit/.test(userAgent),
<     isFirefox = /Firefox/.test(userAgent),
<     //hasSVG = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
<     hasSVG = !!doc.createElementNS && !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
<     SVG_NS = 'http://www.w3.org/2000/svg',
<     Renderer,
<     hasTouch = doc.documentElement.ontouchstart !== undefined,
<     colorCounter,
<     symbolCounter,
<     symbolSizes = {},
<     idCounter = 0,
<     timeFactor = 1, // 1 = JavaScript time, 1000 = Unix time
<     garbageBin,
<     defaultOptions,
<     dateFormat, // function
<     globalAnimation,
<     pathAnim,
< 	
< 	
<     // some constants for frequently used strings
<     UNDEFINED,
<     DIV = 'div',
<     ABSOLUTE = 'absolute',
<     RELATIVE = 'relative',
<     HIDDEN = 'hidden',
<     PREFIX = 'highcharts-',
<     VISIBLE = 'visible',
<     PX = 'px',
<     NONE = 'none',
<     M = 'M',
<     L = 'L',
<     /*
---
> // encapsulated variables
> var doc = document,
> 	win = window,
> 	math = Math,
> 	mathRound = math.round,
> 	mathFloor = math.floor,
> 	mathCeil = math.ceil,
> 	mathMax = math.max,
> 	mathMin = math.min,
> 	mathAbs = math.abs,
> 	mathCos = math.cos,
> 	mathSin = math.sin,
> 	mathPI = math.PI,
> 	deg2rad = mathPI * 2 / 360,
> 	
> 	
> 	// some variables
> 	userAgent = navigator.userAgent,
> 	isIE = /msie/i.test(userAgent) && !win.opera,
> 	docMode8 = doc.documentMode === 8,
> 	isWebKit = /AppleWebKit/.test(userAgent),
> 	isFirefox = /Firefox/.test(userAgent),
> 	//hasSVG = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
> 	hasSVG = !!doc.createElementNS && !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
> 	SVG_NS = 'http://www.w3.org/2000/svg',
> 	Renderer,
> 	hasTouch = doc.documentElement.ontouchstart !== undefined,
> 	colorCounter,
> 	symbolCounter,
> 	symbolSizes = {},
> 	idCounter = 0,
> 	timeFactor = 1, // 1 = JavaScript time, 1000 = Unix time
> 	garbageBin,
> 	defaultOptions,
> 	dateFormat, // function
> 	globalAnimation,
> 	pathAnim,
> 	
> 	
> 	// some constants for frequently used strings
> 	UNDEFINED,
> 	DIV = 'div',
> 	ABSOLUTE = 'absolute',
> 	RELATIVE = 'relative',
> 	HIDDEN = 'hidden',
> 	PREFIX = 'highcharts-',
> 	VISIBLE = 'visible',
> 	PX = 'px',
> 	NONE = 'none',
> 	M = 'M',
> 	L = 'L',
> 	/*
79,118c79,118
<     TRACKER_FILL = 'rgba(192,192,192,'+ (hasSVG ? 0.000001 : 0.002) +')', // invisible but clickable
<     NORMAL_STATE = '',
<     HOVER_STATE = 'hover',
<     SELECT_STATE = 'select',
< 	
<     // time methods, changed based on whether or not UTC is used
<     makeTime,
<     getMinutes,
<     getHours,
<     getDay,
<     getDate,
<     getMonth,
<     getFullYear,
<     setMinutes,
<     setHours,
<     setDate,
<     setMonth,
<     setFullYear,
< 	
<     // check for a custom HighchartsAdapter defined prior to this file
<     globalAdapter = win.HighchartsAdapter,
<     adapter = globalAdapter || {},
< 	
<     // Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
<     // and all the utility functions will be null. In that case they are populated by the
<     // default adapters below.
<     each = adapter.each,
<     grep = adapter.grep,
<     map = adapter.map,
<     merge = adapter.merge,
<     hyphenate = adapter.hyphenate,
<     addEvent = adapter.addEvent,
<     removeEvent = adapter.removeEvent,
<     fireEvent = adapter.fireEvent,
<     animate = adapter.animate,
<     stop = adapter.stop,
< 	
<     // lookup over the types and the associated classes
<     seriesTypes = {},
<     hoverChart;
---
> 	TRACKER_FILL = 'rgba(192,192,192,'+ (hasSVG ? 0.000001 : 0.002) +')', // invisible but clickable
> 	NORMAL_STATE = '',
> 	HOVER_STATE = 'hover',
> 	SELECT_STATE = 'select',
> 	
> 	// time methods, changed based on whether or not UTC is used
> 	makeTime,
> 	getMinutes,
> 	getHours,
> 	getDay,
> 	getDate,
> 	getMonth,
> 	getFullYear,
> 	setMinutes,
> 	setHours,
> 	setDate,
> 	setMonth,
> 	setFullYear,
> 	
> 	// check for a custom HighchartsAdapter defined prior to this file
> 	globalAdapter = win.HighchartsAdapter,
> 	adapter = globalAdapter || {}, 
> 	
> 	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
> 	// and all the utility functions will be null. In that case they are populated by the 
> 	// default adapters below.
> 	each = adapter.each,
> 	grep = adapter.grep,
> 	map = adapter.map,
> 	merge = adapter.merge,
> 	hyphenate = adapter.hyphenate,
> 	addEvent = adapter.addEvent,
> 	removeEvent = adapter.removeEvent,
> 	fireEvent = adapter.fireEvent,
> 	animate = adapter.animate,
> 	stop = adapter.stop,
> 	
> 	// lookup over the types and the associated classes
> 	seriesTypes = {},
> 	hoverChart;
120c120
<     /**
---
> /**
125,134c125,134
<     function extend(a, b) {
<         var n;
<         if (!a) {
<             a = {};
<         }
<         for (n in b) {
<             a[n] = b[n];
<         }
<         return a;
<     }
---
> function extend(a, b) {
> 	var n;
> 	if (!a) {
> 		a = {};
> 	}
> 	for (n in b) {
> 		a[n] = b[n];
> 	}
> 	return a;
> }
136c136
<     /**
---
> /**
140,142c140,142
<     function pInt(s, mag) {
<         return parseInt(s, mag || 10);
<     }
---
> function pInt(s, mag) {
> 	return parseInt(s, mag || 10);
> }
144c144
<     /**
---
> /**
148,150c148,150
<     function isString(s) {
<         return typeof s === 'string';
<     }
---
> function isString(s) {
> 	return typeof s === 'string';
> }
152c152
<     /**
---
> /**
156,158c156,158
<     function isObject(obj) {
<         return typeof obj === 'object';
<     }
---
> function isObject(obj) {
> 	return typeof obj === 'object';
> }
160c160
<     /**
---
> /**
164,173c164,173
<     function isNumber(n) {
<         return typeof n === 'number';
<     }
< 
<     function log2lin(num) {
<         return math.log(num) / math.LN10;
<     }
<     function lin2log(num) {
<         return math.pow(10, num);
<     }
---
> function isNumber(n) {
> 	return typeof n === 'number';
> }
> 
> function log2lin(num) {
> 	return math.log(num) / math.LN10;
> }
> function lin2log(num) {
> 	return math.pow(10, num);
> }
175c175
<     /**
---
> /**
180,189c180,189
<     function erase(arr, item) {
<         var i = arr.length;
<         while (i--) {
<             if (arr[i] === item) {
<                 arr.splice(i, 1);
<                 break;
<             }
<         }
<     //return arr;
<     }
---
> function erase(arr, item) {
> 	var i = arr.length;
> 	while (i--) {
> 		if (arr[i] === item) {
> 			arr.splice(i, 1);
> 			break;
> 		}
> 	}
> 	//return arr;
> }
191c191
<     /**
---
> /**
195,197c195,197
<     function defined (obj) {
<         return obj !== UNDEFINED && obj !== null;
<     }
---
> function defined (obj) {
> 	return obj !== UNDEFINED && obj !== null;
> }
199c199
<     /**
---
> /**
207,232c207,232
<     function attr(elem, prop, value) {
<         var key,
<         setAttribute = 'setAttribute',
<         ret;
< 	
<         // if the prop is a string
<         if (isString(prop)) {
<             // set the value
<             if (defined(value)) {
< 
<                 elem[setAttribute](prop, value);
< 		
<             // get the value
<             } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
<                 ret = elem.getAttribute(prop);
<             }
< 	
<         // else if prop is defined, it is a hash of key/value pairs
<         } else if (defined(prop) && isObject(prop)) {
<             for (key in prop) {
<                 elem[setAttribute](key, prop[key]);
<             }
<         }
<         return ret;
<     }
<     /**
---
> function attr(elem, prop, value) {
> 	var key,
> 		setAttribute = 'setAttribute',
> 		ret;
> 	
> 	// if the prop is a string
> 	if (isString(prop)) {
> 		// set the value
> 		if (defined(value)) {
> 
> 			elem[setAttribute](prop, value);
> 		
> 		// get the value
> 		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
> 			ret = elem.getAttribute(prop);
> 		}
> 	
> 	// else if prop is defined, it is a hash of key/value pairs
> 	} else if (defined(prop) && isObject(prop)) {
> 		for (key in prop) {
> 			elem[setAttribute](key, prop[key]);
> 		}
> 	}
> 	return ret;
> }
> /**
236,241c236,241
<     function splat(obj) {
<         if (!obj || obj.constructor !== Array) {
<             obj = [obj];
<         }
<         return obj;
<     }
---
> function splat(obj) {
> 	if (!obj || obj.constructor !== Array) {
> 		obj = [obj];
> 	}
> 	return obj; 
> }
245c245
<     /**
---
> /**
248,260c248,260
<     function pick() {
<         var args = arguments,
<         i,
<         arg,
<         length = args.length;
<         for (i = 0; i < length; i++) {
<             arg = args[i];
<             if (typeof arg !== 'undefined' && arg !== null) {
<                 return arg;
<             }
<         }
<     }
<     /**
---
> function pick() {
> 	var args = arguments,
> 		i,
> 		arg,
> 		length = args.length;
> 	for (i = 0; i < length; i++) {
> 		arg = args[i];
> 		if (typeof arg !== 'undefined' && arg !== null) {
> 			return arg;
> 		}
> 	}
> }
> /**
264,271c264,271
<     function serializeCSS(style) {
<         var s = '',
<         key;
<         // serialize the declaration
<         for (key in style) {
<             s += key +':'+ style[key] + ';';
<         }
<         return s;
---
> function serializeCSS(style) {
> 	var s = '', 
> 		key;
> 	// serialize the declaration
> 	for (key in style) {
> 		s += key +':'+ style[key] + ';';
> 	}
> 	return s;
273,274c273,274
<     }
<     /**
---
> }
> /**
279,286c279,286
<     function css (el, styles) {
<         if (isIE) {
<             if (styles && styles.opacity !== UNDEFINED) {
<                 styles.filter = 'alpha(opacity='+ (styles.opacity * 100) +')';
<             }
<         }
<         extend(el.style, styles);
<     }
---
> function css (el, styles) {
> 	if (isIE) {
> 		if (styles && styles.opacity !== UNDEFINED) {
> 			styles.filter = 'alpha(opacity='+ (styles.opacity * 100) +')';
> 		}
> 	}
> 	extend(el.style, styles);
> }
288c288
<     /* *
---
> /* *
305c305
<     /**
---
> /**
313,332c313,328
<     function createElement (tag, attribs, styles, parent, nopad) {
<         var el = doc.createElement(tag);
<         if (attribs) {
<             extend(el, attribs);
<         }
<         if (nopad) {
<             css(el, {
<                 padding: 0,
<                 border: NONE,
<                 margin: 0
<             });
<         }
<         if (styles) {
<             css(el, styles);
<         }
<         if (parent) {
<             parent.appendChild(el);
<         }
<         return el;
<     }
---
> function createElement (tag, attribs, styles, parent, nopad) {
> 	var el = doc.createElement(tag);
> 	if (attribs) {
> 		extend(el, attribs);
> 	}
> 	if (nopad) {
> 		css(el, {padding: 0, border: NONE, margin: 0});
> 	}
> 	if (styles) {
> 		css(el, styles);
> 	}
> 	if (parent) {
> 		parent.appendChild(el);
> 	}	
> 	return el;
> }
334c330
<     /**
---
> /**
339,344c335,340
<     function extendClass(parent, members) {
<         var object = function(){};
<         object.prototype = new parent();
<         extend(object.prototype, members);
<         return object;
<     }
---
> function extendClass(parent, members) {
> 	var object = function(){};
> 	object.prototype = new parent();
> 	extend(object.prototype, members);
> 	return object;
> }
346c342
<     /**
---
> /**
353,360c349,356
<     function numberFormat (number, decimals, decPoint, thousandsSep) {
<         var lang = defaultOptions.lang,
<         // http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
<         n = number, c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
<         d = decPoint === undefined ? lang.decimalPoint : decPoint,
<         t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "",
<         i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
<         j = i.length > 3 ? i.length % 3 : 0;
---
> function numberFormat (number, decimals, decPoint, thousandsSep) {
> 	var lang = defaultOptions.lang,
> 		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
> 		n = number, c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
> 		d = decPoint === undefined ? lang.decimalPoint : decPoint,
> 		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "",
> 		i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
> 		j = i.length > 3 ? i.length % 3 : 0;
362,364c358,360
<         return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
<         (c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
<     }
---
> 	return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
> 		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
> }
366c362
<     /**
---
> /**
372,393c368,389
<     dateFormat = function (format, timestamp, capitalize) {
<         function pad (number) {
<             return number.toString().replace(/^([0-9])$/, '0$1');
<         }
< 	
<         if (!defined(timestamp) || isNaN(timestamp)) {
<             return 'Invalid date';
<         }
<         format = pick(format, '%Y-%m-%d %H:%M:%S');
< 	
<         var date = new Date(timestamp * timeFactor),
<         key, // used in for constuct below
<         // get the basic time values
<         hours = date[getHours](),
<         day = date[getDay](),
<         dayOfMonth = date[getDate](),
<         month = date[getMonth](),
<         fullYear = date[getFullYear](),
<         lang = defaultOptions.lang,
<         langWeekdays = lang.weekdays,
<         langMonths = lang.months,
<         /* // uncomment this and the 'W' format key below to enable week numbers
---
> dateFormat = function (format, timestamp, capitalize) {
> 	function pad (number) {
> 		return number.toString().replace(/^([0-9])$/, '0$1');
> 	}
> 	
> 	if (!defined(timestamp) || isNaN(timestamp)) {
> 		return 'Invalid date';
> 	}
> 	format = pick(format, '%Y-%m-%d %H:%M:%S');
> 	
> 	var date = new Date(timestamp * timeFactor),
> 		key, // used in for constuct below
> 		// get the basic time values
> 		hours = date[getHours](),
> 		day = date[getDay](),
> 		dayOfMonth = date[getDate](),
> 		month = date[getMonth](),
> 		fullYear = date[getFullYear](),
> 		lang = defaultOptions.lang,
> 		langWeekdays = lang.weekdays,
> 		langMonths = lang.months,
> 		/* // uncomment this and the 'W' format key below to enable week numbers
404,405c400,401
<         // list all format keys
<         replacements = {
---
> 		// list all format keys
> 		replacements = {
407,444c403,440
<             // Day
<             'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
<             'A': langWeekdays[day], // Long weekday, like 'Monday'
<             'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
<             'e': dayOfMonth, // Day of the month, 1 through 31
< 			
<             // Week (none implemented)
<             //'W': weekNumber(),
< 			
<             // Month
<             'b': langMonths[month].substr(0, 3), // Short month, like 'Jan'
<             'B': langMonths[month], // Long month, like 'January'
<             'm': pad(month + 1), // Two digit month number, 01 through 12
< 			
<             // Year
<             'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
<             'Y': fullYear, // Four digits year, like 2009
< 			
<             // Time
<             'H': pad(hours), // Two digits hours in 24h format, 00 through 23
<             'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
<             'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
<             'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
<             'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
<             'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
<             'S': pad(date.getSeconds()) // Two digits seconds, 00 through  59
< 			
<         };
< 
< 
<         // do the replaces
<         for (key in replacements) {
<             format = format.replace('%'+ key, replacements[key]);
<         }
< 		
<         // Optionally capitalize the string and return
<         return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
<     };
---
> 			// Day
> 			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
> 			'A': langWeekdays[day], // Long weekday, like 'Monday'
> 			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31 
> 			'e': dayOfMonth, // Day of the month, 1 through 31 
> 			
> 			// Week (none implemented)
> 			//'W': weekNumber(),
> 			
> 			// Month
> 			'b': langMonths[month].substr(0, 3), // Short month, like 'Jan'
> 			'B': langMonths[month], // Long month, like 'January'
> 			'm': pad(month + 1), // Two digit month number, 01 through 12
> 			
> 			// Year
> 			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
> 			'Y': fullYear, // Four digits year, like 2009
> 			
> 			// Time
> 			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
> 			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
> 			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
> 			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
> 			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
> 			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
> 			'S': pad(date.getSeconds()) // Two digits seconds, 00 through  59
> 			
> 		};
> 
> 
> 	// do the replaces
> 	for (key in replacements) {
> 		format = format.replace('%'+ key, replacements[key]);
> 	}
> 		
> 	// Optionally capitalize the string and return
> 	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
> };
446c442
<     /**
---
> /**
454,470c450,463
<     function getPosition (el) {
<         var p = {
<             left: el.offsetLeft,
<             top: el.offsetTop
<         };
<         el = el.offsetParent;
<         while (el) {
<             p.left += el.offsetLeft;
<             p.top += el.offsetTop;
<             if (el !== doc.body && el !== doc.documentElement) {
<                 p.left -= el.scrollLeft;
<                 p.top -= el.scrollTop;
<             }
<             el = el.offsetParent;
<         }
<         return p;
<     }
---
> function getPosition (el) {
> 	var p = { left: el.offsetLeft, top: el.offsetTop };
> 	el = el.offsetParent;
> 	while (el) {
> 		p.left += el.offsetLeft;
> 		p.top += el.offsetTop;
> 		if (el !== doc.body && el !== doc.documentElement) {
> 			p.left -= el.scrollLeft;
> 			p.top -= el.scrollTop;
> 		}
> 		el = el.offsetParent;
> 	}
> 	return p;
> }
472c465
<     /**
---
> /**
478,480c471,473
<     function setAnimation(animation, chart) {
<         globalAnimation = pick(animation, chart.animation);
<     }
---
> function setAnimation(animation, chart) {
> 	globalAnimation = pick(animation, chart.animation);
> }
482c475
<     /*
---
> /* 
486,490c479,483
<     if (globalAdapter && globalAdapter.init) {
<         globalAdapter.init();
<     }
<     if (!globalAdapter && win.jQuery) {
<         var jQ = jQuery;
---
> if (globalAdapter && globalAdapter.init) {
> 	globalAdapter.init();
> } 
> if (!globalAdapter && win.jQuery) {
> 	var jQ = jQuery;
492c485
<         /**
---
> 	/**
497,505c490,498
<         each = function(arr, fn) {
<             var i = 0,
<             len = arr.length;
<             for (; i < len; i++) {
<                 if (fn.call(arr[i], arr[i], i, arr) === false) {
<                     return i;
<                 }
<             }
<         };
---
> 	each = function(arr, fn) {
> 		var i = 0, 
> 			len = arr.length;
> 		for (; i < len; i++) {
> 			if (fn.call(arr[i], arr[i], i, arr) === false) {
> 				return i;
> 			}
> 		}
> 	};
507c500
<         /**
---
> 	/**
510c503
<         grep = jQ.grep;
---
> 	grep = jQ.grep;
512c505
<         /**
---
> 	/**
517,524c510,517
<         map = function(arr, fn){
<             //return jQuery.map(arr, fn);
<             var results = [],
<             i = 0, len = arr.length;
<             for (; i < len; i++) {
<                 results[i] = fn.call(arr[i], arr[i], i, arr);
<             }
<             return results;
---
> 	map = function(arr, fn){
> 		//return jQuery.map(arr, fn);
> 		var results = [],
> 			i = 0, len = arr.length;
> 		for (; i < len; i++) {
> 			results[i] = fn.call(arr[i], arr[i], i, arr);
> 		}
> 		return results;
526c519
<         };
---
> 	};
528c521
<         /**
---
> 	/**
531,534c524,527
<         merge = function(){
<             var args = arguments;
<             return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
<         };
---
> 	merge = function(){
> 		var args = arguments;
> 		return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
> 	};
536c529
<         /**
---
> 	/**
540,544c533,535
<         hyphenate = function (str) {
<             return str.replace(/([A-Z])/g, function(a, b){
<                 return '-'+ b.toLowerCase();
<             });
<         };
---
> 	hyphenate = function (str) {
> 		return str.replace(/([A-Z])/g, function(a, b){ return '-'+ b.toLowerCase(); });
> 	};
546c537
<         /**
---
> 	/**
552,554c543,545
<         addEvent = function (el, event, fn){
<             jQ(el).bind(event, fn);
<         };
---
> 	addEvent = function (el, event, fn){
> 		jQ(el).bind(event, fn);
> 	};
556c547
<         /**
---
> 	/**
562,568c553,559
<         removeEvent = function(el, eventType, handler) {
<             // workaround for jQuery issue with unbinding custom events:
<             // http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
<             var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
<             if (doc[func] && !el[func]) {
<                 el[func] = function() {};
<             }
---
> 	removeEvent = function(el, eventType, handler) {
> 		// workaround for jQuery issue with unbinding custom events:
> 		// http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
> 		var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
> 		if (doc[func] && !el[func]) {
> 			el[func] = function() {};
> 		}
570,571c561,562
<             jQ(el).unbind(eventType, handler);
<         };
---
> 		jQ(el).unbind(eventType, handler);
> 	};
573c564
<         /**
---
> 	/**
580,605c571,596
<         fireEvent = function(el, type, eventArguments, defaultFunction) {
<             var event = jQ.Event(type),
<             detachedType = 'detached'+ type;
<             extend(event, eventArguments);
< 		
<             // Prevent jQuery from triggering the object method that is named the
<             // same as the event. For example, if the event is 'select', jQuery
<             // attempts calling el.select and it goes into a loop.
<             if (el[type]) {
<                 el[detachedType] = el[type];
<                 el[type] = null;
<             }
< 		
<             // trigger it
<             jQ(el).trigger(event);
< 		
<             // attach the method
<             if (el[detachedType]) {
<                 el[type] = el[detachedType];
<                 el[detachedType] = null;
<             }
< 		
<             if (defaultFunction && !event.isDefaultPrevented()) {
<                 defaultFunction(event);
<             }
<         };
---
> 	fireEvent = function(el, type, eventArguments, defaultFunction) {
> 		var event = jQ.Event(type),
> 			detachedType = 'detached'+ type;
> 		extend(event, eventArguments);
> 		
> 		// Prevent jQuery from triggering the object method that is named the
> 		// same as the event. For example, if the event is 'select', jQuery
> 		// attempts calling el.select and it goes into a loop.
> 		if (el[type]) {
> 			el[detachedType] = el[type];
> 			el[type] = null;	
> 		}
> 		
> 		// trigger it
> 		jQ(el).trigger(event);
> 		
> 		// attach the method
> 		if (el[detachedType]) {
> 			el[type] = el[detachedType];
> 			el[detachedType] = null;
> 		}
> 		
> 		if (defaultFunction && !event.isDefaultPrevented()) {
> 			defaultFunction(event);
> 		}	
> 	};
607c598
<         /**
---
> 	/**
613,618c604,609
<         animate = function (el, params, options) {
<             var $el = jQ(el);
<             if (params.d) {
<                 el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
<                 params.d = 1; // because in jQuery, animating to an array has a different meaning
<             }
---
> 	animate = function (el, params, options) {
> 		var $el = jQ(el);
> 		if (params.d) {
> 			el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
> 			params.d = 1; // because in jQuery, animating to an array has a different meaning
> 		}
620,621c611,612
<             $el.stop();
<             $el.animate(params, options);
---
> 		$el.stop();
> 		$el.animate(params, options);
623,624c614,615
<         };
<         /**
---
> 	};
> 	/**
627,629c618,620
<         stop = function (el) {
<             jQ(el).stop();
<         };
---
> 	stop = function (el) {
> 		jQ(el).stop();
> 	};
632,637c623,628
<         // extend jQuery
<         jQ.extend( jQ.easing, {
<             easeOutQuad: function (x, t, b, c, d) {
<                 return -c *(t/=d)*(t-2) + b;
<             }
<         });
---
> 	// extend jQuery
> 	jQ.extend( jQ.easing, {
> 		easeOutQuad: function (x, t, b, c, d) {
> 			return -c *(t/=d)*(t-2) + b;
> 		}
> 	});
639,683c630,674
<         // extend the animate function to allow SVG animations
<         var oldStepDefault = jQuery.fx.step._default,
<         oldCur = jQuery.fx.prototype.cur;
< 	
<         // do the step
<         jQ.fx.step._default = function(fx){
<             var elem = fx.elem;
<             if (elem.attr) { // is SVG element wrapper
<                 elem.attr(fx.prop, fx.now);
<             } else {
<                 oldStepDefault.apply(this, arguments);
<             }
<         };
<         // animate paths
<         jQ.fx.step.d = function(fx) {
<             var elem = fx.elem;
< 			
< 		
<             // Normally start and end should be set in state == 0, but sometimes,
<             // for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
<             // in these cases
<             if (!fx.started) {
<                 var ends = pathAnim.init(elem, elem.d, elem.toD);
<                 fx.start = ends[0];
<                 fx.end = ends[1];
<                 fx.started = true;
<             }
< 		
< 		
<             // interpolate each value of the path
<             elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
< 	
<         };
<         // get the current value
<         jQ.fx.prototype.cur = function() {
<             var elem = this.elem,
<             r;
<             if (elem.attr) { // is SVG element wrapper
<                 r = elem.attr(this.prop);
<             } else {
<                 r = oldCur.apply(this, arguments);
<             }
<             return r;
<         };
<     }
---
> 	// extend the animate function to allow SVG animations
> 	var oldStepDefault = jQuery.fx.step._default, 
> 		oldCur = jQuery.fx.prototype.cur;
> 	
> 	// do the step
> 	jQ.fx.step._default = function(fx){
> 		var elem = fx.elem;
> 		if (elem.attr) { // is SVG element wrapper
> 			elem.attr(fx.prop, fx.now);
> 		} else {
> 			oldStepDefault.apply(this, arguments);
> 		}
> 	};
> 	// animate paths
> 	jQ.fx.step.d = function(fx) {
> 		var elem = fx.elem;
> 			
> 		
> 		// Normally start and end should be set in state == 0, but sometimes,
> 		// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
> 		// in these cases
> 		if (!fx.started) {
> 			var ends = pathAnim.init(elem, elem.d, elem.toD);
> 			fx.start = ends[0];
> 			fx.end = ends[1];
> 			fx.started = true;
> 		}
> 		
> 		
> 		// interpolate each value of the path
> 		elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
> 	
> 	};
> 	// get the current value
> 	jQ.fx.prototype.cur = function() {
> 		var elem = this.elem,
> 			r;
> 		if (elem.attr) { // is SVG element wrapper
> 			r = elem.attr(this.prop);
> 		} else {
> 			r = oldCur.apply(this, arguments);
> 		}
> 		return r;
> 	};
> }
686c677
<     /**
---
> /**
689c680
<     /*addEvent(doc, 'mousemove', function(e) {
---
> /*addEvent(doc, 'mousemove', function(e) {
695c686
<     /**
---
> /**
698,699c689,690
<     pathAnim = {
<         /**
---
> pathAnim = {
> 	/**
702,761c693,752
<         init: function(elem, fromD, toD) {
<             fromD = fromD || '';
<             var shift = elem.shift,
<             bezier = fromD.indexOf('C') > -1,
<             numParams = bezier ? 7 : 3,
<             endLength,
<             slice,
<             i,
<             start = fromD.split(' '),
<             end = [].concat(toD), // copy
<             startBaseLine,
<             endBaseLine,
<             sixify = function(arr) { // in splines make move points have six parameters like bezier curves
<                 i = arr.length;
<                 while (i--) {
<                     if (arr[i] === M) {
<                         arr.splice(i + 1, 0, arr[i+1], arr[i+2], arr[i+1], arr[i+2]);
<                     }
<                 }
<             };
< 		
<             if (bezier) {
<                 sixify(start);
<                 sixify(end);
<             }
< 		
<             // pull out the base lines before padding
<             if (elem.isArea) {
<                 startBaseLine = start.splice(start.length - 6, 6);
<                 endBaseLine = end.splice(end.length - 6, 6);
<             }
< 		
<             // if shifting points, prepend a dummy point to the end path
<             if (shift) {
< 
<                 end = [].concat(end).splice(0, numParams).concat(end);
<                 elem.shift = false; // reset for following animations
<             }
< 		
<             // copy and append last point until the length matches the end length
<             if (start.length) {
<                 endLength = end.length;
<                 while (start.length < endLength) {
< 				
<                     //bezier && sixify(start);
<                     slice = [].concat(start).splice(start.length - numParams, numParams);
<                     if (bezier) { // disable first control point
<                         slice[numParams - 6] = slice[numParams - 2];
<                         slice[numParams - 5] = slice[numParams - 1];
<                     }
<                     start = start.concat(slice);
<                 }
<             }
< 		
<             if (startBaseLine) { // append the base lines for areas
<                 start = start.concat(startBaseLine);
<                 end = end.concat(endBaseLine);
<             }
<             return [start, end];
<         },
---
> 	init: function(elem, fromD, toD) {
> 		fromD = fromD || '';
> 		var shift = elem.shift,
> 			bezier = fromD.indexOf('C') > -1,
> 			numParams = bezier ? 7 : 3,
> 			endLength,
> 			slice,
> 			i,
> 			start = fromD.split(' '),
> 			end = [].concat(toD), // copy
> 			startBaseLine,
> 			endBaseLine,
> 			sixify = function(arr) { // in splines make move points have six parameters like bezier curves
> 				i = arr.length;
> 				while (i--) {
> 					if (arr[i] === M) {
> 						arr.splice(i + 1, 0, arr[i+1], arr[i+2], arr[i+1], arr[i+2]);
> 					}
> 				}
> 			};
> 		
> 		if (bezier) {
> 			sixify(start);
> 			sixify(end);
> 		}
> 		
> 		// pull out the base lines before padding
> 		if (elem.isArea) { 
> 			startBaseLine = start.splice(start.length - 6, 6);
> 			endBaseLine = end.splice(end.length - 6, 6);
> 		}
> 		
> 		// if shifting points, prepend a dummy point to the end path
> 		if (shift) {
> 
> 			end = [].concat(end).splice(0, numParams).concat(end);
> 			elem.shift = false; // reset for following animations
> 		}
> 		
> 		// copy and append last point until the length matches the end length
> 		if (start.length) {
> 			endLength = end.length;
> 			while (start.length < endLength) {		
> 				
> 				//bezier && sixify(start); 
> 				slice = [].concat(start).splice(start.length - numParams, numParams);
> 				if (bezier) { // disable first control point
> 					slice[numParams - 6] = slice[numParams - 2];
> 					slice[numParams - 5] = slice[numParams - 1];
> 				}
> 				start = start.concat(slice);
> 			}
> 		}
> 		
> 		if (startBaseLine) { // append the base lines for areas
> 			start = start.concat(startBaseLine);
> 			end = end.concat(endBaseLine);
> 		}
> 		return [start, end];
> 	},
763c754
<         /**
---
> 	/**
766,780c757,771
<         step: function(start, end, pos, complete) {
<             var ret = [],
<             i = start.length,
<             startVal;
< 			
<             if (pos === 1) { // land on the final path without adjustment points appended in the ends
<                 ret = complete;
< 			
<             } else if (i === end.length && pos < 1) {
<                 while (i--) {
<                     startVal = parseFloat(start[i]);
<                     ret[i] =
<                     isNaN(startVal) ? // a letter instruction like M or L
<                     start[i] :
<                     pos * (parseFloat(end[i] - startVal)) + startVal;
---
> 	step: function(start, end, pos, complete) {
> 		var ret = [],
> 			i = start.length,
> 			startVal;
> 			
> 		if (pos === 1) { // land on the final path without adjustment points appended in the ends
> 			ret = complete;
> 			
> 		} else if (i === end.length && pos < 1) {
> 			while (i--) {
> 				startVal = parseFloat(start[i]);
> 				ret[i] = 
> 					isNaN(startVal) ? // a letter instruction like M or L
> 						start[i] :
> 						pos * (parseFloat(end[i] - startVal)) + startVal;
782,788c773,779
<                 }
<             } else { // if animation is finished or length not matching, land on right value
<                 ret = end;
<             }
<             return ret;
<         }
<     };
---
> 			}
> 		} else { // if animation is finished or length not matching, land on right value
> 			ret = end;
> 		}
> 		return ret;
> 	}
> };
790c781
<     /**
---
> /**
794,795c785,786
<     function setTimeMethods() {
<         var useUTC = defaultOptions.global.useUTC;
---
> function setTimeMethods() {
> 	var useUTC = defaultOptions.global.useUTC;
797,817c788,808
<         makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
<             return new Date(
<                 year,
<                 month,
<                 pick(date, 1),
<                 pick(hours, 0),
<                 pick(minutes, 0),
<                 pick(seconds, 0)
<                 ).getTime();
<         };
<         getMinutes = useUTC ? 'getUTCMinutes' : 'getMinutes';
<         getHours = useUTC ? 'getUTCHours' : 'getHours';
<         getDay = useUTC ? 'getUTCDay' : 'getDay';
<         getDate = useUTC ? 'getUTCDate' : 'getDate';
<         getMonth = useUTC ? 'getUTCMonth' : 'getMonth';
<         getFullYear = useUTC ? 'getUTCFullYear' : 'getFullYear';
<         setMinutes = useUTC ? 'setUTCMinutes' : 'setMinutes';
<         setHours = useUTC ? 'setUTCHours' : 'setHours';
<         setDate = useUTC ? 'setUTCDate' : 'setDate';
<         setMonth = useUTC ? 'setUTCMonth' : 'setMonth';
<         setFullYear = useUTC ? 'setUTCFullYear' : 'setFullYear';
---
> 	makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
> 		return new Date(
> 			year, 
> 			month, 
> 			pick(date, 1), 
> 			pick(hours, 0), 
> 			pick(minutes, 0), 
> 			pick(seconds, 0)
> 		).getTime();
> 	};
> 	getMinutes = useUTC ? 'getUTCMinutes' : 'getMinutes';
> 	getHours = useUTC ? 'getUTCHours' : 'getHours';
> 	getDay = useUTC ? 'getUTCDay' : 'getDay';
> 	getDate = useUTC ? 'getUTCDate' : 'getDate';
> 	getMonth = useUTC ? 'getUTCMonth' : 'getMonth';
> 	getFullYear = useUTC ? 'getUTCFullYear' : 'getFullYear';
> 	setMinutes = useUTC ? 'setUTCMinutes' : 'setMinutes';
> 	setHours = useUTC ? 'setUTCHours' : 'setHours';
> 	setDate = useUTC ? 'setUTCDate' : 'setDate';
> 	setMonth = useUTC ? 'setUTCMonth' : 'setMonth';
> 	setFullYear = useUTC ? 'setUTCFullYear' : 'setFullYear';
819c810
<     }
---
> }
821c812
<     /**
---
> /**
825,826c816,817
<     function setOptions(options) {
<         defaultOptions = merge(defaultOptions, options);
---
> function setOptions(options) {
> 	defaultOptions = merge(defaultOptions, options);
828,829c819,820
<         // apply UTC
<         setTimeMethods();
---
> 	// apply UTC
> 	setTimeMethods();
831,832c822,823
<         return defaultOptions;
<     }
---
> 	return defaultOptions;
> }
834c825
<     /**
---
> /**
838,840c829,831
<     function getOptions() {
<         return defaultOptions;
<     }
---
> function getOptions() {
> 	return defaultOptions;
> }
842c833
<     /**
---
> /**
846,857c837,848
<     function discardElement(element) {
<         // create a garbage bin element, not part of the DOM
<         if (!garbageBin) {
<             garbageBin = createElement(DIV);
<         }
< 	
<         // move the node and empty bin
<         if (element) {
<             garbageBin.appendChild(element);
<         }
<         garbageBin.innerHTML = '';
<     }
---
> function discardElement(element) {
> 	// create a garbage bin element, not part of the DOM
> 	if (!garbageBin) {
> 		garbageBin = createElement(DIV);
> 	}
> 	
> 	// move the node and empty bin
> 	if (element) {
> 		garbageBin.appendChild(element);
> 	}
> 	garbageBin.innerHTML = '';
> }
859c850
<     /* ****************************************************************************
---
> /* ****************************************************************************
862c853
<     var
---
> var 
864,870c855,861
<     defaultLabelOptions = {
<         enabled: true,
<         // rotation: 0,
<         align: 'center',
<         x: 0,
<         y: 15,
<         /*formatter: function() {
---
> defaultLabelOptions = {
> 	enabled: true,
> 	// rotation: 0,
> 	align: 'center',
> 	x: 0,
> 	y: 15,
> 	/*formatter: function() {
873,1282c864,1273
<         style: {
<             color: '#666',
<             fontSize: '11px',
<             lineHeight: '14px'
<         }
<     };
< 
<     defaultOptions = {
<         colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
<         '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
<         symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
<         lang: {
<             loading: 'Loading...',
<             months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
<             'August', 'September', 'October', 'November', 'December'],
<             weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
<             decimalPoint: '.',
<             resetZoom: 'Reset zoom',
<             resetZoomTitle: 'Reset zoom level 1:1',
<             thousandsSep: ','
<         },
<         global: {
<             useUTC: true
<         },
<         chart: {
<             //animation: true,
<             //alignTicks: false,
<             //reflow: true,
<             //className: null,
<             //events: { load, selection },
<             //margin: [null],
<             //marginTop: null,
<             //marginRight: null,
<             //marginBottom: null,
<             //marginLeft: null,
<             borderColor: '#4572A7',
<             //borderWidth: 0,
<             borderRadius: 5,
<             defaultSeriesType: 'line',
<             ignoreHiddenSeries: true,
<             //inverted: false,
<             //shadow: false,
<             spacingTop: 10,
<             spacingRight: 10,
<             spacingBottom: 15,
<             spacingLeft: 10,
<             style: {
<                 fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
<                 fontSize: '12px'
<             },
<             backgroundColor: '#FFFFFF',
<             //plotBackgroundColor: null,
<             plotBorderColor: '#C0C0C0'
<         //plotBorderWidth: 0,
<         //plotShadow: false,
<         //zoomType: ''
<         },
<         title: {
<             text: 'Chart title',
<             align: 'center',
<             // floating: false,
<             // margin: 15,
<             // x: 0,
<             // verticalAlign: 'top',
<             y: 15, // docs
<             style: {
<                 color: '#3E576F',
<                 fontSize: '16px'
<             }
< 
<         },
<         subtitle: {
<             text: '',
<             align: 'center',
<             // floating: false
<             // x: 0,
<             // verticalAlign: 'top',
<             y: 30, // docs
<             style: {
<                 color: '#6D869F'
<             }
<         },
< 	
<         plotOptions: {
<             line: { // base series options
<                 allowPointSelect: false,
<                 showCheckbox: false,
<                 animation: {
<                     duration: 1000
<                 },
<                 // connectNulls: false, // docs
<                 //cursor: 'default',
<                 //dashStyle: null,
<                 //enableMouseTracking: true,
<                 events: {},
<                 //legendIndex: 0, // docs (+ pie points)
<                 lineWidth: 2,
<                 shadow: true,
<                 // stacking: null,
<                 marker: {
<                     enabled: true,
<                     //symbol: null,
<                     lineWidth: 0,
<                     radius: 4,
<                     lineColor: '#FFFFFF',
<                     //fillColor: null,
<                     states: { // states for a single point
<                         hover: {
<                         //radius: base + 2
<                         },
<                         select: {
<                             fillColor: '#FFFFFF',
<                             lineColor: '#000000',
<                             lineWidth: 2
<                         }
<                     }
<                 },
<                 point: {
<                     events: {}
<                 },
<                 dataLabels: merge(defaultLabelOptions, {
<                     enabled: false,
<                     y: -6,
<                     formatter: function() {
<                         return this.y;
<                     }
<                 }),
< 			
<                 //pointStart: 0,
<                 //pointInterval: 1,
<                 showInLegend: true,
<                 states: { // states for the entire series
<                     hover: {
<                         //enabled: false,
<                         //lineWidth: base + 1,
<                         marker: {
<                     // lineWidth: base + 1,
<                     // radius: base + 1
<                     }
<                     },
<                     select: {
<                         marker: {}
<                     }
<                 },
<                 stickyTracking: true
<             //zIndex: null
<             }
<         },
<         labels: {
<             //items: [],
<             style: {
<                 //font: defaultFont,
<                 position: ABSOLUTE,
<                 color: '#3E576F'
<             }
<         },
<         legend: {
<             enabled: true,
<             align: 'center',
<             //floating: false,
<             layout: 'horizontal',
<             labelFormatter: function() {
<                 return this.name;
<             },
<             // lineHeight: 16, // docs: deprecated
<             borderWidth: 1,
<             borderColor: '#909090',
<             borderRadius: 5,
<             // margin: 10,
<             // reversed: false,
<             shadow: false,
<             // backgroundColor: null,
<             style: {
<                 padding: '5px'
<             },
<             itemStyle: {
<                 cursor: 'pointer',
<                 color: '#3E576F'
<             },
<             itemHoverStyle: {
<                 cursor: 'pointer',
<                 color: '#000000'
<             },
<             itemHiddenStyle: {
<                 color: '#C0C0C0'
<             },
<             itemCheckboxStyle: {
<                 position: ABSOLUTE,
<                 width: '13px', // for IE precision
<                 height: '13px'
<             },
<             // itemWidth: undefined,
<             symbolWidth: 16,
<             symbolPadding: 5,
<             verticalAlign: 'bottom',
<             // width: undefined,
<             x: 0, // docs
<             y: 0 // docs
<         },
< 	
<         loading: {
<             hideDuration: 100,
<             labelStyle: {
<                 fontWeight: 'bold',
<                 position: RELATIVE,
<                 top: '1em'
<             },
<             showDuration: 100,
<             style: {
<                 position: ABSOLUTE,
<                 backgroundColor: 'white',
<                 opacity: 0.5,
<                 textAlign: 'center'
<             }
<         },
< 	
<         tooltip: {
<             enabled: true,
<             //crosshairs: null,
<             backgroundColor: 'rgba(255, 255, 255, .85)',
<             borderWidth: 2,
<             borderRadius: 5,
<             //formatter: defaultFormatter,
<             shadow: true,
<             //shared: false,
<             snap: hasTouch ? 25 : 10,
<             style: {
<                 color: '#333333',
<                 fontSize: '12px',
<                 padding: '5px',
<                 whiteSpace: 'nowrap'
<             }
<         },
< 	
<         toolbar: {
<             itemStyle: {
<                 color: '#4572A7',
<                 cursor: 'pointer'
<             }
<         },
< 	
<         credits: {
<             enabled: true,
<             text: 'Highcharts.com',
<             href: 'http://www.highcharts.com',
<             position: {
<                 align: 'right',
<                 x: -10,
<                 verticalAlign: 'bottom',
<                 y: -5
<             },
<             style: {
<                 cursor: 'pointer',
<                 color: '#909090',
<                 fontSize: '10px'
<             }
<         }
<     };
< 
<     // Axis defaults
<     var defaultXAxisOptions =  {
<         // allowDecimals: null,
<         // alternateGridColor: null,
<         // categories: [],
<         dateTimeLabelFormats: {
<             second: '%H:%M:%S',
<             minute: '%H:%M',
<             hour: '%H:%M',
<             day: '%e. %b',
<             week: '%e. %b',
<             month: '%b \'%y',
<             year: '%Y'
<         },
<         endOnTick: false,
<         gridLineColor: '#C0C0C0',
<         // gridLineDashStyle: 'solid', // docs
<         // gridLineWidth: 0,
<         // reversed: false,
< 	
<         labels: defaultLabelOptions,
<         // { step: null },
<         lineColor: '#C0D0E0',
<         lineWidth: 1,
<         //linkedTo: null,
<         max: null,
<         min: null,
<         minPadding: 0.01,
<         maxPadding: 0.01,
<         //maxZoom: null,
<         minorGridLineColor: '#E0E0E0',
<         // minorGridLineDashStyle: null,
<         minorGridLineWidth: 1,
<         minorTickColor: '#A0A0A0',
<         //minorTickInterval: null,
<         minorTickLength: 2,
<         minorTickPosition: 'outside', // inside or outside
<         //minorTickWidth: 0,
<         //opposite: false,
<         //offset: 0,
<         //plotBands: [{
<         //	events: {},
<         //	zIndex: 1,
<         //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
<         //}],
<         //plotLines: [{
<         //	events: {}
<         //  dashStyle: {}
<         //	zIndex:
<         //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
<         //}],
<         //reversed: false,
<         // showFirstLabel: true,
<         // showLastLabel: false,
<         startOfWeek: 1,
<         startOnTick: false,
<         tickColor: '#C0D0E0',
<         //tickInterval: null,
<         tickLength: 5,
<         tickmarkPlacement: 'between', // on or between
<         tickPixelInterval: 100,
<         tickPosition: 'outside',
<         tickWidth: 1,
<         title: {
<             //text: null,
<             align: 'middle', // low, middle or high
<             //margin: 0 for horizontal, 10 for vertical axes,
<             //rotation: 0,
<             //side: 'outside',
<             style: {
<                 color: '#6D869F',
<                 //font: defaultFont.replace('normal', 'bold')
<                 fontWeight: 'bold'
<             }
<         //x: 0,
<         //y: 0
<         },
<         type: 'linear' // linear, logarithmic or datetime // docs
<     },
< 
<     defaultYAxisOptions = merge(defaultXAxisOptions, {
<         endOnTick: true,
<         gridLineWidth: 1,
<         tickPixelInterval: 72,
<         showLastLabel: true,
<         labels: {
<             align: 'right',
<             x: -8,
<             y: 3
<         },
<         lineWidth: 0,
<         maxPadding: 0.05,
<         minPadding: 0.05,
<         startOnTick: true,
<         tickWidth: 0,
<         title: {
<             rotation: 270,
<             text: 'Y-values'
<         },
<         stackLabels: {
<             enabled: false,
<             //align: dynamic,
<             //y: dynamic,
<             //x: dynamic,
<             //verticalAlign: dynamic,
<             //textAlign: dynamic,
<             //rotation: 0,
<             formatter: function() {
<                 return this.total;
<             },
<             style: defaultLabelOptions.style
<         }
<     }),
< 
<     defaultLeftAxisOptions = {
<         labels: {
<             align: 'right',
<             x: -8,
<             y: null // docs
<         },
<         title: {
<             rotation: 270
<         }
<     },
<     defaultRightAxisOptions = {
<         labels: {
<             align: 'left',
<             x: 8,
<             y: null // docs
<         },
<         title: {
<             rotation: 90
<         }
<     },
<     defaultBottomAxisOptions = { // horizontal axis
<         labels: {
<             align: 'center',
<             x: 0,
<             y: 14
<         // staggerLines: null
<         },
<         title: {
<             rotation: 0
<         }
<     },
<     defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
<         labels: {
<             y: -5
<         // staggerLines: null
<         }
<     });
---
> 	style: {
> 		color: '#666',
> 		fontSize: '11px',
> 		lineHeight: '14px'
> 	}
> };
> 
> defaultOptions = {
> 	colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE', 
> 		'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
> 	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
> 	lang: {
> 		loading: 'Loading...',
> 		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 
> 				'August', 'September', 'October', 'November', 'December'],
> 		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
> 		decimalPoint: '.',
> 		resetZoom: 'Reset zoom',
> 		resetZoomTitle: 'Reset zoom level 1:1',
> 		thousandsSep: ','
> 	},
> 	global: {
> 		useUTC: true
> 	},
> 	chart: {
> 		//animation: true,
> 		//alignTicks: false,
> 		//reflow: true,
> 		//className: null,
> 		//events: { load, selection },
> 		//margin: [null],
> 		//marginTop: null,
> 		//marginRight: null,
> 		//marginBottom: null,
> 		//marginLeft: null,
> 		borderColor: '#4572A7',
> 		//borderWidth: 0,
> 		borderRadius: 5,		
> 		defaultSeriesType: 'line',
> 		ignoreHiddenSeries: true,
> 		//inverted: false,
> 		//shadow: false,
> 		spacingTop: 10,
> 		spacingRight: 10,
> 		spacingBottom: 15,
> 		spacingLeft: 10,
> 		style: {
> 			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
> 			fontSize: '12px'
> 		},
> 		backgroundColor: '#FFFFFF',
> 		//plotBackgroundColor: null,
> 		plotBorderColor: '#C0C0C0'
> 		//plotBorderWidth: 0,
> 		//plotShadow: false,
> 		//zoomType: ''
> 	},
> 	title: {
> 		text: 'Chart title',
> 		align: 'center',
> 		// floating: false,
> 		// margin: 15,
> 		// x: 0,
> 		// verticalAlign: 'top',
> 		y: 15, // docs
> 		style: {
> 			color: '#3E576F',
> 			fontSize: '16px'
> 		}
> 
> 	},
> 	subtitle: {
> 		text: '',
> 		align: 'center',
> 		// floating: false
> 		// x: 0,
> 		// verticalAlign: 'top',
> 		y: 30, // docs
> 		style: {
> 			color: '#6D869F'
> 		}
> 	},
> 	
> 	plotOptions: {
> 		line: { // base series options
> 			allowPointSelect: false,
> 			showCheckbox: false,
> 			animation: {
> 				duration: 1000
> 			},
> 			// connectNulls: false, // docs
> 			//cursor: 'default',
> 			//dashStyle: null,
> 			//enableMouseTracking: true,
> 			events: {},
> 			//legendIndex: 0, // docs (+ pie points)
> 			lineWidth: 2,
> 			shadow: true,
> 			// stacking: null,
> 			marker: { 
> 				enabled: true,
> 				//symbol: null, 
> 				lineWidth: 0,
> 				radius: 4,
> 				lineColor: '#FFFFFF',
> 				//fillColor: null, 
> 				states: { // states for a single point
> 					hover: {
> 						//radius: base + 2
> 					},
> 					select: {
> 						fillColor: '#FFFFFF',
> 						lineColor: '#000000',
> 						lineWidth: 2
> 					}					
> 				}
> 			},
> 			point: {
> 				events: {}
> 			},
> 			dataLabels: merge(defaultLabelOptions, {
> 				enabled: false,
> 				y: -6,
> 				formatter: function() {
> 					return this.y;
> 				}
> 			}),
> 			
> 			//pointStart: 0,
> 			//pointInterval: 1,
> 			showInLegend: true,
> 			states: { // states for the entire series
> 				hover: {
> 					//enabled: false,
> 					//lineWidth: base + 1,
> 					marker: {
> 						// lineWidth: base + 1,
> 						// radius: base + 1
> 					}
> 				},
> 				select: {
> 					marker: {}
> 				}
> 			},
> 			stickyTracking: true
> 			//zIndex: null
> 		}
> 	},
> 	labels: {
> 		//items: [],
> 		style: {
> 			//font: defaultFont,
> 			position: ABSOLUTE,
> 			color: '#3E576F'
> 		}
> 	},
> 	legend: {
> 		enabled: true,
> 		align: 'center',
> 		//floating: false,
> 		layout: 'horizontal',
> 		labelFormatter: function() {
> 			return this.name;
> 		},
> 		// lineHeight: 16, // docs: deprecated
> 		borderWidth: 1,
> 		borderColor: '#909090',
> 		borderRadius: 5,
> 		// margin: 10,
> 		// reversed: false,
> 		shadow: false,
> 		// backgroundColor: null,
> 		style: {
> 			padding: '5px'
> 		},
> 		itemStyle: {
> 			cursor: 'pointer',
> 			color: '#3E576F'
> 		},
> 		itemHoverStyle: {
> 			cursor: 'pointer',
> 			color: '#000000'
> 		},
> 		itemHiddenStyle: {
> 			color: '#C0C0C0'
> 		},
> 		itemCheckboxStyle: {
> 			position: ABSOLUTE,
> 			width: '13px', // for IE precision
> 			height: '13px'
> 		},
> 		// itemWidth: undefined,
> 		symbolWidth: 16,
> 		symbolPadding: 5,
> 		verticalAlign: 'bottom',
> 		// width: undefined,
> 		x: 0, // docs
> 		y: 0 // docs
> 	},
> 	
> 	loading: {
> 		hideDuration: 100,
> 		labelStyle: {
> 			fontWeight: 'bold',
> 			position: RELATIVE,
> 			top: '1em'
> 		},
> 		showDuration: 100,
> 		style: {
> 			position: ABSOLUTE,
> 			backgroundColor: 'white',
> 			opacity: 0.5,
> 			textAlign: 'center'
> 		}
> 	},
> 	
> 	tooltip: {
> 		enabled: true,
> 		//crosshairs: null,
> 		backgroundColor: 'rgba(255, 255, 255, .85)',
> 		borderWidth: 2,
> 		borderRadius: 5,
> 		//formatter: defaultFormatter,
> 		shadow: true,
> 		//shared: false,
> 		snap: hasTouch ? 25 : 10,
> 		style: {
> 			color: '#333333',
> 			fontSize: '12px',
> 			padding: '5px',
> 			whiteSpace: 'nowrap'
> 		}
> 	},
> 	
> 	toolbar: {
> 		itemStyle: {
> 			color: '#4572A7',
> 			cursor: 'pointer'
> 		}
> 	},
> 	
> 	credits: {
> 		enabled: true,
> 		text: 'Highcharts.com',
> 		href: 'http://www.highcharts.com',
> 		position: {
> 			align: 'right',
> 			x: -10,
> 			verticalAlign: 'bottom',
> 			y: -5
> 		},
> 		style: {
> 			cursor: 'pointer',
> 			color: '#909090',
> 			fontSize: '10px'
> 		}
> 	}
> };
> 
> // Axis defaults
> var defaultXAxisOptions =  {
> 	// allowDecimals: null,
> 	// alternateGridColor: null,
> 	// categories: [],
> 	dateTimeLabelFormats: {
> 		second: '%H:%M:%S',
> 		minute: '%H:%M',
> 		hour: '%H:%M',
> 		day: '%e. %b',
> 		week: '%e. %b',
> 		month: '%b \'%y',
> 		year: '%Y'
> 	},
> 	endOnTick: false,
> 	gridLineColor: '#C0C0C0',
> 	// gridLineDashStyle: 'solid', // docs
> 	// gridLineWidth: 0,
> 	// reversed: false,
> 	
> 	labels: defaultLabelOptions,
> 		// { step: null },
> 	lineColor: '#C0D0E0',
> 	lineWidth: 1,
> 	//linkedTo: null,
> 	max: null,
> 	min: null,
> 	minPadding: 0.01,
> 	maxPadding: 0.01,
> 	//maxZoom: null,
> 	minorGridLineColor: '#E0E0E0',
> 	// minorGridLineDashStyle: null,
> 	minorGridLineWidth: 1,
> 	minorTickColor: '#A0A0A0',
> 	//minorTickInterval: null,
> 	minorTickLength: 2,
> 	minorTickPosition: 'outside', // inside or outside
> 	//minorTickWidth: 0,
> 	//opposite: false,
> 	//offset: 0,
> 	//plotBands: [{
> 	//	events: {},
> 	//	zIndex: 1,
> 	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
> 	//}],
> 	//plotLines: [{
> 	//	events: {}
> 	//  dashStyle: {}
> 	//	zIndex:
> 	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
> 	//}],
> 	//reversed: false,
> 	// showFirstLabel: true,
> 	// showLastLabel: false,
> 	startOfWeek: 1, 
> 	startOnTick: false,
> 	tickColor: '#C0D0E0',
> 	//tickInterval: null,
> 	tickLength: 5,
> 	tickmarkPlacement: 'between', // on or between
> 	tickPixelInterval: 100,
> 	tickPosition: 'outside',
> 	tickWidth: 1,
> 	title: {
> 		//text: null,
> 		align: 'middle', // low, middle or high
> 		//margin: 0 for horizontal, 10 for vertical axes,
> 		//rotation: 0,
> 		//side: 'outside',
> 		style: {
> 			color: '#6D869F',
> 			//font: defaultFont.replace('normal', 'bold')
> 			fontWeight: 'bold'
> 		}
> 		//x: 0,
> 		//y: 0
> 	},
> 	type: 'linear' // linear, logarithmic or datetime // docs
> },
> 
> defaultYAxisOptions = merge(defaultXAxisOptions, {
> 	endOnTick: true,
> 	gridLineWidth: 1,
> 	tickPixelInterval: 72,
> 	showLastLabel: true,
> 	labels: {
> 		align: 'right',
> 		x: -8,
> 		y: 3
> 	},
> 	lineWidth: 0,
> 	maxPadding: 0.05,
> 	minPadding: 0.05,
> 	startOnTick: true,
> 	tickWidth: 0,
> 	title: {
> 		rotation: 270,
> 		text: 'Y-values'
> 	},
> 	stackLabels: {
> 		enabled: false,
> 		//align: dynamic,
> 		//y: dynamic,
> 		//x: dynamic,
> 		//verticalAlign: dynamic,
> 		//textAlign: dynamic,
> 		//rotation: 0,
> 		formatter: function() {
> 			return this.total;
> 		},
> 		style: defaultLabelOptions.style
> 	}
> }),
> 
> defaultLeftAxisOptions = {
> 	labels: {
> 		align: 'right',
> 		x: -8,
> 		y: null // docs
> 	},
> 	title: {
> 		rotation: 270
> 	}
> },
> defaultRightAxisOptions = {
> 	labels: {
> 		align: 'left',
> 		x: 8,
> 		y: null // docs
> 	},
> 	title: {
> 		rotation: 90
> 	}
> },
> defaultBottomAxisOptions = { // horizontal axis
> 	labels: {
> 		align: 'center',
> 		x: 0,
> 		y: 14
> 		// staggerLines: null
> 	},
> 	title: {
> 		rotation: 0
> 	}
> },
> defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
> 	labels: {
> 		y: -5
> 		// staggerLines: null
> 	}
> });
1287,1370c1278,1361
<     // Series defaults
<     var defaultPlotOptions = defaultOptions.plotOptions,
<     defaultSeriesOptions = defaultPlotOptions.line;
<     //defaultPlotOptions.line = merge(defaultSeriesOptions);
<     defaultPlotOptions.spline = merge(defaultSeriesOptions);
<     defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
<         lineWidth: 0,
<         states: {
<             hover: {
<                 lineWidth: 0
<             }
<         }
<     });
<     defaultPlotOptions.area = merge(defaultSeriesOptions, {
<         // threshold: 0,
<         // lineColor: null, // overrides color, but lets fillColor be unaltered
<         // fillOpacity: 0.75,
<         // fillColor: null
< 
<         });
<     defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
<     defaultPlotOptions.column = merge(defaultSeriesOptions, {
<         borderColor: '#FFFFFF',
<         borderWidth: 1,
<         borderRadius: 0,
<         //colorByPoint: undefined,
<         groupPadding: 0.2,
<         marker: null, // point options are specified in the base options
<         pointPadding: 0.1,
<         //pointWidth: null,
<         minPointLength: 0,
<         states: {
<             hover: {
<                 brightness: 0.1,
<                 shadow: false
<             },
<             select: {
<                 color: '#C0C0C0',
<                 borderColor: '#000000',
<                 shadow: false
<             }
<         },
<         dataLabels: {
<             y: null,
<             verticalAlign: null
<         }
<     });
<     defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
<         dataLabels: {
<             align: 'left',
<             x: 5,
<             y: 0
<         }
<     });
<     defaultPlotOptions.pie = merge(defaultSeriesOptions, {
<         //dragType: '', // n/a
<         borderColor: '#FFFFFF',
<         borderWidth: 1,
<         center: ['50%', '50%'],
<         colorByPoint: true, // always true for pies
<         dataLabels: {
<             // align: null,
<             // connectorWidth: 1,
<             // connectorColor: '#606060',
<             // connectorPadding: 5,
<             distance: 30,
<             enabled: true,
<             formatter: function() {
<                 return this.point.name;
<             },
<             y: 5
<         },
<         //innerSize: 0,
<         legendType: 'point',
<         marker: null, // point options are specified in the base options
<         size: '75%',
<         showInLegend: false,
<         slicedOffset: 10,
<         states: {
<             hover: {
<                 brightness: 0.1,
<                 shadow: false
<             }
<         }
---
> // Series defaults
> var defaultPlotOptions = defaultOptions.plotOptions, 
> 	defaultSeriesOptions = defaultPlotOptions.line; 
> //defaultPlotOptions.line = merge(defaultSeriesOptions);
> defaultPlotOptions.spline = merge(defaultSeriesOptions);
> defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
> 	lineWidth: 0,
> 	states: {
> 		hover: {
> 			lineWidth: 0
> 		}
> 	}
> });
> defaultPlotOptions.area = merge(defaultSeriesOptions, {
> 	// threshold: 0,
> 	// lineColor: null, // overrides color, but lets fillColor be unaltered
> 	// fillOpacity: 0.75,
> 	// fillColor: null
> 
> });
> defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
> defaultPlotOptions.column = merge(defaultSeriesOptions, {
> 	borderColor: '#FFFFFF',
> 	borderWidth: 1,
> 	borderRadius: 0,
> 	//colorByPoint: undefined,
> 	groupPadding: 0.2,
> 	marker: null, // point options are specified in the base options
> 	pointPadding: 0.1,
> 	//pointWidth: null,
> 	minPointLength: 0, 
> 	states: {
> 		hover: {
> 			brightness: 0.1,
> 			shadow: false
> 		},
> 		select: {
> 			color: '#C0C0C0',
> 			borderColor: '#000000',
> 			shadow: false
> 		}
> 	},
> 	dataLabels: {
> 		y: null,
> 		verticalAlign: null
> 	}
> });
> defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
> 	dataLabels: {
> 		align: 'left',
> 		x: 5,
> 		y: 0
> 	}
> });
> defaultPlotOptions.pie = merge(defaultSeriesOptions, {
> 	//dragType: '', // n/a
> 	borderColor: '#FFFFFF',
> 	borderWidth: 1,
> 	center: ['50%', '50%'],
> 	colorByPoint: true, // always true for pies
> 	dataLabels: {
> 		// align: null,
> 		// connectorWidth: 1,
> 		// connectorColor: '#606060',
> 		// connectorPadding: 5,
> 		distance: 30,
> 		enabled: true,
> 		formatter: function() {
> 			return this.point.name;
> 		},
> 		y: 5
> 	},
> 	//innerSize: 0,
> 	legendType: 'point',
> 	marker: null, // point options are specified in the base options
> 	size: '75%',
> 	showInLegend: false,
> 	slicedOffset: 10,
> 	states: {
> 		hover: {
> 			brightness: 0.1,
> 			shadow: false
> 		}
> 	}
1372c1363
<     });
---
> });
1374,1375c1365,1366
<     // set the default time methods
<     setTimeMethods();
---
> // set the default time methods
> setTimeMethods();
1378c1369
<     /**
---
> /**
1382,1384c1373,1375
<     var Color = function(input) {
<         // declare variables
<         var rgba = [], result;
---
> var Color = function(input) {
> 	// declare variables
> 	var rgba = [], result;
1386c1377
<         /**
---
> 	/**
1390c1381
<         function init(input) {
---
> 	function init(input) {
1392,1404c1383,1395
<             // rgba
<             result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
<             if (result) {
<                 rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
<             }
< 
<             // hex
<             else {
<                 result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
<                 if (result) {
<                     rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
<                 }
<             }
---
> 		// rgba
> 		result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
> 		if (result) {
> 			rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
> 		}
> 
> 		// hex
> 		else {
> 			result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
> 			if (result) {
> 				rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
> 			}
> 		}
1406,1407c1397,1398
<         }
<         /**
---
> 	}
> 	/**
1411,1412c1402,1403
<         function get(format) {
<             var ret;
---
> 	function get(format) {
> 		var ret;
1414,1427c1405,1418
<             // it's NaN if gradient colors on a column chart
<             if (rgba && !isNaN(rgba[0])) {
<                 if (format === 'rgb') {
<                     ret = 'rgb('+ rgba[0] +','+ rgba[1] +','+ rgba[2] +')';
<                 } else if (format === 'a') {
<                     ret = rgba[3];
<                 } else {
<                     ret = 'rgba('+ rgba.join(',') +')';
<                 }
<             } else {
<                 ret = input;
<             }
<             return ret;
<         }
---
> 		// it's NaN if gradient colors on a column chart
> 		if (rgba && !isNaN(rgba[0])) {
> 			if (format === 'rgb') {
> 				ret = 'rgb('+ rgba[0] +','+ rgba[1] +','+ rgba[2] +')';
> 			} else if (format === 'a') {
> 				ret = rgba[3];
> 			} else {
> 				ret = 'rgba('+ rgba.join(',') +')';
> 			}
> 		} else {
> 			ret = input;
> 		}
> 		return ret;
> 	}
1429c1420
<         /**
---
> 	/**
1433,1437c1424,1428
<         function brighten(alpha) {
<             if (isNumber(alpha) && alpha !== 0) {
<                 var i;
<                 for (i = 0; i < 3; i++) {
<                     rgba[i] += pInt(alpha * 255);
---
> 	function brighten(alpha) {
> 		if (isNumber(alpha) && alpha !== 0) {
> 			var i;
> 			for (i = 0; i < 3; i++) {
> 				rgba[i] += pInt(alpha * 255);
1439,1449c1430,1440
<                     if (rgba[i] < 0) {
<                         rgba[i] = 0;
<                     }
<                     if (rgba[i] > 255) {
<                         rgba[i] = 255;
<                     }
<                 }
<             }
<             return this;
<         }
<         /**
---
> 				if (rgba[i] < 0) {
> 					rgba[i] = 0;
> 				}
> 				if (rgba[i] > 255) {
> 					rgba[i] = 255;
> 				}
> 			}
> 		}
> 		return this;
> 	}
> 	/**
1453,1470c1444,8174
<         function setOpacity(alpha) {
<             rgba[3] = alpha;
<             return this;
<         }
< 	
<         // initialize: parse the input
<         init(input);
< 	
<         // public methods
<         return {
<             get: get,
<             brighten: brighten,
<             setOpacity: setOpacity
<         };
<     };
< 
<     /**
<  * A wrapper object for SVG elements 
---
> 	function setOpacity(alpha) {
> 		rgba[3] = alpha;
> 		return this;
> 	}	
> 	
> 	// initialize: parse the input
> 	init(input);
> 	
> 	// public methods
> 	return {
> 		get: get,
> 		brighten: brighten,
> 		setOpacity: setOpacity
> 	};
> };
> 
> /**
>  * A wrapper object for SVG elements 
>  */
> function SVGElement () {}
> 
> SVGElement.prototype = {
> 	/**
> 	 * Initialize the SVG renderer
> 	 * @param {Object} renderer
> 	 * @param {String} nodeName
> 	 */
> 	init: function(renderer, nodeName) {
> 		this.element = doc.createElementNS(SVG_NS, nodeName);
> 		this.renderer = renderer;
> 	},
> 	/**
> 	 * Animate a given attribute
> 	 * @param {Object} params
> 	 * @param {Number} options The same options as in jQuery animation
> 	 * @param {Function} complete Function to perform at the end of animation
> 	 */
> 	animate: function(params, options, complete) {
> 		var animOptions = pick(options, globalAnimation, true);
> 		if (animOptions) {
> 			animOptions = merge(animOptions);
> 			if (complete) { // allows using a callback with the global animation without overwriting it
> 				animOptions.complete = complete;
> 			}
> 			animate(this, params, animOptions);
> 		} else {
> 			this.attr(params);
> 			if (complete) {
> 				complete();
> 			}
> 		}
> 	},
> 	/**
> 	 * Set or get a given attribute
> 	 * @param {Object|String} hash
> 	 * @param {Mixed|Undefined} val
> 	 */
> 	attr: function(hash, val) {
> 		var key, 
> 			value, 
> 			i, 
> 			child,
> 			element = this.element,
> 			nodeName = element.nodeName,
> 			renderer = this.renderer,
> 			skipAttr,
> 			shadows = this.shadows,
> 			hasSetSymbolSize,
> 			ret = this;
> 			
> 		// single key-value pair
> 		if (isString(hash) && defined(val)) {
> 			key = hash;
> 			hash = {};
> 			hash[key] = val;
> 		}
> 		
> 		// used as a getter: first argument is a string, second is undefined
> 		if (isString(hash)) {
> 			key = hash;
> 			if (nodeName === 'circle') {
> 				key = { x: 'cx', y: 'cy' }[key] || key;
> 			} else if (key === 'strokeWidth') {
> 				key = 'stroke-width';
> 			}
> 			ret = attr(element, key) || this[key] || 0;
> 			
> 			if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
> 				ret = parseFloat(ret);
> 			}
> 			
> 		// setter
> 		} else {
> 		
> 			for (key in hash) {
> 				skipAttr = false; // reset
> 				value = hash[key];
> 				
> 				// paths
> 				if (key === 'd') {
> 					if (value && value.join) { // join path
> 						value = value.join(' ');
> 					}					
> 					if (/(NaN| {2}|^$)/.test(value)) {
> 						value = 'M 0 0';
> 					}
> 					this.d = value; // shortcut for animations
> 					
> 				// update child tspans x values
> 				} else if (key === 'x' && nodeName === 'text') { 
> 					for (i = 0; i < element.childNodes.length; i++ ) {
> 						child = element.childNodes[i];
> 						// if the x values are equal, the tspan represents a linebreak
> 						if (attr(child, 'x') === attr(element, 'x')) {
> 							//child.setAttribute('x', value);
> 							attr(child, 'x', value);
> 						}
> 					}
> 					
> 					if (this.rotation) {
> 						attr(element, 'transform', 'rotate('+ this.rotation +' '+ value +' '+
> 							pInt(hash.y || attr(element, 'y')) +')');
> 					}
> 					
> 				// apply gradients
> 				} else if (key === 'fill') {
> 					value = renderer.color(value, element, key);
> 				
> 				// circle x and y
> 				} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
> 					key = { x: 'cx', y: 'cy' }[key] || key;
> 					
> 				// translation and text rotation
> 				} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
> 					this[key] = value;
> 					this.updateTransform();
> 					skipAttr = true;
> 	
> 				// apply opacity as subnode (required by legacy WebKit and Batik)
> 				} else if (key === 'stroke') {
> 					value = renderer.color(value, element, key);
> 					
> 				// emulate VML's dashstyle implementation
> 				} else if (key === 'dashstyle') {
> 					key = 'stroke-dasharray';
> 					value = value && value.toLowerCase();
> 					if (value === 'solid') {
> 						value = NONE;
> 					} else if (value) {
> 						value = value
> 							.replace('shortdashdotdot', '3,1,1,1,1,1,')
> 							.replace('shortdashdot', '3,1,1,1')
> 							.replace('shortdot', '1,1,')
> 							.replace('shortdash', '3,1,')
> 							.replace('longdash', '8,3,')
> 							.replace(/dot/g, '1,3,')
> 							.replace('dash', '4,3,')
> 							.replace(/,$/, '')
> 							.split(','); // ending comma
> 						
> 						i = value.length;
> 						while (i--) {
> 							value[i] = pInt(value[i]) * hash['stroke-width'];
> 						}
> 						
> 						value = value.join(',');
> 					}	
> 					
> 				// special
> 				} else if (key === 'isTracker') {
> 					this[key] = value;
> 				
> 				// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
> 				// is unable to cast them. Test again with final IE9.
> 				} else if (key === 'width') {
> 					value = pInt(value);
> 				
> 				// Text alignment
> 				} else if (key === 'align') {
> 					key = 'text-anchor';
> 					value = { left: 'start', center: 'middle', right: 'end' }[value];
> 				}
> 				
> 				
> 				
> 				// jQuery animate changes case
> 				if (key === 'strokeWidth') {
> 					key = 'stroke-width';
> 				}
> 				
> 				// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)				
> 				if (isWebKit && key === 'stroke-width' && value === 0) {
> 					value = 0.000001;
> 				}
> 				
> 				// symbols
> 				if (this.symbolName && /^(x|y|r|start|end|innerR)/.test(key)) {
> 					
> 					
> 					if (!hasSetSymbolSize) {
> 						this.symbolAttr(hash);
> 						hasSetSymbolSize = true;
> 					}
> 					skipAttr = true;
> 				}
> 				
> 				// let the shadow follow the main element
> 				if (shadows && /^(width|height|visibility|x|y|d)$/.test(key)) {
> 					i = shadows.length;
> 					while (i--) {
> 						attr(shadows[i], key, value);
> 					}					
> 				}
> 				
> 				// validate heights
> 				if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
> 					value = 0;
> 				}
> 				
> 				if (key === 'text') {
> 					// only one node allowed
> 					this.textStr = value;
> 					if (this.added) {
> 						renderer.buildText(this);
> 					}
> 				} else if (!skipAttr) {
> 					//element.setAttribute(key, value);
> 					attr(element, key, value);
> 				}
> 				
> 			}
> 			
> 		}
> 		return ret;
> 	},
> 	
> 	/**
> 	 * If one of the symbol size affecting parameters are changed,
> 	 * check all the others only once for each call to an element's
> 	 * .attr() method
> 	 * @param {Object} hash
> 	 */
> 	symbolAttr: function(hash) {
> 		var wrapper = this;
> 		
> 		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR'], function(key) {
> 			wrapper[key] = pick(hash[key], wrapper[key]);
> 		});
> 		
> 		wrapper.attr({ 
> 			d: wrapper.renderer.symbols[wrapper.symbolName](
> 					mathRound(wrapper.x * 2) / 2, // Round to halves. Issue #274.
> 					mathRound(wrapper.y * 2) / 2, 
> 					wrapper.r, 
> 			{
> 				start: wrapper.start, 
> 				end: wrapper.end,
> 				width: wrapper.width, 
> 				height: wrapper.height,
> 				innerR: wrapper.innerR
> 			})
> 		});
> 	},
> 	
> 	/**
> 	 * Apply a clipping path to this object
> 	 * @param {String} id
> 	 */
> 	clip: function(clipRect) {
> 		return this.attr('clip-path', 'url('+ this.renderer.url +'#'+ clipRect.id +')');
> 	},
> 	
> 	/**
> 	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
> 	 * calculated attributes
> 	 * @param {Number} strokeWidth
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	crisp: function(strokeWidth, x, y, width, height) {
> 		
> 		var wrapper = this,
> 			key,
> 			attr = {},
> 			values = {},
> 			normalizer;
> 			
> 		strokeWidth = strokeWidth || wrapper.strokeWidth || 0;
> 		normalizer = strokeWidth % 2 / 2;
> 
> 		// normalize for crisp edges
> 		values.x = mathFloor(x || wrapper.x || 0) + normalizer;
> 		values.y = mathFloor(y || wrapper.y || 0) + normalizer;
> 		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
> 		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
> 		values.strokeWidth = strokeWidth;
> 		
> 		for (key in values) {
> 			if (wrapper[key] !== values[key]) { // only set attribute if changed
> 				wrapper[key] = attr[key] = values[key];
> 			}
> 		}
> 		
> 		return attr;
> 	},
> 	
> 	/**
> 	 * Set styles for the element
> 	 * @param {Object} styles
> 	 */
> 	css: function(styles) {
> 		var elemWrapper = this,
> 			elem = elemWrapper.element,
> 			textWidth = styles && styles.width && elem.nodeName === 'text',
> 			camelStyles = styles,
> 			n;
> 			
> 		// convert legacy
> 		if (styles && styles.color) {
> 			styles.fill = styles.color;
> 		}
> 		
> 		// save the styles in an object
> 		styles = extend(
> 			elemWrapper.styles,
> 			styles
> 		);
> 		
> 		
> 		// store object
> 		elemWrapper.styles = styles;
> 		
> 		// hyphenate
> 		if (defined(styles)) {
> 			styles = {};
> 			for (n in camelStyles) {
> 				styles[hyphenate(n)] = camelStyles[n];
> 			}
> 		}
> 		
> 		// serialize and set style attribute
> 		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
> 			if (textWidth) {
> 				delete styles.width;
> 			} 
> 			css(elemWrapper.element, styles);	
> 		} else {
> 			elemWrapper.attr({
> 				style: serializeCSS(styles)
> 			});
> 		}	
> 		
> 		
> 		// re-build text
> 		if (textWidth && elemWrapper.added) {
> 			elemWrapper.renderer.buildText(elemWrapper);
> 		}
> 		
> 		return elemWrapper;
> 	},
> 	
> 	/**
> 	 * Add an event listener
> 	 * @param {String} eventType
> 	 * @param {Function} handler
> 	 */
> 	on: function(eventType, handler) {
> 		var fn = handler;
> 		// touch
> 		if (hasTouch && eventType === 'click') {
> 			eventType = 'touchstart';
> 			fn = function(e) {
> 				e.preventDefault();
> 				handler();
> 			};
> 		}
> 		// simplest possible event model for internal use
> 		this.element['on'+ eventType] = fn;
> 		return this;
> 	},
> 	
> 	
> 	/**
> 	 * Move an object and its children by x and y values
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 */
> 	translate: function(x, y) {
> 		return this.attr({
> 			translateX: x,
> 			translateY: y
> 		});
> 	},
> 	
> 	/**
> 	 * Invert a group, rotate and flip
> 	 */
> 	invert: function() {
> 		var wrapper = this;
> 		wrapper.inverted = true;
> 		wrapper.updateTransform();
> 		return wrapper;
> 	},
> 	
> 	/**
> 	 * Private method to update the transform attribute based on internal 
> 	 * properties
> 	 */
> 	updateTransform: function() {
> 		var wrapper = this,
> 			translateX = wrapper.translateX || 0,
> 			translateY = wrapper.translateY || 0,
> 			inverted = wrapper.inverted,
> 			rotation = wrapper.rotation,
> 			transform = [];
> 			
> 		// flipping affects translate as adjustment for flipping around the group's axis
> 		if (inverted) {
> 			translateX += wrapper.attr('width');
> 			translateY += wrapper.attr('height');
> 		}
> 			
> 		// apply translate
> 		if (translateX || translateY) {
> 			transform.push('translate('+ translateX +','+ translateY +')');
> 		}
> 		
> 		// apply rotation
> 		if (inverted) {
> 			transform.push('rotate(90) scale(-1,1)');
> 		} else if (rotation) { // text rotation
> 			transform.push('rotate('+ rotation +' '+ wrapper.x +' '+ wrapper.y +')');
> 		}
> 		
> 		if (transform.length) {
> 			attr(wrapper.element, 'transform', transform.join(' '));
> 		}
> 	},
> 	/**
> 	 * Bring the element to the front
> 	 */
> 	toFront: function() {
> 		var element = this.element;
> 		element.parentNode.appendChild(element);
> 		return this;
> 	},
> 	
> 	
> 	/**
> 	 * Break down alignment options like align, verticalAlign, x and y 
> 	 * to x and y relative to the chart.
> 	 * 
> 	 * @param {Object} alignOptions
> 	 * @param {Boolean} alignByTranslate
> 	 * @param {Object} box The box to align to, needs a width and height
> 	 * 
> 	 */
> 	align: function(alignOptions, alignByTranslate, box) {
> 		var elemWrapper = this;
> 		
> 		if (!alignOptions) { // called on resize
> 			alignOptions = elemWrapper.alignOptions;
> 			alignByTranslate = elemWrapper.alignByTranslate;
> 		} else { // first call on instanciate
> 			elemWrapper.alignOptions = alignOptions;
> 			elemWrapper.alignByTranslate = alignByTranslate;
> 			if (!box) { // boxes other than renderer handle this internally
> 				elemWrapper.renderer.alignedObjects.push(elemWrapper);
> 			}
> 		}
> 		
> 		box = pick(box, elemWrapper.renderer);
> 		
> 		var align = alignOptions.align,
> 			vAlign = alignOptions.verticalAlign,
> 			x = (box.x || 0) + (alignOptions.x || 0), // default: left align
> 			y = (box.y || 0) + (alignOptions.y || 0), // default: top align
> 			attribs = {};
> 			
> 			
> 		// align
> 		if (/^(right|center)$/.test(align)) {
> 			x += (box.width - (alignOptions.width || 0) ) /
> 					{ right: 1, center: 2 }[align];
> 		}
> 		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);
> 		
> 		
> 		// vertical align
> 		if (/^(bottom|middle)$/.test(vAlign)) {
> 			y += (box.height - (alignOptions.height || 0)) /
> 					({ bottom: 1, middle: 2 }[vAlign] || 1);
> 			
> 		}
> 		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);
> 		
> 		// animate only if already placed
> 		elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
> 		elemWrapper.placed = true;
> 		elemWrapper.alignAttr = attribs;
> 		
> 		return elemWrapper;
> 	},
> 	
> 	/**
> 	 * Get the bounding box (width, height, x and y) for the element
> 	 */
> 	getBBox: function() {		
> 		var bBox,
> 			width,
> 			height,
> 			rotation = this.rotation,
> 			rad = rotation * deg2rad;
> 			
> 		try { // fails in Firefox if the container has display: none
> 			// use extend because IE9 is not allowed to change width and height in case 
> 			// of rotation (below)
> 			bBox = extend({}, this.element.getBBox());
> 		} catch(e) {
> 			bBox = { width: 0, height: 0 };
> 		}
> 		width = bBox.width;
> 		height = bBox.height;
> 			
> 		// adjust for rotated text
> 		if (rotation) {
> 			bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
> 			bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
> 		}
> 		
> 		return bBox;
> 	},
> 	
> 	/* *
> 	 * Manually compute width and height of rotated text from non-rotated. Shared by SVG and VML
> 	 * @param {Object} bBox
> 	 * @param {number} rotation
> 	 * /
> 	rotateBBox: function(bBox, rotation) {
> 		var rad = rotation * math.PI * 2 / 360, // radians
> 			width = bBox.width,
> 			height = bBox.height;
> 			
> 		
> 	},*/
> 	
> 	/**
> 	 * Show the element
> 	 */
> 	show: function() {
> 		return this.attr({ visibility: VISIBLE });
> 	},
> 	
> 	/**
> 	 * Hide the element
> 	 */
> 	hide: function() {
> 		return this.attr({ visibility: HIDDEN });
> 	},
> 	
> 	/**
> 	 * Add the element
> 	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
> 	 *    to append the element to the renderer.box.
> 	 */ 
> 	add: function(parent) {
> 	
> 		var renderer = this.renderer,
> 			parentWrapper = parent || renderer,
> 			parentNode = parentWrapper.element || renderer.box,
> 			childNodes = parentNode.childNodes,
> 			element = this.element,
> 			zIndex = attr(element, 'zIndex'),
> 			otherElement,
> 			otherZIndex,
> 			i;
> 			
> 		// mark as inverted
> 		this.parentInverted = parent && parent.inverted;
> 		
> 		// build formatted text
> 		if (this.textStr !== undefined) {
> 			renderer.buildText(this);
> 		}
> 		
> 		// mark the container as having z indexed children
> 		if (zIndex) {
> 			parentWrapper.handleZ = true;
> 			zIndex = pInt(zIndex);
> 		}
> 
> 		// insert according to this and other elements' zIndex
> 		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
> 			for (i = 0; i < childNodes.length; i++) {
> 				otherElement = childNodes[i];
> 				otherZIndex = attr(otherElement, 'zIndex');
> 				if (otherElement !== element && (
> 						// insert before the first element with a higher zIndex
> 						pInt(otherZIndex) > zIndex || 
> 						// if no zIndex given, insert before the first element with a zIndex
> 						(!defined(zIndex) && defined(otherZIndex))  
> 						
> 						)) {
> 					parentNode.insertBefore(element, otherElement);
> 					return this;
> 				}
> 			}
> 		}
> 		
> 		// default: append at the end
> 		parentNode.appendChild(element);
> 		
> 		this.added = true;
> 		
> 		return this;
> 	},
> 
> 	/**
> 	 * Destroy the element and element wrapper
> 	 */
> 	destroy: function() {
> 		var wrapper = this,
> 			element = wrapper.element || {},
> 			shadows = wrapper.shadows,
> 			parentNode = element.parentNode,
> 			key;
> 		
> 		// remove events
> 		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
> 		stop(wrapper); // stop running animations
> 		
> 		// remove element
> 		if (parentNode) {
> 			parentNode.removeChild(element);
> 		}
> 		
> 		// destroy shadows
> 		if (shadows) {
> 			each(shadows, function(shadow) {
> 				parentNode = shadow.parentNode;
> 				if (parentNode) { // the entire chart HTML can be overwritten
> 					parentNode.removeChild(shadow);
> 				}				
> 			});
> 		}
> 		
> 		// remove from alignObjects
> 		erase(wrapper.renderer.alignedObjects, wrapper);
> 				
> 		for (key in wrapper) {
> 			delete wrapper[key];
> 		}
> 		
> 		return null;
> 	},
> 	
> 	/**
> 	 * Empty a group element
> 	 */
> 	empty: function() {
> 		var element = this.element,
> 			childNodes = element.childNodes,
> 			i = childNodes.length;
> 			
> 		while (i--) {
> 			element.removeChild(childNodes[i]);
> 		}
> 	},
> 	
> 	/**
> 	 * Add a shadow to the element. Must be done after the element is added to the DOM
> 	 * @param {Boolean} apply
> 	 */
> 	shadow: function(apply, group) {
> 		var shadows = [],
> 			i,
> 			shadow,
> 			element = this.element,
> 			
> 			// compensate for inverted plot area
> 			transform = this.parentInverted ? '(-1,-1)' : '(1,1)';
> 			
> 		
> 		if (apply) {
> 			for (i = 1; i <= 3; i++) {
> 				shadow = element.cloneNode(0);
> 				attr(shadow, {
> 					'isShadow': 'true',
> 					'stroke': 'rgb(0, 0, 0)',
> 					'stroke-opacity': 0.05 * i,
> 					'stroke-width': 7 - 2 * i,
> 					'transform': 'translate'+ transform,
> 					'fill': NONE
> 				});
> 				
> 				if (group) {
> 					group.element.appendChild(shadow);
> 				} else {
> 					element.parentNode.insertBefore(shadow, element);
> 				}
> 				
> 				shadows.push(shadow);
> 			}
> 			
> 			this.shadows = shadows;
> 		}
> 		return this;
> 	
> 	}
> };
> 
> /**
>  * The default SVG renderer
>  */
> var SVGRenderer = function() {
> 	this.init.apply(this, arguments);
> };
> SVGRenderer.prototype = {
> 	
> 	Element: SVGElement,
> 	
> 	/**
> 	 * Initialize the SVGRenderer
> 	 * @param {Object} container
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 * @param {Boolean} forExport
> 	 */
> 	init: function(container, width, height, forExport) {
> 		var renderer = this,
> 			loc = location,
> 			boxWrapper;
> 					
> 		boxWrapper = renderer.createElement('svg')
> 			.attr({
> 				xmlns: SVG_NS,
> 				version: '1.1'
> 			});
> 		container.appendChild(boxWrapper.element);
> 		
> 		// object properties
> 		renderer.box = boxWrapper.element;
> 		renderer.boxWrapper = boxWrapper;
> 		renderer.alignedObjects = [];
> 		renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, ''); // page url used for internal references
> 		renderer.defs = this.createElement('defs').add();
> 		renderer.forExport = forExport;
> 		
> 		renderer.setSize(width, height, false);
> 		
> 	},
> 	
> 	
> 	/**
> 	 * Create a wrapper for an SVG element
> 	 * @param {Object} nodeName
> 	 */
> 	createElement: function(nodeName) {
> 		var wrapper = new this.Element();
> 		wrapper.init(this, nodeName);
> 		return wrapper;
> 	},
> 	
> 	
> 	/** 
> 	 * Parse a simple HTML string into SVG tspans
> 	 * 
> 	 * @param {Object} textNode The parent text SVG node
> 	 */
> 	buildText: function(wrapper) {
> 		var textNode = wrapper.element,
> 			lines = pick(wrapper.textStr, '').toString()
> 				.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
> 				.replace(/<(i|em)>/g, '<span style="font-style:italic">')
> 				.replace(/<a/g, '<span')
> 				.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
> 				.split(/<br.*?>/g),
> 			childNodes = textNode.childNodes,
> 			styleRegex = /style="([^"]+)"/,
> 			hrefRegex = /href="([^"]+)"/,
> 			parentX = attr(textNode, 'x'),
> 			textStyles = wrapper.styles,
> 			reverse = isFirefox && textStyles && textStyles['-hc-direction'] === 'rtl' && 
> 				!this.forExport && pInt(userAgent.split('Firefox/')[1]) < 4, // issue #38
> 			arr,
> 			width = textStyles && pInt(textStyles.width),
> 			textLineHeight = textStyles && textStyles['line-height'],
> 			lastLine,
> 			GET_COMPUTED_STYLE = 'getComputedStyle',
> 			i = childNodes.length;
> 		
> 		// remove old text
> 		while (i--) {
> 			textNode.removeChild(childNodes[i]);
> 		}
> 		
> 		if (width && !wrapper.added) {
> 			this.box.appendChild(textNode); // attach it to the DOM to read offset width
> 		}
> 		
> 		each(lines, function(line, lineNo) {
> 			var spans, spanNo = 0, lineHeight;
> 			
> 			line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
> 			spans = line.split('|||');
> 			
> 			each(spans, function (span) {
> 				if (span !== '' || spans.length === 1) {
> 					var attributes = {},
> 						tspan = doc.createElementNS(SVG_NS, 'tspan');
> 					if (styleRegex.test(span)) {
> 						attr(
> 							tspan, 
> 							'style', 
> 							span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
> 						);
> 					}
> 					if (hrefRegex.test(span)) {
> 						attr(tspan, 'onclick', 'location.href=\"'+ span.match(hrefRegex)[1] +'\"');
> 						css(tspan, { cursor: 'pointer' });
> 					}
> 					
> 					span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
> 						.replace(/&lt;/g, '<')
> 						.replace(/&gt;/g, '>');
> 					
> 					// issue #38 workaround.
> 					if (reverse) {
> 						arr = [];
> 						i = span.length;
> 						while (i--) {
> 							arr.push(span.charAt(i));
> 						}
> 						span = arr.join('');
> 					}
> 					
> 					// add the text node
> 					tspan.appendChild(doc.createTextNode(span));
> 					
> 					if (!spanNo) { // first span in a line, align it to the left
> 						attributes.x = parentX;
> 					} else {
> 						// Firefox ignores spaces at the front or end of the tspan
> 						attributes.dx = 3; // space
> 					}
> 					
> 					// first span on subsequent line, add the line height
> 					if (!spanNo) {						
> 						if (lineNo) {
> 							
> 							// allow getting the right offset height in exporting in IE
> 							if (!hasSVG && wrapper.renderer.forExport) {
> 								css(tspan, { display: 'block' });
> 							}
> 							
> 							// Webkit and opera sometimes return 'normal' as the line height. In that
> 							// case, webkit uses offsetHeight, while Opera falls back to 18
> 							lineHeight = win[GET_COMPUTED_STYLE] &&
> 								win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height');
> 							
> 							if (!lineHeight || isNaN(lineHeight)) {
> 								lineHeight = textLineHeight || lastLine.offsetHeight || 18;
> 							}
> 							attr(tspan, 'dy', lineHeight);
> 						}
> 						lastLine = tspan; // record for use in next line						
> 					}
> 					
> 					// add attributes
> 					attr(tspan, attributes);
> 					
> 					// append it
> 					textNode.appendChild(tspan);
> 					
> 					spanNo++;
> 					
> 					// check width and apply soft breaks
> 					if (width) {
> 						var words = span.replace(/-/g, '- ').split(' '),
> 							tooLong,
> 							actualWidth,
> 							rest = [];
> 							
> 						while (words.length || rest.length) {
> 							actualWidth = textNode.getBBox().width;
> 							tooLong = actualWidth > width;
> 							if (!tooLong || words.length === 1) { // new line needed
> 								words = rest;
> 								rest = [];
> 								if (words.length) {
> 									tspan = doc.createElementNS(SVG_NS, 'tspan');
> 									attr(tspan, {
> 										dy: textLineHeight || 16,
> 										x: parentX
> 									});
> 									textNode.appendChild(tspan);
> 								
> 									if (actualWidth > width) { // a single word is pressing it out
> 										width = actualWidth;
> 									}
> 								}
> 							} else { // append to existing line tspan
> 								tspan.removeChild(tspan.firstChild);
> 								rest.unshift(words.pop());							
> 							}
> 							if (words.length) {
> 								tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
> 							}
> 						}
> 					}
> 				}
> 			});
> 		});
> 		
> 		
> 	},
> 	
> 	/**
> 	 * Make a straight line crisper by not spilling out to neighbour pixels
> 	 * @param {Array} points
> 	 * @param {Number} width 
> 	 */
> 	crispLine: function(points, width) {
> 		// points format: [M, 0, 0, L, 100, 0]
> 		// normalize to a crisp line
> 		if (points[1] === points[4]) {
> 			points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
> 		}
> 		if (points[2] === points[5]) {
> 			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
> 		}
> 		return points;
> 	},
> 	
> 	
> 	/**
> 	 * Draw a path
> 	 * @param {Array} path An SVG path in array form
> 	 */
> 	path: function (path) {
> 		return this.createElement('path').attr({ 
> 			d: path, 
> 			fill: NONE
> 		});
> 	},
> 	
> 	/**
> 	 * Draw and return an SVG circle
> 	 * @param {Number} x The x position
> 	 * @param {Number} y The y position
> 	 * @param {Number} r The radius
> 	 */
> 	circle: function (x, y, r) {
> 		var attr = isObject(x) ?
> 			x :
> 			{
> 				x: x,
> 				y: y,
> 				r: r
> 			};
> 		
> 		return this.createElement('circle').attr(attr);
> 	},
> 	
> 	/**
> 	 * Draw and return an arc
> 	 * @param {Number} x X position
> 	 * @param {Number} y Y position
> 	 * @param {Number} r Radius
> 	 * @param {Number} innerR Inner radius like used in donut charts
> 	 * @param {Number} start Starting angle
> 	 * @param {Number} end Ending angle
> 	 */
> 	arc: function (x, y, r, innerR, start, end) {
> 		// arcs are defined as symbols for the ability to set 
> 		// attributes in attr and animate
> 		
> 		if (isObject(x)) {
> 			y = x.y;
> 			r = x.r;
> 			innerR = x.innerR;
> 			start = x.start;
> 			end = x.end;
> 			x = x.x;
> 		}
> 		
> 		return this.symbol('arc', x || 0, y || 0, r || 0, {
> 			innerR: innerR || 0,
> 			start: start || 0,
> 			end: end || 0
> 		});
> 	},
> 	
> 	/**
> 	 * Draw and return a rectangle
> 	 * @param {Number} x Left position
> 	 * @param {Number} y Top position
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 * @param {Number} r Border corner radius
> 	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
> 	 */
> 	rect: function (x, y, width, height, r, strokeWidth) {
> 		if (isObject(x)) {
> 			y = x.y;
> 			width = x.width;
> 			height = x.height;
> 			r = x.r;
> 			strokeWidth = x.strokeWidth;
> 			x = x.x;	
> 		}
> 		var wrapper = this.createElement('rect').attr({
> 			rx: r,
> 			ry: r,
> 			fill: NONE
> 		});
> 		
> 		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
> 	},
> 	
> 	/**
> 	 * Resize the box and re-align all aligned elements
> 	 * @param {Object} width
> 	 * @param {Object} height
> 	 * @param {Boolean} animate
> 	 * 
> 	 */
> 	setSize: function(width, height, animate) {
> 		var renderer = this,
> 			alignedObjects = renderer.alignedObjects,
> 			i = alignedObjects.length;
> 		
> 		renderer.width = width;
> 		renderer.height = height;
> 		
> 		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
> 			width: width,
> 			height: height
> 		});		
> 		
> 		while (i--) {
> 			alignedObjects[i].align();
> 		}
> 	},
> 	
> 	/**
> 	 * Create a group
> 	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
> 	 *     This can be used for styling and scripting.
> 	 */
> 	g: function(name) {
> 		return this.createElement('g').attr(
> 			defined(name) && { 'class': PREFIX + name }
> 		);
> 	},
> 	
> 	/**
> 	 * Display an image
> 	 * @param {String} src
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	image: function(src, x, y, width, height) {
> 		var attribs = {
> 				preserveAspectRatio: NONE	
> 			},
> 			elemWrapper;
> 			
> 		// optional properties
> 		if (arguments.length > 1) {
> 			extend(attribs, {
> 				x: x,
> 				y: y,
> 				width: width,
> 				height: height
> 			});
> 		}
> 		
> 		elemWrapper = this.createElement('image').attr(attribs);		
> 		
> 		// set the href in the xlink namespace
> 		if (elemWrapper.element.setAttributeNS) {
> 			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink', 
> 				'href', src);
> 		} else {
> 			// could be exporting in IE
> 			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
> 			elemWrapper.element.setAttribute('hc-svg-href', src);
> 		}
> 			
> 		return elemWrapper;					
> 	},
> 	
> 	/**
> 	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
> 	 * 
> 	 * @param {Object} symbol
> 	 * @param {Object} x
> 	 * @param {Object} y
> 	 * @param {Object} radius
> 	 * @param {Object} options
> 	 */
> 	symbol: function(symbol, x, y, radius, options) {
> 		
> 		var obj,
> 			
> 			// get the symbol definition function
> 			symbolFn = this.symbols[symbol],
> 			
> 			// check if there's a path defined for this symbol
> 			path = symbolFn && symbolFn(
> 				mathRound(x), 
> 				mathRound(y),
> 				radius, 
> 				options
> 			),
> 			
> 			imageRegex = /^url\((.*?)\)$/,
> 			imageSrc,
> 			imageSize;
> 			
> 		if (path) {
> 		
> 			obj = this.path(path);
> 			// expando properties for use in animate and attr
> 			extend(obj, {
> 				symbolName: symbol,
> 				x: x,
> 				y: y,
> 				r: radius
> 			});
> 			if (options) {
> 				extend(obj, options);
> 			}
> 			
> 			
> 		// image symbols
> 		} else if (imageRegex.test(symbol)) {
> 			
> 			var centerImage = function(img, size) {
> 				img.attr({
> 					width: size[0],
> 					height: size[1]
> 				}).translate(
> 					-mathRound(size[0] / 2),
> 					-mathRound(size[1] / 2)
> 				);
> 			};
> 			
> 			imageSrc = symbol.match(imageRegex)[1];
> 			imageSize = symbolSizes[imageSrc];
> 			
> 			// create the image synchronously, add attribs async
> 			obj = this.image(imageSrc)
> 				.attr({
> 					x: x,
> 					y: y
> 				});
> 
> 			if (imageSize) {
> 				centerImage(obj, imageSize);
> 			} else {
> 				// initialize image to be 0 size so export will still function if there's no cached sizes
> 				obj.attr({ width: 0, height: 0 });
> 
> 				// create a dummy JavaScript image to get the width and height  
> 				createElement('img', {
> 					onload: function() {
> 						var img = this;
> 						centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
> 					},
> 					src: imageSrc
> 				});
> 			}
> 				
> 		// default circles
> 		} else {
> 			obj = this.circle(x, y, radius);
> 		}
> 		
> 		return obj;
> 	},
> 	
> 	/**
> 	 * An extendable collection of functions for defining symbol paths.
> 	 */
> 	symbols: {
> 		'square': function (x, y, radius) {
> 			var len = 0.707 * radius;
> 			return [
> 				M, x-len, y-len,
> 				L, x+len, y-len,
> 				x+len, y+len,
> 				x-len, y+len,
> 				'Z'
> 			];
> 		},
> 			
> 		'triangle': function (x, y, radius) {
> 			return [
> 				M, x, y-1.33 * radius,
> 				L, x+radius, y + 0.67 * radius,
> 				x-radius, y + 0.67 * radius,
> 				'Z'
> 			];
> 		},
> 			
> 		'triangle-down': function (x, y, radius) {
> 			return [
> 				M, x, y + 1.33 * radius,
> 				L, x-radius, y-0.67 * radius,
> 				x+radius, y-0.67 * radius,
> 				'Z'
> 			];
> 		},
> 		'diamond': function (x, y, radius) {
> 			return [
> 				M, x, y-radius,
> 				L, x+radius, y,
> 				x, y+radius,
> 				x-radius, y,
> 				'Z'
> 			];
> 		},
> 		'arc': function (x, y, radius, options) {
> 			var start = options.start,
> 				end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
> 				innerRadius = options.innerR,
> 				cosStart = mathCos(start),
> 				sinStart = mathSin(start),
> 				cosEnd = mathCos(end),
> 				sinEnd = mathSin(end),
> 				longArc = options.end - start < mathPI ? 0 : 1;
> 				
> 			return [
> 				M,
> 				x + radius * cosStart,
> 				y + radius * sinStart,
> 				'A', // arcTo
> 				radius, // x radius
> 				radius, // y radius
> 				0, // slanting
> 				longArc, // long or short arc
> 				1, // clockwise
> 				x + radius * cosEnd,
> 				y + radius * sinEnd,
> 				L,				
> 				x + innerRadius * cosEnd, 
> 				y + innerRadius * sinEnd,
> 				'A', // arcTo
> 				innerRadius, // x radius
> 				innerRadius, // y radius
> 				0, // slanting
> 				longArc, // long or short arc
> 				0, // clockwise
> 				x + innerRadius * cosStart,
> 				y + innerRadius * sinStart,
> 				
> 				'Z' // close
> 			];
> 		}
> 	},
> 	
> 	/**
> 	 * Define a clipping rectangle
> 	 * @param {String} id
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	clipRect: function (x, y, width, height) {
> 		var wrapper,
> 			id = PREFIX + idCounter++,
> 			
> 			clipPath = this.createElement('clipPath').attr({
> 				id: id
> 			}).add(this.defs);
> 		
> 		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
> 		wrapper.id = id;
> 		
> 		return wrapper;
> 	},
> 	
> 	
> 	/**
> 	 * Take a color and return it if it's a string, make it a gradient if it's a
> 	 * gradient configuration object
> 	 * 
> 	 * @param {Object} color The color or config object
> 	 */
> 	color: function(color, elem, prop) {
> 		var colorObject,
> 			regexRgba = /^rgba/;
> 		if (color && color.linearGradient) {
> 			var renderer = this,
> 				strLinearGradient = 'linearGradient',
> 				linearGradient = color[strLinearGradient],
> 				id = PREFIX + idCounter++,
> 				gradientObject,
> 				stopColor,
> 				stopOpacity;
> 			gradientObject = renderer.createElement(strLinearGradient).attr({
> 				id: id,
> 				gradientUnits: 'userSpaceOnUse',
> 				x1: linearGradient[0],
> 				y1: linearGradient[1],
> 				x2: linearGradient[2],
> 				y2: linearGradient[3]
> 			}).add(renderer.defs);
> 			
> 			each(color.stops, function(stop) {
> 				if (regexRgba.test(stop[1])) {
> 					colorObject = Color(stop[1]);
> 					stopColor = colorObject.get('rgb');
> 					stopOpacity = colorObject.get('a');
> 				} else {
> 					stopColor = stop[1];
> 					stopOpacity = 1;
> 				}
> 				renderer.createElement('stop').attr({
> 					offset: stop[0],
> 					'stop-color': stopColor,
> 					'stop-opacity': stopOpacity
> 				}).add(gradientObject);
> 			});
> 			
> 			return 'url('+ this.url +'#'+ id +')';
> 			
> 		// Webkit and Batik can't show rgba.
> 		} else if (regexRgba.test(color)) {
> 			colorObject = Color(color);
> 			attr(elem, prop +'-opacity', colorObject.get('a'));
> 			
> 			return colorObject.get('rgb');
> 			
> 			
> 		} else {
> 			return color;
> 		}
> 		
> 	},
> 	
> 		
> 	/**
> 	 * Add text to the SVG object
> 	 * @param {String} str
> 	 * @param {Number} x Left position
> 	 * @param {Number} y Top position
> 	 */
> 	text: function(str, x, y) {
> 		
> 		// declare variables
> 		var defaultChartStyle = defaultOptions.chart.style,
> 			wrapper;
> 	
> 		x = mathRound(pick(x, 0));
> 		y = mathRound(pick(y, 0));
> 		
> 		wrapper = this.createElement('text')
> 			.attr({
> 				x: x,
> 				y: y,
> 				text: str	
> 			})
> 			.css({
> 				'font-family': defaultChartStyle.fontFamily,
> 				'font-size': defaultChartStyle.fontSize
> 			});
> 			
> 		wrapper.x = x;
> 		wrapper.y = y;
> 		return wrapper;
> 	}
> }; // end SVGRenderer
> 
> // general renderer
> Renderer = SVGRenderer;
> 
> 
> 
> /* **************************************************************************** 
>  *                                                                            * 
>  * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
>  *                                                                            *
>  * For applications and websites that don't need IE support, like platform    *
>  * targeted mobile apps and web apps, this code can be removed.               *
>  *                                                                            *
>  *****************************************************************************/
> var VMLRenderer;
> if (!hasSVG) {
> 
> /**
>  * The VML element wrapper.
>  */
> var VMLElement = extendClass( SVGElement, {
> 	
> 	/**
> 	 * Initialize a new VML element wrapper. It builds the markup as a string
> 	 * to minimize DOM traffic.
> 	 * @param {Object} renderer
> 	 * @param {Object} nodeName
> 	 */
> 	init: function(renderer, nodeName) {
> 		var markup =  ['<', nodeName, ' filled="f" stroked="f"'],
> 			style = ['position: ', ABSOLUTE, ';'];
> 		
> 		// divs and shapes need size
> 		if (nodeName === 'shape' || nodeName === DIV) {
> 			style.push('left:0;top:0;width:10px;height:10px;');
> 		}
> 		if (docMode8) {
> 			style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
> 		}
> 		
> 		markup.push(' style="', style.join(''), '"/>');
> 		
> 		// create element with default attributes and style
> 		if (nodeName) {
> 			markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ? 
> 				markup.join('')
> 				: renderer.prepVML(markup);
> 			this.element = createElement(markup);
> 		}
> 		
> 		this.renderer = renderer;
> 	},
> 	
> 	/**
> 	 * Add the node to the given parent
> 	 * @param {Object} parent
> 	 */
> 	add: function(parent) {
> 		var wrapper = this,
> 			renderer = wrapper.renderer,
> 			element = wrapper.element,
> 			box = renderer.box,
> 			inverted = parent && parent.inverted,
> 		
> 			// get the parent node
> 			parentNode = parent ? 
> 				parent.element || parent : 
> 				box;
> 			
> 			
> 		// if the parent group is inverted, apply inversion on all children
> 		if (inverted) { // only on groups
> 			renderer.invertChild(element, parentNode);			
> 		}
> 		
> 		// issue #140 workaround - related to #61 and #74
> 		if (docMode8 && parentNode.gVis === HIDDEN) {
> 			css(element, { visibility: HIDDEN });
> 		}
> 		
> 		// append it
> 		parentNode.appendChild(element);
> 		
> 		// align text after adding to be able to read offset
> 		wrapper.added = true;
> 		if (wrapper.alignOnAdd) {
> 			wrapper.updateTransform();
> 		}		
> 		
> 		return wrapper;
> 	},
> 	
> 	/**
> 	 * Get or set attributes
> 	 */
> 	attr: function(hash, val) {
> 		var key, 
> 			value, 
> 			i, 
> 			element = this.element || {},
> 			elemStyle = element.style,
> 			nodeName = element.nodeName,
> 			renderer = this.renderer,
> 			symbolName = this.symbolName,
> 			childNodes,
> 			hasSetSymbolSize,
> 			shadows = this.shadows,
> 			skipAttr,
> 			ret = this;
> 			
> 		// single key-value pair
> 		if (isString(hash) && defined(val)) {
> 			key = hash;
> 			hash = {};
> 			hash[key] = val;
> 		}
> 		
> 		// used as a getter, val is undefined
> 		if (isString(hash)) {
> 			key = hash;
> 			if (key === 'strokeWidth' || key === 'stroke-width') {
> 				ret = this.strokeweight;
> 			} else {
> 				ret = this[key];
> 			}
> 			
> 		// setter
> 		} else {		
> 			for (key in hash) {
> 				value = hash[key];
> 				skipAttr = false;
> 				
> 				// prepare paths
> 				// symbols
> 				if (symbolName && /^(x|y|r|start|end|width|height|innerR)/.test(key)) {
> 					// if one of the symbol size affecting parameters are changed,
> 					// check all the others only once for each call to an element's
> 					// .attr() method
> 					if (!hasSetSymbolSize) {
> 						this.symbolAttr(hash);						
> 					
> 						hasSetSymbolSize = true;
> 					} 
> 					
> 					skipAttr = true;
> 					
> 				} else if (key === 'd') {
> 					value = value || [];
> 					this.d = value.join(' '); // used in getter for animation
> 					
> 					// convert paths 
> 					i = value.length;
> 					var convertedPath = [];
> 					while (i--) {					
> 						
> 						// Multiply by 10 to allow subpixel precision.
> 						// Substracting half a pixel seems to make the coordinates
> 						// align with SVG, but this hasn't been tested thoroughly
> 						if (isNumber(value[i])) {
> 							convertedPath[i] = mathRound(value[i] * 10) - 5;
> 						}
> 						// close the path
> 						else if (value[i] === 'Z') {
> 							convertedPath[i] = 'x';
> 						} 
> 						else {
> 							convertedPath[i] = value[i];
> 						}
> 						
> 					}
> 					value = convertedPath.join(' ') || 'x';	
> 					element.path = value;
> 			
> 					// update shadows
> 					if (shadows) {
> 						i = shadows.length;
> 						while (i--) {
> 							shadows[i].path = value;
> 						}
> 					}
> 					skipAttr = true;
> 	
> 				// directly mapped to css
> 				} else if (key === 'zIndex' || key === 'visibility') {
> 					
> 					// issue 61 workaround
> 					if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
> 						element.gVis = value;
> 						childNodes = element.childNodes;
> 						i = childNodes.length;
> 						while (i--) {
> 							css(childNodes[i], { visibility: value });
> 						}
> 						if (value === VISIBLE) { // issue 74
> 							value = null;
> 						}
> 					}
> 					
> 					if (value) {
> 						elemStyle[key] = value;
> 					}
> 					
> 					
> 					
> 					skipAttr = true;
> 				
> 				// width and height
> 				} else if (/^(width|height)$/.test(key)) {
> 					
> 										
> 					// clipping rectangle special
> 					if (this.updateClipping) {
> 						this[key] = value;
> 						this.updateClipping();
> 						
> 					} else {
> 						// normal
> 						elemStyle[key] = value;
> 					}
> 					
> 					skipAttr = true;
> 					
> 				// x and y 
> 				} else if (/^(x|y)$/.test(key)) {
> 
> 					this[key] = value; // used in getter
> 					
> 					if (element.tagName === 'SPAN') {
> 						this.updateTransform();
> 					
> 					} else {
> 						elemStyle[{ x: 'left', y: 'top' }[key]] = value;
> 					}
> 					
> 				// class name
> 				} else if (key === 'class') {
> 					// IE8 Standards mode has problems retrieving the className
> 					element.className = value;
> 			
> 				// stroke
> 				} else if (key === 'stroke') {
> 					
> 					value = renderer.color(value, element, key);				
> 						
> 					key = 'strokecolor';
> 					
> 				// stroke width
> 				} else if (key === 'stroke-width' || key === 'strokeWidth') {
> 					element.stroked = value ? true : false;
> 					key = 'strokeweight';
> 					this[key] = value; // used in getter, issue #113
> 					if (isNumber(value)) {
> 						value += PX;
> 					}
> 					
> 				// dashStyle					 
> 				} else if (key === 'dashstyle') {
> 					var strokeElem = element.getElementsByTagName('stroke')[0] ||
> 						createElement(renderer.prepVML(['<stroke/>']), null, null, element);
> 					strokeElem[key] = value || 'solid';
> 					this.dashstyle = value; /* because changing stroke-width will change the dash length
> 						and cause an epileptic effect */ 
> 					skipAttr = true;
> 					
> 				// fill
> 				} else if (key === 'fill') {
> 					
> 					if (nodeName === 'SPAN') { // text color
> 						elemStyle.color = value;
> 					} else {
> 						element.filled = value !== NONE ? true : false;
> 						
> 						value = renderer.color(value, element, key);
> 						
> 						key = 'fillcolor';
> 					}
> 				
> 				// translation for animation
> 				} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'align') {
> 					if (key === 'align') {
> 						key = 'textAlign';
> 					}
> 					this[key] = value;
> 					this.updateTransform();
> 					
> 					skipAttr = true;
> 				}
> 				
> 				// text for rotated and non-rotated elements
> 				else if (key === 'text') {
> 					this.bBox = null;
> 					element.innerHTML = value;
> 					skipAttr = true;
> 				} 
> 				
> 					
> 				// let the shadow follow the main element
> 				if (shadows && key === 'visibility') {
> 					i = shadows.length;
> 					while (i--) {
> 						shadows[i].style[key] = value;
> 					}
> 				}
> 				
> 				
> 				
> 				if (!skipAttr) {
> 					if (docMode8) { // IE8 setAttribute bug
> 						element[key] = value;
> 					} else {
> 						attr(element, key, value);
> 					}
> 				}
> 			}			
> 		}
> 		return ret;
> 	},
> 	
> 	/**
> 	 * Set the element's clipping to a predefined rectangle
> 	 * 
> 	 * @param {String} id The id of the clip rectangle
> 	 */
> 	clip: function(clipRect) {
> 		var wrapper = this,
> 			clipMembers = clipRect.members;
> 			
> 		clipMembers.push(wrapper);
> 		wrapper.destroyClip = function() {
> 			erase(clipMembers, wrapper);
> 		};
> 		return wrapper.css(clipRect.getCSS(wrapper.inverted));
> 	},
> 	
> 	/**
> 	 * Set styles for the element
> 	 * @param {Object} styles
> 	 */
> 	css: function(styles) {
> 		var wrapper = this,
> 			element = wrapper.element,
> 			textWidth = styles && element.tagName === 'SPAN' && styles.width;
> 		
> 		/*if (textWidth) {
> 			extend(styles, {
> 				display: 'block',
> 				whiteSpace: 'normal'
> 			});	
> 		}*/
> 		if (textWidth) {
> 			delete styles.width;
> 			wrapper.textWidth = textWidth;
> 			wrapper.updateTransform();	
> 		}
> 		
> 		wrapper.styles = extend(wrapper.styles, styles);
> 		css(wrapper.element, styles);
> 		
> 		return wrapper;
> 	},
> 	
> 	/**
> 	 * Extend element.destroy by removing it from the clip members array
> 	 */
> 	destroy: function() {
> 		var wrapper = this;
> 		
> 		if (wrapper.destroyClip) {
> 			wrapper.destroyClip();
> 		}
> 		
> 		SVGElement.prototype.destroy.apply(wrapper);
> 	},
> 	
> 	/**
> 	 * Remove all child nodes of a group, except the v:group element
> 	 */
> 	empty: function() {
> 		var element = this.element,
> 			childNodes = element.childNodes,
> 			i = childNodes.length,
> 			node;
> 			
> 		while (i--) {
> 			node = childNodes[i];
> 			node.parentNode.removeChild(node);
> 		}
> 	},
> 	
> 	/**
> 	 * VML override for calculating the bounding box based on offsets
> 	 * 
> 	 * @return {Object} A hash containing values for x, y, width and height
> 	 */
> 	
> 	getBBox: function() {
> 		var wrapper = this,
> 			element = wrapper.element,
> 			bBox = wrapper.bBox;
> 		
> 		if (!bBox) {
> 			// faking getBBox in exported SVG in legacy IE
> 			if (element.nodeName === 'text') {
> 				element.style.position = ABSOLUTE;
> 			}
> 			
> 			bBox = wrapper.bBox = {
> 				x: element.offsetLeft,
> 				y: element.offsetTop,
> 				width: element.offsetWidth,
> 				height: element.offsetHeight
> 			};
> 		}
> 		return bBox;
> 					
> 	},
> 	
> 	/**
> 	 * Add an event listener. VML override for normalizing event parameters.
> 	 * @param {String} eventType
> 	 * @param {Function} handler
> 	 */
> 	on: function(eventType, handler) {
> 		// simplest possible event model for internal use
> 		this.element['on'+ eventType] = function() {
> 			var evt = win.event;
> 			evt.target = evt.srcElement;
> 			handler(evt);
> 		};
> 		return this;
> 	},
> 	
> 	
> 	/**
> 	 * VML override private method to update elements based on internal 
> 	 * properties based on SVG transform
> 	 */
> 	updateTransform: function(hash) { 
> 		// aligning non added elements is expensive
> 		if (!this.added) {
> 			this.alignOnAdd = true;
> 			return;
> 		}
> 		
> 		var wrapper = this,
> 			elem = wrapper.element,
> 			translateX = wrapper.translateX || 0,
> 			translateY = wrapper.translateY || 0,
> 			x = wrapper.x || 0,
> 			y = wrapper.y || 0,
> 			align = wrapper.textAlign || 'left',
> 			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
> 			nonLeft = align && align !== 'left';
> 		
> 		// apply translate
> 		if (translateX || translateY) {
> 			wrapper.css({
> 				marginLeft: translateX,
> 				marginTop: translateY
> 			});
> 		}
> 		
> 		// apply inversion
> 		if (wrapper.inverted) { // wrapper is a group
> 			each(elem.childNodes, function(child) {
> 				wrapper.renderer.invertChild(child, elem);
> 			});
> 		}
> 		
> 		if (elem.tagName === 'SPAN') {
> 			
> 			var width, height,
> 				rotation = wrapper.rotation,
> 				lineHeight,
> 				radians = 0,
> 				costheta = 1,
> 				sintheta = 0,
> 				quad,
> 				textWidth = pInt(wrapper.textWidth),
> 				xCorr = wrapper.xCorr || 0,
> 				yCorr = wrapper.yCorr || 0,
> 				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');
> 				
> 			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed
> 				
> 				if (defined(rotation)) {
> 					radians = rotation * deg2rad; // deg to rad
> 					costheta = mathCos(radians);
> 					sintheta = mathSin(radians);				
> 					 
> 					// Adjust for alignment and rotation.
> 					// Test case: http://highcharts.com/tests/?file=text-rotation
> 					css(elem, {
> 						filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta, 
> 							', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta, 
> 							', sizingMethod=\'auto expand\')'].join('') : NONE
> 					});
> 				}
> 				
> 				width = elem.offsetWidth;
> 				height = elem.offsetHeight;
> 				
> 				// update textWidth
> 				if (width > textWidth) {
> 					css(elem, {
> 						width: textWidth +PX,
> 						display: 'block',
> 						whiteSpace: 'normal'
> 					});
> 					width = textWidth;
> 				}
> 				
> 				// correct x and y
> 				lineHeight = mathRound((pInt(elem.style.fontSize) || 12) * 1.2);
> 				xCorr = costheta < 0 && -width;
> 				yCorr = sintheta < 0 && -height;
> 				
> 				// correct for lineHeight and corners spilling out after rotation
> 				quad = costheta * sintheta < 0;
> 				xCorr += sintheta * lineHeight * (quad ? 1 - alignCorrection : alignCorrection);
> 				yCorr -= costheta * lineHeight * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
> 				
> 				// correct for the length/height of the text
> 				if (nonLeft) {
> 					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
> 					if (rotation) {
> 						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
> 					}
> 					css(elem, {
> 						textAlign: align
> 					});
> 				}
> 				
> 				// record correction
> 				wrapper.xCorr = xCorr;
> 				wrapper.yCorr = yCorr; 
> 			}
> 			
> 			// apply position with correction
> 			css(elem, {
> 				left: x + xCorr,
> 				top: y + yCorr
> 			});
> 			
> 			// record current text transform
> 			wrapper.cTT = currentTextTransform;
> 		}
> 	},
> 	
> 	/**
> 	 * Apply a drop shadow by copying elements and giving them different strokes 
> 	 * @param {Boolean} apply
> 	 */
> 	shadow: function(apply, group) {
> 		var shadows = [],
> 			i,
> 			element = this.element,
> 			renderer = this.renderer,
> 			shadow,
> 			elemStyle = element.style,
> 			markup,
> 			path = element.path;
> 			
> 		// some times empty paths are not strings
> 		if (path && typeof path.value !== 'string') {
> 			path = 'x';
> 		}
> 			
> 		if (apply) {
> 			for (i = 1; i <= 3; i++) {
> 				markup = ['<shape isShadow="true" strokeweight="', ( 7 - 2 * i ) ,
> 					'" filled="false" path="', path,
> 					'" coordsize="100,100" style="', element.style.cssText, '" />'];
> 				shadow = createElement(renderer.prepVML(markup),
> 					null, {
> 						left: pInt(elemStyle.left) + 1,
> 						top: pInt(elemStyle.top) + 1
> 					}
> 				);
> 				
> 				// apply the opacity
> 				markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
> 				createElement(renderer.prepVML(markup), null, null, shadow);				
> 				
> 				
> 				// insert it
> 				if (group) {
> 					group.element.appendChild(shadow);
> 				} else {
> 					element.parentNode.insertBefore(shadow, element);
> 				}
> 				
> 				// record it
> 				shadows.push(shadow);				
> 				
> 			}
> 			
> 			this.shadows = shadows;
> 		}
> 		return this;
> 	
> 	}
> });
> 	
> /**
>  * The VML renderer
>  */
> VMLRenderer = function() {
> 	this.init.apply(this, arguments);
> };
> VMLRenderer.prototype = merge( SVGRenderer.prototype, { // inherit SVGRenderer
> 	
> 	Element: VMLElement,
> 	isIE8: userAgent.indexOf('MSIE 8.0') > -1,
> 	
> 
> 	/**
> 	 * Initialize the VMLRenderer
> 	 * @param {Object} container
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	init: function(container, width, height) {
> 		var renderer = this,
> 			boxWrapper;
> 
> 		renderer.alignedObjects = [];
> 		
> 		boxWrapper = renderer.createElement(DIV);
> 		container.appendChild(boxWrapper.element);
> 		
> 		
> 		// generate the containing box
> 		renderer.box = boxWrapper.element;
> 		renderer.boxWrapper = boxWrapper;
> 		
> 		
> 		renderer.setSize(width, height, false);
> 		
> 		// The only way to make IE6 and IE7 print is to use a global namespace. However,
> 		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
> 		// seems to be to add the xmlns attribute and the behaviour style inline. 
> 		if (!doc.namespaces.hcv) {			
> 			
> 			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');
> 			
> 			// setup default css
> 			doc.createStyleSheet().cssText = 
> 				'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'+
> 				'{ behavior:url(#default#VML); display: inline-block; } ';
> 			
> 		}	
> 	},
> 	
> 	/**
> 	 * Define a clipping rectangle. In VML it is accomplished by storing the values
> 	 * for setting the CSS style to all associated members.
> 	 * 
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	clipRect: function (x, y, width, height) {
> 				
> 		// create a dummy element
> 		var clipRect = this.createElement();
> 		
> 		// mimic a rectangle with its style object for automatic updating in attr
> 		return extend(clipRect, {
> 			members: [],
> 			left: x,
> 			top: y,
> 			width: width,
> 			height: height,
> 			getCSS: function(inverted) {
> 				var rect = this,//clipRect.element.style,
> 					top = rect.top,
> 					left = rect.left,
> 					right = left + rect.width,
> 					bottom = top + rect.height,
> 					ret = {
> 						clip: 'rect('+ 
> 							mathRound(inverted ? left : top) + 'px,'+ 
> 							mathRound(inverted ? bottom : right) + 'px,'+ 
> 							mathRound(inverted ? right : bottom) + 'px,'+ 
> 							mathRound(inverted ? top : left) +'px)'
> 					};
> 					
> 				// issue 74 workaround
> 				if (!inverted && docMode8) {
> 					extend(ret, {
> 						width: right +PX,
> 						height: bottom +PX
> 					});
> 				}
> 				return ret;
> 			},
> 			
> 			// used in attr and animation to update the clipping of all members
> 			updateClipping: function() {
> 				each(clipRect.members, function(member) {
> 					member.css(clipRect.getCSS(member.inverted));
> 				});
> 			}
> 		});
> 		
> 	},
> 	
> 	
> 	/**
> 	 * Take a color and return it if it's a string, make it a gradient if it's a
> 	 * gradient configuration object, and apply opacity.
> 	 * 
> 	 * @param {Object} color The color or config object
> 	 */
> 	color: function(color, elem, prop) {
> 		var colorObject,
> 			regexRgba = /^rgba/,
> 			markup;
> 			
> 		if (color && color.linearGradient) {
> 			
> 			var stopColor, 
> 				stopOpacity,
> 				linearGradient = color.linearGradient,
> 				angle,
> 				color1,
> 				opacity1,
> 				color2,
> 				opacity2;	
> 				
> 			each(color.stops, function(stop, i) {
> 				if (regexRgba.test(stop[1])) {
> 					colorObject = Color(stop[1]);
> 					stopColor = colorObject.get('rgb');
> 					stopOpacity = colorObject.get('a');
> 				} else {
> 					stopColor = stop[1];
> 					stopOpacity = 1;
> 				}
> 				
> 				if (!i) { // first
> 					color1 = stopColor;
> 					opacity1 = stopOpacity;
> 				} else {
> 					color2 = stopColor;
> 					opacity2 = stopOpacity;
> 				}
> 			});
> 			
> 			
> 			
> 			// calculate the angle based on the linear vector
> 			angle = 90  - math.atan(
> 				(linearGradient[3] - linearGradient[1]) / // y vector
> 				(linearGradient[2] - linearGradient[0]) // x vector
> 				) * 180 / mathPI;
> 			
> 			// when colors attribute is used, the meanings of opacity and o:opacity2
> 			// are reversed.
> 			markup = ['<', prop, ' colors="0% ', color1, ',100% ', color2, '" angle="', angle,
> 				'" opacity="', opacity2, '" o:opacity2="', opacity1,
> 				'" type="gradient" focus="100%" />'];
> 			createElement(this.prepVML(markup), null, null, elem);
> 			
> 			
> 		
> 		// if the color is an rgba color, split it and add a fill node
> 		// to hold the opacity component
> 		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {
> 			
> 			colorObject = Color(color);
> 			
> 			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
> 			createElement(this.prepVML(markup), null, null, elem);
> 			
> 			return colorObject.get('rgb');
> 			
> 			
> 		} else {
> 			return color;
> 		}
> 		
> 	},
> 	
> 	/**
> 	 * Take a VML string and prepare it for either IE8 or IE6/IE7. 
> 	 * @param {Array} markup A string array of the VML markup to prepare
> 	 */
> 	prepVML: function(markup) {
> 		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
> 			isIE8 = this.isIE8;
> 	
> 		markup = markup.join('');
> 		
> 		if (isIE8) { // add xmlns and style inline
> 			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
> 			if (markup.indexOf('style="') === -1) {
> 				markup = markup.replace('/>', ' style="'+ vmlStyle +'" />');
> 			} else {
> 				markup = markup.replace('style="', 'style="'+ vmlStyle);
> 			}
> 
> 		} else { // add namespace
> 			markup = markup.replace('<', '<hcv:');
> 		}
> 
> 		return markup;
> 	},
> 	
> 	/**
> 	 * Create rotated and aligned text
> 	 * @param {String} str
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 */
> 	text: function(str, x, y) {
> 		
> 		var defaultChartStyle = defaultOptions.chart.style; 
> 			
> 		return this.createElement('span')
> 			.attr({
> 				text: str,
> 				x: mathRound(x),
> 				y: mathRound(y)
> 			})
> 			.css({
> 				whiteSpace: 'nowrap',
> 				fontFamily: defaultChartStyle.fontFamily,
> 				fontSize: defaultChartStyle.fontSize
> 			});
> 	},
> 	
> 	/**
> 	 * Create and return a path element
> 	 * @param {Array} path
> 	 */
> 	path: function (path) {
> 		// create the shape
> 		return this.createElement('shape').attr({
> 			// subpixel precision down to 0.1 (width and height = 10px)
> 			coordsize: '100 100',
> 			d: path
> 		});
> 	},
> 	
> 	/**
> 	 * Create and return a circle element. In VML circles are implemented as
> 	 * shapes, which is faster than v:oval
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} r
> 	 */
> 	circle: function(x, y, r) {
> 		return this.symbol('circle').attr({ x: x, y: y, r: r});
> 	},
> 	
> 	/**
> 	 * Create a group using an outer div and an inner v:group to allow rotating 
> 	 * and flipping. A simple v:group would have problems with positioning
> 	 * child HTML elements and CSS clip.
> 	 * 
> 	 * @param {String} name The name of the group
> 	 */
> 	g: function(name) {
> 		var wrapper,
> 			attribs;
> 		
> 		// set the class name	
> 		if (name) {
> 			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
> 		}
> 		
> 		// the div to hold HTML and clipping	
> 		wrapper = this.createElement(DIV).attr(attribs);
> 		
> 		return wrapper;
> 	},
> 	
> 	/**
> 	 * VML override to create a regular HTML image
> 	 * @param {String} src
> 	 * @param {Number} x
> 	 * @param {Number} y
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 */
> 	image: function(src, x, y, width, height) {
> 		var obj = this.createElement('img')
> 			.attr({ src: src });
> 			
> 		if (arguments.length > 1) {
> 			obj.css({
> 				left: x,
> 				top: y,
> 				width: width,
> 				height: height
> 			});
> 		}
> 		return obj;
> 	},
> 	
> 	/**
> 	 * VML uses a shape for rect to overcome bugs and rotation problems
> 	 */
> 	rect: function(x, y, width, height, r, strokeWidth) {
> 		
> 		if (isObject(x)) {
> 			y = x.y;
> 			width = x.width;
> 			height = x.height;
> 			r = x.r;
> 			strokeWidth = x.strokeWidth;
> 			x = x.x;
> 		}
> 		var wrapper = this.symbol('rect');
> 		wrapper.r = r;
> 		
> 		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
> 	},
> 	
> 	/**
> 	 * In the VML renderer, each child of an inverted div (group) is inverted
> 	 * @param {Object} element
> 	 * @param {Object} parentNode
> 	 */
> 	invertChild: function(element, parentNode) {
> 		var parentStyle = parentNode.style;
> 			
> 		css(element, { 
> 			flip: 'x',
> 			left: pInt(parentStyle.width) - 10,
> 			top: pInt(parentStyle.height) - 10,
> 			rotation: -90
> 		});
> 	},
> 	
> 	/**
> 	 * Symbol definitions that override the parent SVG renderer's symbols
> 	 * 
> 	 */
> 	symbols: {
> 		// VML specific arc function
> 		arc: function (x, y, radius, options) {
> 			var start = options.start,
> 				end = options.end,
> 				cosStart = mathCos(start),
> 				sinStart = mathSin(start),
> 				cosEnd = mathCos(end),
> 				sinEnd = mathSin(end),
> 				innerRadius = options.innerR,
> 				circleCorrection = 0.07 / radius,
> 				innerCorrection = (innerRadius && 0.1 / innerRadius) || 0;
> 				
> 			if (end - start === 0) { // no angle, don't show it. 
> 				return ['x'];
> 				
> 			//} else if (end - start == 2 * mathPI) { // full circle
> 			} else if (2 * mathPI - end + start < circleCorrection) { // full circle
> 				// empirical correction found by trying out the limits for different radii
> 				cosEnd = - circleCorrection;
> 			} else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
> 				cosEnd = mathCos(start + innerCorrection);
> 			}
> 								
> 			return [
> 				'wa', // clockwise arc to
> 				x - radius, // left
> 				y - radius, // top
> 				x + radius, // right
> 				y + radius, // bottom
> 				x + radius * cosStart, // start x
> 				y + radius * sinStart, // start y
> 				x + radius * cosEnd, // end x
> 				y + radius * sinEnd, // end y
> 				
> 				
> 				'at', // anti clockwise arc to
> 				x - innerRadius, // left
> 				y - innerRadius, // top
> 				x + innerRadius, // right
> 				y + innerRadius, // bottom
> 				x + innerRadius * cosEnd, // start x
> 				y + innerRadius * sinEnd, // start y
> 				x + innerRadius * cosStart, // end x
> 				y + innerRadius * sinStart, // end y
> 				
> 				'x', // finish path
> 				'e' // close
> 			];
> 			
> 		},
> 		// Add circle symbol path. This performs significantly faster than v:oval.
> 		circle: function (x, y, r) {
> 			return [
> 				'wa', // clockwisearcto
> 				x - r, // left
> 				y - r, // top
> 				x + r, // right
> 				y + r, // bottom
> 				x + r, // start x
> 				y,     // start y
> 				x + r, // end x
> 				y,     // end y
> 				//'x', // finish path
> 				'e' // close
> 			];
> 		},
> 		/** 
> 		 * Add rectangle symbol path which eases rotation and omits arcsize problems
> 		 * compared to the built-in VML roundrect shape
> 		 * 
> 		 * @param {Number} left Left position
> 		 * @param {Number} top Top position
> 		 * @param {Number} r Border radius
> 		 * @param {Object} options Width and height
> 		 */
> 		
> 		rect: function (left, top, r, options) {
> 			if (!defined(options)) {
> 				return [];
> 			}
> 			var width = options.width,
> 				height = options.height,
> 				right = left + width,
> 				bottom = top + height;
> 		
> 			r = mathMin(r, width, height);
> 			
> 			return [
> 				M,
> 				left + r, top,
> 				
> 				L,
> 				right - r, top,
> 				'wa',
> 				right - 2 * r, top,
> 				right, top + 2 * r,
> 				right - r, top,
> 				right, top + r,
> 				
> 				L,
> 				right, bottom - r,
> 				'wa',
> 				right - 2 * r, bottom - 2 * r,
> 				right, bottom,
> 				right, bottom - r,
> 				right - r, bottom,
> 				
> 				L,
> 				left + r, bottom,
> 				'wa',
> 				left, bottom - 2 * r,
> 				left + 2 * r, bottom, 
> 				left + r, bottom,
> 				left, bottom - r,
> 				
> 				L,
> 				left, top + r,
> 				'wa',
> 				left, top,
> 				left + 2 * r, top + 2 * r,
> 				left, top + r,
> 				left + r, top,
> 				
> 				
> 				'x',
> 				'e'
> 			];
> 				
> 		}
> 	}
> });
> 
> // general renderer
> Renderer = VMLRenderer;
> }
> /* **************************************************************************** 
>  *                                                                            * 
>  * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
>  *                                                                            *
>  *****************************************************************************/
> 	
> 
> /**
>  * The chart class
>  * @param {Object} options
>  * @param {Function} callback Function to run when the chart has loaded
>  */
> function Chart (options, callback) {
> 	
> 	defaultXAxisOptions = merge(defaultXAxisOptions, defaultOptions.xAxis);
> 	defaultYAxisOptions = merge(defaultYAxisOptions, defaultOptions.yAxis);
> 	defaultOptions.xAxis = defaultOptions.yAxis = null;
> 		
> 	// Handle regular options
> 	options = merge(defaultOptions, options);
> 	
> 	// Define chart variables
> 	var optionsChart = options.chart,
> 		optionsMargin = optionsChart.margin,
> 		margin = isObject(optionsMargin) ?
> 			optionsMargin : 
> 			[optionsMargin, optionsMargin, optionsMargin, optionsMargin],
> 		optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
> 		optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
> 		optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
> 		optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
> 		spacingTop = optionsChart.spacingTop,
> 		spacingRight = optionsChart.spacingRight,
> 		spacingBottom = optionsChart.spacingBottom,
> 		spacingLeft = optionsChart.spacingLeft,
> 		spacingBox, 
> 		chartTitleOptions,
> 		chartSubtitleOptions,
> 		plotTop,
> 		marginRight,
> 		marginBottom,
> 		plotLeft,
> 		axisOffset,
> 		renderTo,
> 		renderToClone,
> 		container,
> 		containerId,
> 		containerWidth,
> 		containerHeight,
> 		chartWidth,
> 		chartHeight,
> 		oldChartWidth,
> 		oldChartHeight,
> 		chartBackground,
> 		plotBackground,
> 		plotBGImage,
> 		plotBorder,
> 		chart = this,
> 		chartEvents = optionsChart.events,
> 		runChartClick = chartEvents && !!chartEvents.click,
> 		eventType,
> 		isInsidePlot, // function
> 		tooltip,
> 		mouseIsDown,
> 		loadingDiv,
> 		loadingSpan,
> 		loadingShown,
> 		plotHeight,
> 		plotWidth,
> 		tracker,
> 		trackerGroup,
> 		placeTrackerGroup,
> 		legend,
> 		legendWidth,
> 		legendHeight,
> 		chartPosition,// = getPosition(container),
> 		hasCartesianSeries = optionsChart.showAxes,
> 		isResizing = 0,
> 		axes = [],
> 		maxTicks, // handle the greatest amount of ticks on grouped axes
> 		series = [], 
> 		inverted,
> 		renderer,
> 		tooltipTick,
> 		tooltipInterval,
> 		hoverX,
> 		drawChartBox, // function
> 		getMargins, // function
> 		resetMargins, // function
> 		setChartSize, // function
> 		resize,
> 		zoom, // function
> 		zoomOut; // function
> 		
> 
> 	/**
> 	 * Create a new axis object
> 	 * @param {Object} chart
> 	 * @param {Object} options
> 	 */
> 	function Axis (chart, options) {
> 
> 		// Define variables
> 		var isXAxis = options.isX,
> 			opposite = options.opposite, // needed in setOptions			
> 			horiz = inverted ? !isXAxis : isXAxis,
> 			side = horiz ? 
> 				(opposite ? 0 /* top */  : 2 /* bottom */) :
> 				(opposite ? 1 /* right*/ : 3 /* left */  ),
> 			stacks = {};
> 			
> 	
> 		options = merge(
> 				isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
> 				[defaultTopAxisOptions, defaultRightAxisOptions, 
> 					defaultBottomAxisOptions, defaultLeftAxisOptions][side],
> 				options
> 			);
> 	
> 		var axis = this,
> 			type = options.type,
> 			isDatetimeAxis = type === 'datetime',
> 			isLog = type === 'logarithmic',
> 			offset = options.offset || 0,
> 			xOrY = isXAxis ? 'x' : 'y',
> 			axisLength,
> 			transA, // translation factor
> 			oldTransA, // used for prerendering
> 			transB = horiz ? plotLeft : marginBottom, // translation addend
> 			translate, // fn
> 			getPlotLinePath, // fn
> 			axisGroup,
> 			gridGroup,
> 			axisLine,
> 			dataMin,
> 			dataMax,
> 			associatedSeries,
> 			userMin,
> 			userMax,
> 			max = null,
> 			min = null,
> 			oldMin,
> 			oldMax,
> 			minPadding = options.minPadding,
> 			maxPadding = options.maxPadding,
> 			isLinked = defined(options.linkedTo),
> 			ignoreMinPadding, // can be set to true by a column or bar series
> 			ignoreMaxPadding,
> 			usePercentage,
> 			events = options.events,
> 			eventType,
> 			plotLinesAndBands = [],
> 			tickInterval,
> 			minorTickInterval,
> 			magnitude,
> 			tickPositions, // array containing predefined positions
> 			ticks = {},
> 			minorTicks = {},
> 			alternateBands = {},
> 			tickAmount,
> 			labelOffset,
> 			axisTitleMargin,// = options.title.margin,
> 			dateTimeLabelFormat,
> 			categories = options.categories,
> 			labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
> 				function() {
> 					var value = this.value, 
> 						ret;
> 					
> 					if (dateTimeLabelFormat) { // datetime axis
> 						ret = dateFormat(dateTimeLabelFormat, value);
> 						
> 					} else if (tickInterval % 1000000 === 0) { // use M abbreviation
> 						ret = (value / 1000000) +'M';
> 						
> 					} else if (tickInterval % 1000 === 0) { // use k abbreviation
> 						ret = (value / 1000) +'k';
> 						
> 					} else if (!categories && value >= 1000) { // add thousands separators
> 						ret = numberFormat(value, 0);
> 					
> 					} else { // strings (categories) and small numbers
> 						ret = value;
> 					}
> 					return ret;
> 				},
> 				
> 			staggerLines = horiz && options.labels.staggerLines,
> 			reversed = options.reversed,
> 			tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;		
> 
> 		/**
> 		 * The Tick class
> 		 */
> 		function Tick(pos, minor) {
> 			var tick = this;
> 			tick.pos = pos;
> 			tick.minor = minor;
> 			tick.isNew = true;				
> 			
> 			if (!minor) {
> 				tick.addLabel();
> 			}
> 		}
> 		Tick.prototype = {
> 			/**
> 			 * Write the tick label
> 			 */
> 			addLabel: function() {
> 				var pos = this.pos,
> 					labelOptions = options.labels,
> 					str,
> 					withLabel = !((pos === min && !pick(options.showFirstLabel, 1)) ||
> 						(pos === max && !pick(options.showLastLabel, 0))),
> 					width = (categories && horiz && categories.length && 
> 						!labelOptions.step && !labelOptions.staggerLines &&
> 						!labelOptions.rotation &&
> 						plotWidth / categories.length) ||
> 						(!horiz && plotWidth / 2),
> 					css,
> 					label = this.label;
> 					
> 				
> 				// get the string
> 				str = labelFormatter.call({
> 						isFirst: pos === tickPositions[0],
> 						isLast: pos === tickPositions[tickPositions.length - 1],
> 						dateTimeLabelFormat: dateTimeLabelFormat,
> 						value: (categories && categories[pos] ? categories[pos] : pos)
> 					});
> 				
> 				
> 				// prepare CSS
> 				css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) +PX };
> 				css = extend(css, labelOptions.style);
> 				
> 				// first call
> 				if (label === UNDEFINED) {
> 					this.label =  
> 						defined(str) && withLabel && labelOptions.enabled ?
> 							renderer.text(
> 									str,
> 									0,
> 									0
> 								)
> 								.attr({
> 									align: labelOptions.align,
> 									rotation: labelOptions.rotation
> 								})
> 								// without position absolute, IE export sometimes is wrong
> 								.css(css)
> 								.add(axisGroup):
> 							null;
> 							
> 				// update
> 				} else if (label) {
> 					label.attr({ text: str })
> 						.css(css);
> 				}
> 			},
> 			/**
> 			 * Get the offset height or width of the label
> 			 */
> 			getLabelSize: function() {
> 				var label = this.label;
> 				return label ? 
> 					((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
> 					0;
> 				},
> 			/**
> 			 * Put everything in place
> 			 * 
> 			 * @param index {Number}
> 			 * @param old {Boolean} Use old coordinates to prepare an animation into new position
> 			 */
> 			render: function(index, old) {
> 				var tick = this,
> 					major = !tick.minor,
> 					label = tick.label,
> 					pos = tick.pos,
> 					labelOptions = options.labels,
> 					gridLine = tick.gridLine,
> 					gridLineWidth = major ? options.gridLineWidth : options.minorGridLineWidth,
> 					gridLineColor = major ? options.gridLineColor : options.minorGridLineColor,
> 					dashStyle = major ? 
> 						options.gridLineDashStyle : 
> 						options.minorGridLineDashStyle,
> 					gridLinePath,
> 					mark = tick.mark,
> 					markPath,
> 					tickLength = major ? options.tickLength : options.minorTickLength,
> 					tickWidth = major ? options.tickWidth : (options.minorTickWidth || 0),
> 					tickColor = major ? options.tickColor : options.minorTickColor,
> 					tickPosition = major ? options.tickPosition : options.minorTickPosition,
> 					step = labelOptions.step,
> 					cHeight = (old && oldChartHeight) || chartHeight,
> 					attribs,
> 					x,
> 					y;
> 					
> 				// get x and y position for ticks and labels
> 				x = horiz ? 
> 					translate(pos + tickmarkOffset, null, null, old) + transB : 
> 					plotLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - marginRight - plotLeft : 0);
> 					
> 				y = horiz ?
> 					cHeight - marginBottom + offset - (opposite ? plotHeight : 0) :
> 					cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;
> 					
> 				// create the grid line
> 				if (gridLineWidth) {
> 					gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);
> 					
> 					if (gridLine === UNDEFINED) {
> 						attribs = {
> 							stroke: gridLineColor,
> 							'stroke-width': gridLineWidth
> 						};
> 						if (dashStyle) {
> 							attribs.dashstyle = dashStyle;
> 						}
> 						tick.gridLine = gridLine =
> 							gridLineWidth ?
> 								renderer.path(gridLinePath)
> 									.attr(attribs).add(gridGroup) :
> 								null;
> 					} 
> 					if (gridLine && gridLinePath) {
> 						gridLine.animate({
> 							d: gridLinePath
> 						});
> 					}
> 				}
> 				
> 				// create the tick mark
> 				if (tickWidth) {
> 					
> 					// negate the length
> 					if (tickPosition === 'inside') {
> 						tickLength = -tickLength;
> 					}
> 					if (opposite) {
> 						tickLength = -tickLength;
> 					}
> 			
> 					markPath = renderer.crispLine([
> 						M, 
> 						x, 
> 						y, 
> 						L, 
> 						x + (horiz ? 0 : -tickLength), 
> 						y + (horiz ? tickLength : 0)
> 					], tickWidth);
> 					
> 					if (mark) { // updating
> 						mark.animate({
> 							d: markPath
> 						});
> 					} else { // first time
> 						tick.mark = renderer.path(
> 							markPath
> 						).attr({
> 							stroke: tickColor,
> 							'stroke-width': tickWidth
> 						}).add(axisGroup);
> 					}
> 				}
> 				
> 				// the label is created on init - now move it into place
> 				if (label && !isNaN(x)) {
> 					x = x + labelOptions.x - (tickmarkOffset && horiz ? 
> 						tickmarkOffset * transA * (reversed ? -1 : 1) : 0); 
> 					y = y + labelOptions.y - (tickmarkOffset && !horiz ? 
> 						tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
> 						
> 					// vertically centered
> 					if (!defined(labelOptions.y)) {
> 						y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
> 					}
> 					
> 						
> 					// correct for staggered labels
> 					if (staggerLines) {
> 						y += (index / (step || 1) % staggerLines) * 16;
> 					}
> 					// apply step
> 					if (step) {
> 						// show those indices dividable by step 
> 						label[index % step ? 'hide' : 'show']();
> 					}
> 					
> 					label[tick.isNew ? 'attr' : 'animate']({
> 						x: x,
> 						y: y
> 					});
> 				}
> 				
> 				tick.isNew = false;
> 			},
> 			/**
> 			 * Destructor for the tick prototype
> 			 */
> 			destroy: function() {
> 				var tick = this,
> 					n;
> 				for (n in tick) {
> 					if (tick[n] && tick[n].destroy) {
> 						tick[n].destroy();
> 					}
> 				}
> 			}
> 		};
> 		
> 		/**
> 		 * The object wrapper for plot lines and plot bands
> 		 * @param {Object} options
> 		 */
> 		function PlotLineOrBand(options) {
> 			var plotLine = this;
> 			if (options) {
> 				plotLine.options = options;
> 				plotLine.id = options.id;
> 			}
> 			
> 			//plotLine.render()
> 			return plotLine;
> 		}
> 		
> 		PlotLineOrBand.prototype = {
> 
> 		/**
> 		 * Render the plot line or plot band. If it is already existing,
> 		 * move it.
> 		 */
> 		render: function () {
> 			var plotLine = this,
> 				options = plotLine.options,
> 				optionsLabel = options.label,
> 				label = plotLine.label,
> 				width = options.width,
> 				to = options.to,
> 				toPath, // bands only
> 				from = options.from,
> 				dashStyle = options.dashStyle,
> 				svgElem = plotLine.svgElem,
> 				path = [],
> 				addEvent,
> 				eventType,
> 				xs,
> 				ys,
> 				x,
> 				y,
> 				color = options.color,
> 				zIndex = options.zIndex,
> 				events = options.events,
> 				attribs;
> 			
> 			// plot line
> 			if (width) {
> 				path = getPlotLinePath(options.value, width);
> 				attribs = {
> 					stroke: color,
> 					'stroke-width': width
> 				};
> 				if (dashStyle) {
> 					attribs.dashstyle = dashStyle;
> 				}
> 			}
> 			
> 			// plot band
> 			else if (defined(from) && defined(to)) {
> 				// keep within plot area
> 				from = mathMax(from, min);
> 				to = mathMin(to, max);
> 			
> 				toPath = getPlotLinePath(to);
> 				path = getPlotLinePath(from);
> 				if (path && toPath) {
> 					path.push(
> 						toPath[4],
> 						toPath[5],
> 						toPath[1],
> 						toPath[2]
> 					);
> 				} else { // outside the axis area
> 					path = null;
> 				}
> 				attribs = {
> 					fill: color
> 				};
> 			} else {
> 				return;
> 			}
> 			// zIndex 
> 			if (defined(zIndex)) {
> 				attribs.zIndex = zIndex;
> 			}
> 			
> 			// common for lines and bands
> 			if (svgElem) {
> 				if (path) {
> 					svgElem.animate({
> 						d: path
> 					}, null, svgElem.onGetPath);
> 				} else {
> 					svgElem.hide();
> 					svgElem.onGetPath = function() {
> 						svgElem.show();
> 					};
> 				}
> 			} else if (path && path.length) {
> 				plotLine.svgElem = svgElem = renderer.path(path)
> 					.attr(attribs).add();
> 					
> 				// events
> 				if (events) {
> 					addEvent = function(eventType) {
> 						svgElem.on(eventType, function(e) {
> 							events[eventType].apply(plotLine, [e]);
> 						});
> 					};
> 					for (eventType in events) {
> 						addEvent(eventType);
> 					}
> 				}
> 			}
> 			
> 			// the plot band/line label
> 			if (optionsLabel && defined(optionsLabel.text) && path && path.length && plotWidth > 0 && plotHeight > 0) {
> 				// apply defaults
> 				optionsLabel = merge({
> 					align: horiz && toPath && 'center',
> 					x: horiz ? !toPath && 4 : 10,
> 					verticalAlign : !horiz && toPath && 'middle',
> 					y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
> 					rotation: horiz && !toPath && 90
> 				}, optionsLabel);
> 				
> 				// add the SVG element
> 				if (!label) {
> 					plotLine.label = label = renderer.text(
> 							optionsLabel.text,
> 							0,
> 							0
> 						)
> 						.attr({
> 							align: optionsLabel.textAlign || optionsLabel.align,
> 							rotation: optionsLabel.rotation,
> 							zIndex: zIndex
> 						})
> 						.css(optionsLabel.style)
> 						.add();
> 				}
> 				
> 				// get the bounding box and align the label
> 				xs = [path[1], path[4], pick(path[6], path[1])];
> 				ys = [path[2], path[5], pick(path[7], path[2])];
> 				x = mathMin.apply(math, xs);
> 				y = mathMin.apply(math, ys);
> 				
> 				label.align(optionsLabel, false, {
> 					x: x,
> 					y: y,
> 					width: mathMax.apply(math, xs) - x,
> 					height: mathMax.apply(math, ys) - y
> 				});
> 				label.show();
> 				
> 			} else if (label) { // move out of sight
> 				label.hide();
> 			}
> 			
> 			// chainable
> 			return plotLine;
> 		},
> 		
> 		/**
> 		 * Remove the plot line or band
> 		 */
> 		destroy: function() {
> 			var obj = this,
> 				n;
> 				
> 			for (n in obj) {
> 				if (obj[n] && obj[n].destroy) {
> 					obj[n].destroy(); // destroy SVG wrappers
> 				}
> 				delete obj[n];
> 			}
> 			// remove it from the lookup
> 			erase(plotLinesAndBands, obj);
> 		}
> 		};
> 		
> 		/**
> 		 * The class for stack items
> 		 */
> 		function StackItem(options, isNegative, x) {
> 			var stackItem = this;
> 		
> 			// Tells if the stack is negative 
> 			stackItem.isNegative = isNegative;
> 			
> 			// Save the options to be able to style the label
> 			stackItem.options = options;
> 			
> 			// Save the x value to be able to position the label later
> 			stackItem.x = x;
> 			
> 			// The align options and text align varies on whether the stack is negative and
> 			// if the chart is inverted or not.
> 			// First test the user supplied value, then use the dynamic.
> 			stackItem.alignOptions = {
> 				align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
> 				verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
> 				y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
> 				x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
> 			};
> 			
> 			stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
> 		}
> 		
> 		StackItem.prototype = {
> 			/**
> 			 * Sets the total of this stack. Should be called when a serie is hidden or shown
> 			 * since that will affect the total of other stacks.
> 			 */
> 			setTotal: function(total) {
> 				this.total = total;
> 				this.cum = total;
> 			},
> 
> 			/**
> 			 * Renders the stack total label and adds it to the stack label group.
> 			 */
> 			render: function(group) {
> 				var stackItem = this,									// aliased this
> 					str = stackItem.options.formatter.call(stackItem);	// format the text in the label
> 
> 				// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
> 				if (stackItem.label) {
> 					stackItem.label.attr({text: str, visibility: HIDDEN});
> 				// Create new label
> 				} else {
> 					stackItem.label =
> 						chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
> 							.css(stackItem.options.style)			// apply style
> 							.attr({align: stackItem.textAlign,			// fix the text-anchor
> 								rotation: stackItem.options.rotation,	// rotation
> 								visibility: HIDDEN })					// hidden until setOffset is called
> 							.add(group);							// add to the labels-group
> 				}
> 			},
> 
> 			/**
> 			 * Sets the offset that the stack has from the x value and repositions the label.
> 			 */
> 			setOffset: function(xOffset, xWidth) {
> 				var stackItem = this,										// aliased this
> 					neg = stackItem.isNegative,								// special treatment is needed for negative stacks
> 					y = axis.translate(stackItem.total),					// stack value translated mapped to chart coordinates
> 					yZero = axis.translate(0),								// stack origin
> 					h = mathAbs(y - yZero),									// stack height
> 					x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
> 					plotHeight = chart.plotHeight,
> 					stackBox = {	// this is the box for the complete stack
> 							x: inverted ? (neg ? y : y - h) : x,
> 							y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
> 							width: inverted ? h : xWidth,
> 							height: inverted ? xWidth : h
> 					};
> 				
> 				if (stackItem.label) {
> 					stackItem.label
> 						.align(stackItem.alignOptions, null, stackBox)	// align the label to the box
> 						.attr({visibility: VISIBLE});					// set visibility
> 				}
> 			}
> 		};
> 		
> 		/**
> 		 * Get the minimum and maximum for the series of each axis 
> 		 */
> 		function getSeriesExtremes() {
> 			var posStack = [],
> 				negStack = [],
> 				run;
> 				
> 			// reset dataMin and dataMax in case we're redrawing
> 			dataMin = dataMax = null;
> 			
> 			// get an overview of what series are associated with this axis
> 			associatedSeries = [];
> 			
> 			each(series, function(serie) {
> 				run = false;
> 				
> 				
> 				// match this axis against the series' given or implicated axis
> 				each(['xAxis', 'yAxis'], function(strAxis) {
> 					if (
> 						// the series is a cartesian type, and...
> 						serie.isCartesian &&
> 						// we're in the right x or y dimension, and...
> 						((strAxis === 'xAxis' && isXAxis) || (strAxis === 'yAxis' && !isXAxis)) && (
> 							// the axis number is given in the options and matches this axis index, or
> 							(serie.options[strAxis] === options.index) || 
> 							// the axis index is not given
> 							(serie.options[strAxis] === UNDEFINED && options.index === 0)
> 						)
> 					) {
> 						serie[strAxis] = axis;
> 						associatedSeries.push(serie);
> 						
> 						// the series is visible, run the min/max detection
> 						run = true;		
> 					}
> 				});
> 				// ignore hidden series if opted 
> 				if (!serie.visible && optionsChart.ignoreHiddenSeries) {
> 					run = false;
> 				}				
> 				
> 				if (run) {
> 					
> 					var stacking,
> 						posPointStack,
> 						negPointStack,
> 						stackKey,
> 						negKey;
> 		
> 					if (!isXAxis) {
> 						stacking = serie.options.stacking;
> 						usePercentage = stacking === 'percent';
> 	
> 						// create a stack for this particular series type
> 						if (stacking) {
> 							stackKey = serie.type + pick(serie.options.stack, '');
> 							negKey = '-'+ stackKey;
> 							serie.stackKey = stackKey; // used in translate
> 									
> 							posPointStack = posStack[stackKey] || []; // contains the total values for each x
> 							posStack[stackKey] = posPointStack;
> 							
> 							negPointStack = negStack[negKey] || [];
> 							negStack[negKey] = negPointStack;
> 						}
> 						if (usePercentage) {
> 							dataMin = 0;
> 							dataMax = 99;			
> 						}
> 					} 
> 					if (serie.isCartesian) { // line, column etc. need axes, pie doesn't
> 						each(serie.data, function(point, i) {
> 							var pointX = point.x,
> 								pointY = point.y,
> 								isNegative = pointY < 0, 
> 								pointStack = isNegative ? negPointStack : posPointStack,
> 								key = isNegative ? negKey : stackKey,
> 								totalPos,
> 								pointLow;
> 							
> 							// initial values
> 							if (dataMin === null) {
> 
> 								// start out with the first point
> 								dataMin = dataMax = point[xOrY]; 
> 							}
> 		
> 							// x axis
> 							if (isXAxis) {
> 								if (pointX > dataMax) {
> 									dataMax = pointX;
> 								} else if (pointX < dataMin) {
> 									dataMin = pointX;
> 								}
> 							}
> 							
> 							// y axis
> 							else if (defined(pointY)) {
> 								if (stacking) {
> 									pointStack[pointX] = 
> 										defined(pointStack[pointX]) ? 
> 										pointStack[pointX] + pointY : pointY;
> 								}
> 								totalPos = pointStack ? pointStack[pointX] : pointY;
> 								pointLow = pick(point.low, totalPos);
> 								if (!usePercentage) {
> 									if (totalPos > dataMax) {
> 										dataMax = totalPos;
> 									} else if (pointLow < dataMin) {
> 										dataMin = pointLow;
> 									}
> 								}
> 								if (stacking) {		
> 									// add the series
> 									if (!stacks[key]) {
> 										stacks[key] = {};
> 									}
> 									
> 									// If the StackItem is there, just update the values,
> 									// if not, create one first
> 									if (!stacks[key][pointX]) {
> 										stacks[key][pointX] = new StackItem(options.stackLabels, isNegative, pointX);
> 									}
> 									stacks[key][pointX].setTotal(totalPos);
> 								}
> 							}
> 						});
> 						
> 							
> 						// For column, areas and bars, set the minimum automatically to zero
> 						// and prevent that minPadding is added in setScale
> 						if (/(area|column|bar)/.test(serie.type) && !isXAxis) {
> 							var threshold = 0; // use series.options.threshold?
> 							if (dataMin >= threshold) {
> 								dataMin = threshold;
> 								ignoreMinPadding = true;
> 							} else if (dataMax < threshold) {
> 								dataMax = threshold;
> 								ignoreMaxPadding = true;
> 							}
> 						}
> 					}
> 				}
> 			});
> 			
> 		}
> 	
> 		/**
> 		 * Translate from axis value to pixel position on the chart, or back
> 		 * 
> 		 */
> 		translate = function(val, backwards, cvsCoord, old, handleLog) {
> 			var sign = 1,
> 				cvsOffset = 0,
> 				localA = old ? oldTransA : transA,
> 				localMin = old ? oldMin : min,
> 				returnValue;
> 				
> 			if (!localA) {
> 				localA = transA;
> 			}
> 				
> 			if (cvsCoord) {
> 				sign *= -1; // canvas coordinates inverts the value
> 				cvsOffset = axisLength;
> 			}
> 			if (reversed) { // reversed axis
> 				sign *= -1; 
> 				cvsOffset -= sign * axisLength;
> 			}
> 			
> 			if (backwards) { // reverse translation
> 				if (reversed) {
> 					val = axisLength - val;
> 				}
> 				returnValue = val / localA + localMin; // from chart pixel to value	
> 				if (isLog && handleLog) {
> 					returnValue = lin2log(returnValue);
> 				}			
> 			
> 			} else { // normal translation
> 				if (isLog && handleLog) {
> 					val = log2lin(val);
> 				}
> 				returnValue = sign * (val - localMin) * localA + cvsOffset; // from value to chart pixel
> 			}
> 			
> 			return returnValue;
> 		};
> 		
> 		/**
> 		 * Create the path for a plot line that goes from the given value on 
> 		 * this axis, across the plot to the opposite side
> 		 * @param {Number} value
> 		 * @param {Number} lineWidth Used for calculation crisp line
> 		 * @param {Number] old Use old coordinates (for resizing and rescaling)
> 		 */
> 		getPlotLinePath = function(value, lineWidth, old) {
> 			var x1, 
> 				y1, 
> 				x2, 
> 				y2,
> 				translatedValue = translate(value, null, null, old),
> 				cHeight = (old && oldChartHeight) || chartHeight,
> 				cWidth = (old && oldChartWidth) || chartWidth,
> 				skip;
> 				
> 			x1 = x2 = mathRound(translatedValue + transB);
> 			y1 = y2 = mathRound(cHeight - translatedValue - transB);
> 			
> 			if (isNaN(translatedValue)) { // no min or max
> 				skip = true;
> 			
> 			} else if (horiz) { 
> 				y1 = plotTop;
> 				y2 = cHeight - marginBottom;
> 				if (x1 < plotLeft || x1 > plotLeft + plotWidth) {
> 					skip = true;
> 				}
> 			} else {
> 				x1 = plotLeft;
> 				x2 = cWidth - marginRight;
> 				if (y1 < plotTop || y1 > plotTop + plotHeight) {
> 					skip = true;
> 				}
> 			}
> 			return skip ? 
> 				null : 
> 				renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
> 		};
> 		
> 		
> 		/**
> 		 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
> 		 * @param {Number} interval
> 		 */
> 		function normalizeTickInterval(interval, multiples) {
> 			var normalized, i;
> 				
> 			// round to a tenfold of 1, 2, 2.5 or 5
> 			magnitude = multiples ? 1 : math.pow(10, mathFloor(math.log(interval) / math.LN10));
> 			normalized = interval / magnitude;
> 			
> 			// multiples for a linear scale
> 			if (!multiples) {
> 				multiples = [1, 2, 2.5, 5, 10];
> 				//multiples = [1, 2, 2.5, 4, 5, 7.5, 10];
> 				
> 				// the allowDecimals option
> 				if (options.allowDecimals === false || isLog) {
> 					if (magnitude === 1) {
> 						multiples = [1, 2, 5, 10];
> 					} else if (magnitude <= 0.1) {
> 						multiples = [1 / magnitude];
> 					}					
> 				}
> 			}
> 			
> 			// normalize the interval to the nearest multiple
> 			for (i = 0; i < multiples.length; i++) {
> 				interval = multiples[i];
> 				if (normalized <= (multiples[i] + (multiples[i+1] || multiples[i])) / 2) {
> 					break;
> 				}
> 			}
> 			
> 			// multiply back to the correct magnitude
> 			interval *= magnitude;
> 			
> 			return interval;
> 		}
> 	
> 		/**
> 		 * Set the tick positions to a time unit that makes sense, for example
> 		 * on the first of each month or on every Monday.
> 		 */
> 		function setDateTimeTickPositions() {
> 			tickPositions = [];
> 			var i,
> 				useUTC = defaultOptions.global.useUTC,
> 				oneSecond = 1000 / timeFactor,
> 				oneMinute = 60000 / timeFactor,
> 				oneHour = 3600000 / timeFactor,
> 				oneDay = 24 * 3600000 / timeFactor,
> 				oneWeek = 7 * 24 * 3600000 / timeFactor,
> 				oneMonth = 30 * 24 * 3600000 / timeFactor,
> 				oneYear = 31556952000 / timeFactor,
> 			
> 				units = [[
> 					'second',						// unit name
> 					oneSecond,						// fixed incremental unit
> 					[1, 2, 5, 10, 15, 30]			// allowed multiples
> 				], [
> 					'minute',						// unit name
> 					oneMinute,						// fixed incremental unit
> 					[1, 2, 5, 10, 15, 30]			// allowed multiples
> 				], [
> 					'hour',							// unit name
> 					oneHour,						// fixed incremental unit
> 					[1, 2, 3, 4, 6, 8, 12]			// allowed multiples
> 				], [
> 					'day',							// unit name
> 					oneDay,							// fixed incremental unit
> 					[1, 2]							// allowed multiples
> 				], [
> 					'week',							// unit name
> 					oneWeek,						// fixed incremental unit
> 					[1, 2]							// allowed multiples
> 				], [
> 					'month',
> 					oneMonth,
> 					[1, 2, 3, 4, 6]
> 				], [
> 					'year',
> 					oneYear,
> 					null
> 				]],
> 			
> 				unit = units[6], // default unit is years
> 				interval = unit[1], 
> 				multiples = unit[2];
> 			
> 			// loop through the units to find the one that best fits the tickInterval
> 			for (i = 0; i < units.length; i++)  {
> 				unit = units[i];
> 				interval = unit[1];
> 				multiples = unit[2];
> 				
> 				
> 				if (units[i+1]) {
> 					// lessThan is in the middle between the highest multiple and the next unit.
> 					var lessThan = (interval * multiples[multiples.length - 1] + 
> 								units[i + 1][1]) / 2;
> 							
> 					// break and keep the current unit
> 					if (tickInterval <= lessThan) {
> 						break;
> 					}
> 				}
> 			}
> 			
> 			// prevent 2.5 years intervals, though 25, 250 etc. are allowed
> 			if (interval === oneYear && tickInterval < 5 * interval) {
> 				multiples = [1, 2, 5];
> 			}
> 	
> 			// get the minimum value by flooring the date
> 			var multitude = normalizeTickInterval(tickInterval / interval, multiples),
> 				minYear, // used in months and years as a basis for Date.UTC()
> 				minDate = new Date(min * timeFactor);
> 				
> 			minDate.setMilliseconds(0);
> 			
> 			if (interval >= oneSecond) { // second
> 				minDate.setSeconds(interval >= oneMinute ? 0 :
> 					multitude * mathFloor(minDate.getSeconds() / multitude));
> 			}
> 	
> 			if (interval >= oneMinute) { // minute
> 				minDate[setMinutes](interval >= oneHour ? 0 :
> 					multitude * mathFloor(minDate[getMinutes]() / multitude));
> 			}
> 	
> 			if (interval >= oneHour) { // hour
> 				minDate[setHours](interval >= oneDay ? 0 :
> 					multitude * mathFloor(minDate[getHours]() / multitude));
> 			}
> 	
> 			if (interval >= oneDay) { // day
> 				minDate[setDate](interval >= oneMonth ? 1 :
> 					multitude * mathFloor(minDate[getDate]() / multitude));
> 			}
> 					
> 			if (interval >= oneMonth) { // month
> 				minDate[setMonth](interval >= oneYear ? 0 :
> 					multitude * mathFloor(minDate[getMonth]() / multitude));
> 				minYear = minDate[getFullYear]();
> 			}
> 			
> 			if (interval >= oneYear) { // year
> 				minYear -= minYear % multitude;
> 				minDate[setFullYear](minYear);
> 			}
> 			
> 			// week is a special case that runs outside the hierarchy
> 			if (interval === oneWeek) {
> 				// get start of current week, independent of multitude
> 				minDate[setDate](minDate[getDate]() - minDate[getDay]() + 
> 					options.startOfWeek);
> 			}
> 			
> 			
> 			// get tick positions
> 			i = 1; // prevent crash just in case
> 			minYear = minDate[getFullYear]();
> 			var time = minDate.getTime() / timeFactor,
> 				minMonth = minDate[getMonth](),
> 				minDateDate = minDate[getDate]();
> 				
> 			// iterate and add tick positions at appropriate values
> 			while (time < max && i < plotWidth) {
> 				tickPositions.push(time);
> 				
> 				// if the interval is years, use Date.UTC to increase years
> 				if (interval === oneYear) {
> 					time = makeTime(minYear + i * multitude, 0) / timeFactor;
> 				
> 				// if the interval is months, use Date.UTC to increase months
> 				} else if (interval === oneMonth) {
> 					time = makeTime(minYear, minMonth + i * multitude) / timeFactor;
> 					
> 				// if we're using global time, the interval is not fixed as it jumps
> 				// one hour at the DST crossover
> 				} else if (!useUTC && (interval === oneDay || interval === oneWeek)) {
> 					time = makeTime(minYear, minMonth, minDateDate + 
> 						i * multitude * (interval === oneDay ? 1 : 7));
> 					
> 				// else, the interval is fixed and we use simple addition
> 				} else {
> 					time += interval * multitude;
> 				}
> 				
> 				i++;
> 			}
> 			// push the last time
> 			tickPositions.push(time);
> 			
> 			
> 			// dynamic label formatter 
> 			dateTimeLabelFormat = options.dateTimeLabelFormats[unit[0]];
> 		}
> 			
> 		/**
> 		 * Fix JS round off float errors
> 		 * @param {Number} num
> 		 */
> 		function correctFloat(num) {
> 			var invMag, ret = num;
> 			magnitude = pick(magnitude, math.pow(10, mathFloor(math.log(tickInterval) / math.LN10)));
> 			
> 			if (magnitude < 1) {
> 				invMag = mathRound(1 / magnitude)  * 10;
> 				ret = mathRound(num * invMag) / invMag;
> 			}
> 			return ret;
> 		}
> 				
> 		/**
> 		 * Set the tick positions of a linear axis to round values like whole tens or every five.
> 		 */
> 		function setLinearTickPositions() {
> 			
> 			var i,
> 				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
> 				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval);
> 				
> 			tickPositions = [];
> 			
> 			// populate the intermediate values
> 			i = correctFloat(roundedMin);
> 			while (i <= roundedMax) {
> 				tickPositions.push(i);
> 				i = correctFloat(i + tickInterval);
> 			}
> 			
> 		}
> 		
> 		/**
> 		 * Set the tick positions to round values and optionally extend the extremes
> 		 * to the nearest tick
> 		 */
> 		function setTickPositions(secondPass) {
> 			var length,
> 				catPad,
> 				linkedParent,
> 				linkedParentExtremes,
> 				tickIntervalOption = options.tickInterval,
> 				tickPixelIntervalOption = options.tickPixelInterval,
> 				maxZoom = options.maxZoom || (
> 					isXAxis && !defined(options.min) && !defined(options.max) ? 
> 						mathMin(chart.smallestInterval * 5, dataMax - dataMin) : 
> 						null					
> 				),
> 				zoomOffset;
> 				
> 			
> 			axisLength = horiz ? plotWidth : plotHeight;
> 			
> 			// linked axis gets the extremes from the parent axis
> 			if (isLinked) {
> 				linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
> 				linkedParentExtremes = linkedParent.getExtremes();
> 				min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
> 				max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
> 			}
> 			
> 			// initial min and max from the extreme data values
> 			else {
> 				min = pick(userMin, options.min, dataMin);
> 				max = pick(userMax, options.max, dataMax);
> 			}
> 			
> 			if (isLog) {
> 				min = log2lin(min);
> 				max = log2lin(max);
> 			}
> 			
> 			// maxZoom exceeded, just center the selection
> 			if (max - min < maxZoom) { 
> 				zoomOffset = (maxZoom - max + min) / 2;
> 				// if min and max options have been set, don't go beyond it
> 				min = mathMax(min - zoomOffset, pick(options.min, min - zoomOffset), dataMin);
> 				max = mathMin(min + maxZoom, pick(options.max, min + maxZoom), dataMax);
> 			}
> 				
> 			// pad the values to get clear of the chart's edges
> 			if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
> 				length = (max - min) || 1;
> 				if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) { 
> 					min -= length * minPadding; 
> 				}
> 				if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) { 
> 					max += length * maxPadding;
> 				}
> 			}
> 
> 			// get tickInterval
> 			if (min === max) {
> 				tickInterval = 1;
> 			} else if (isLinked && !tickIntervalOption &&
> 					tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
> 				tickInterval = linkedParent.tickInterval;
> 			} else {
> 				tickInterval = pick(
> 					tickIntervalOption,
> 					categories ? // for categoried axis, 1 is default, for linear axis use tickPix 
> 						1 : 
> 						(max - min) * tickPixelIntervalOption / axisLength
> 				);
> 			}
> 			
> 			if (!isDatetimeAxis && !defined(options.tickInterval)) { // linear
> 				tickInterval = normalizeTickInterval(tickInterval);
> 			}
> 			axis.tickInterval = tickInterval; // record for linked axis
> 			
> 			// get minorTickInterval
> 			minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
> 					tickInterval / 5 : options.minorTickInterval;
> 			
> 			// find the tick positions
> 			if (isDatetimeAxis)	{
> 				setDateTimeTickPositions();
> 			} else {
> 				setLinearTickPositions();
> 			}
> 			
> 			if (!isLinked) {
> 				// pad categorised axis to nearest half unit
> 				if (categories || (isXAxis && chart.hasColumn)) {
> 					catPad = (categories ? 1 : tickInterval) * 0.5;
> 					if (categories || !defined(pick(options.min, userMin))) {
> 						min -= catPad;
> 					}
> 					if (categories || !defined(pick(options.max, userMax))) {
> 						max += catPad;
> 					}
> 				}
> 				
> 				// reset min/max or remove extremes based on start/end on tick
> 				var roundedMin = tickPositions[0],
> 					roundedMax = tickPositions[tickPositions.length - 1];
> 				
> 				if (options.startOnTick) {
> 					min = roundedMin;
> 				} else if (min > roundedMin) {
> 					tickPositions.shift();
> 				}
> 				
> 				if (options.endOnTick) {
> 					max = roundedMax;
> 				} else if (max < roundedMax) {
> 					tickPositions.pop();
> 				}
> 			
> 				// record the greatest number of ticks for multi axis
> 				if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
> 					maxTicks = {
> 						x: 0,
> 						y: 0
> 					};
> 				}
> 				
> 				if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY]) {
> 					maxTicks[xOrY] = tickPositions.length;
> 				}
> 			}
> 			
> 			
> 		}
> 		
> 		/**
> 		 * When using multiple axes, adjust the number of ticks to match the highest
> 		 * number of ticks in that group
> 		 */ 
> 		function adjustTickAmount() {
> 					
> 			if (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale
> 				var oldTickAmount = tickAmount,
> 					calculatedTickAmount = tickPositions.length;
> 					
> 				// set the axis-level tickAmount to use below
> 				tickAmount = maxTicks[xOrY];
> 				
> 				if (calculatedTickAmount < tickAmount) {
> 					while (tickPositions.length < tickAmount) {
> 						tickPositions.push( correctFloat(
> 							tickPositions[tickPositions.length - 1] + tickInterval
> 						));
> 					}
> 					transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
> 					max = tickPositions[tickPositions.length - 1];
> 				
> 				}
> 				if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
> 					axis.isDirty = true;	
> 				}
> 			}
> 			
> 		}
> 	
> 		/**
> 		 * Set the scale based on data min and max, user set min and max or options
> 		 * 
> 		 */
> 		function setScale() {
> 			var type, 
> 				i;
> 				
> 			oldMin = min;
> 			oldMax = max;
> 				
> 			// get data extremes if needed
> 			getSeriesExtremes();
> 					
> 			// get fixed positions based on tickInterval
> 			setTickPositions();
> 			
> 			// the translation factor used in translate function
> 			oldTransA = transA;
> 			transA = axisLength / ((max - min) || 1);
> 							
> 			// reset stacks
> 			if (!isXAxis) {
> 				for (type in stacks) {
> 					for (i in stacks[type]) {
> 						stacks[type][i].cum = stacks[type][i].total;
> 					}
> 				}
> 			}
> 
> 			// mark as dirty if it is not already set to dirty and extremes have changed
> 			if (!axis.isDirty) {
> 				axis.isDirty = (min !== oldMin || max !== oldMax);
> 			}
> 			
> 		}
> 		
> 		/**
> 		 * Set the extremes and optionally redraw
> 		 * @param {Number} newMin
> 		 * @param {Number} newMax
> 		 * @param {Boolean} redraw
> 		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
> 		 *    configuration
> 		 * 
> 		 */
> 		function setExtremes(newMin, newMax, redraw, animation) {
> 			
> 			redraw = pick(redraw, true); // defaults to true
> 				
> 			fireEvent(axis, 'setExtremes', { // fire an event to enable syncing of multiple charts
> 				min: newMin,
> 				max: newMax
> 			}, function() { // the default event handler
> 				
> 				userMin = newMin;
> 				userMax = newMax;
> 			
> 				
> 				// redraw
> 				if (redraw) {
> 					chart.redraw(animation);
> 				}
> 			});
> 			
> 		}
> 		
> 		/**
> 		 * Get the actual axis extremes
> 		 */
> 		function getExtremes() {
> 			return {
> 				min: min,
> 				max: max,
> 				dataMin: dataMin,
> 				dataMax: dataMax,
> 				userMin: userMin,
> 				userMax: userMax
> 			};
> 		}
> 		
> 		/**
> 		 * Get the zero plane either based on zero or on the min or max value.
> 		 * Used in bar and area plots
> 		 */
> 		function getThreshold(threshold) {
> 			if (min > threshold) {
> 				threshold = min;
> 			} else if (max < threshold) {
> 				threshold = max;
> 			}
> 			
> 			return translate(threshold, 0, 1);
> 		}
> 		
> 		/**
> 		 * Add a plot band or plot line after render time
> 		 * 
> 		 * @param options {Object} The plotBand or plotLine configuration object
> 		 */
> 		function addPlotBandOrLine(options) {
> 			var obj = new PlotLineOrBand(options).render();
> 			plotLinesAndBands.push(obj);
> 			return obj;
> 		}
> 		
> 		/**
> 		 * Render the tick labels to a preliminary position to get their sizes
> 		 */
> 		function getOffset() {
> 			
> 			var hasData = associatedSeries.length && defined(min) && defined(max),
> 				titleOffset = 0,
> 				titleMargin = 0,
> 				axisTitleOptions = options.title,
> 				labelOptions = options.labels,
> 				directionFactor = [-1, 1, 1, -1][side],
> 				n;
> 			
> 			if (!axisGroup) {
> 				axisGroup = renderer.g('axis')
> 					.attr({ zIndex: 7 })
> 					.add();
> 				gridGroup = renderer.g('grid')
> 					.attr({ zIndex: 1 })
> 					.add();
> 			}
> 			
> 			labelOffset = 0; // reset
> 			
> 			if (hasData || isLinked) {
> 				each(tickPositions, function(pos) {
> 					if (!ticks[pos]) {
> 						ticks[pos] = new Tick(pos);
> 					} else {
> 						ticks[pos].addLabel(); // update labels depending on tick interval
> 					}
> 					
> 					// left side must be align: right and right side must have align: left for labels
> 					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === labelOptions.align) {
> 					
> 						// get the highest offset
> 						labelOffset = mathMax(
> 							ticks[pos].getLabelSize(),
> 							labelOffset
> 						);
> 					}
> 			
> 				});
> 				
> 				if (staggerLines) {
> 					labelOffset += (staggerLines - 1) * 16;
> 				}
> 			
> 			} else { // doesn't have data
> 				for (n in ticks) {
> 					ticks[n].destroy();
> 					delete ticks[n];
> 				}
> 			}
> 			
> 			if (axisTitleOptions && axisTitleOptions.text) {
> 				if (!axis.axisTitle) {
> 					axis.axisTitle = renderer.text(
> 						axisTitleOptions.text,
> 						0,
> 						0
> 					)
> 					.attr({ 
> 						zIndex: 7,
> 						rotation: axisTitleOptions.rotation || 0,
> 						align: 
> 							axisTitleOptions.textAlign || 
> 							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
> 					})
> 					.css(axisTitleOptions.style)
> 					.add();
> 				}
> 				
> 				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
> 				titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
> 				
> 			}
> 			
> 			// handle automatic or user set offset
> 			offset = directionFactor * (options.offset || axisOffset[side]);
> 			
> 			axisTitleMargin = 
> 				labelOffset +
> 				(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x']) + 
> 				titleMargin;
> 			
> 			axisOffset[side] = mathMax(
> 				axisOffset[side], 
> 				axisTitleMargin + titleOffset + directionFactor * offset
> 			);
> 			
> 		}
> 		
> 		/**
> 		 * Render the axis
> 		 */
> 		function render() {
> 			var axisTitleOptions = options.title,
> 				stackLabelOptions = options.stackLabels,
> 				alternateGridColor = options.alternateGridColor,
> 				lineWidth = options.lineWidth,
> 				lineLeft,
> 				lineTop,
> 				linePath,
> 				hasRendered = chart.hasRendered,
> 				slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
> 				hasData = associatedSeries.length && defined(min) && defined(max);
> 			
> 			// update metrics
> 			axisLength = horiz ? plotWidth : plotHeight;
> 			transA = axisLength / ((max - min) || 1);
> 			transB = horiz ? plotLeft : marginBottom; // translation addend
> 			
> 			// If the series has data draw the ticks. Else only the line and title
> 			if (hasData || isLinked) {
> 				
> 				// minor ticks
> 				if (minorTickInterval && !categories) {
> 					var pos = min + (tickPositions[0] - min) % minorTickInterval;
> 					for (pos; pos <= max; pos += minorTickInterval) {
> 						if (!minorTicks[pos]) {
> 							minorTicks[pos] = new Tick(pos, true);
> 						}
> 						
> 						// render new ticks in old position
> 						if (slideInTicks && minorTicks[pos].isNew) {
> 							minorTicks[pos].render(null, true);
> 						}
> 					
> 						
> 						minorTicks[pos].isActive = true;
> 						minorTicks[pos].render();
> 					}
> 				}
> 				
> 				// major ticks
> 				each(tickPositions, function(pos, i) {
> 					// linked axes need an extra check to find out if 
> 					if (!isLinked || (pos >= min && pos <= max)) {
> 						
> 						// render new ticks in old position
> 						if (slideInTicks && ticks[pos].isNew) {
> 							ticks[pos].render(i, true);
> 						}
> 						
> 						ticks[pos].isActive = true;
> 						ticks[pos].render(i);
> 					}
> 				});
> 				
> 				// alternate grid color
> 				if (alternateGridColor) {
> 					each(tickPositions, function(pos, i) {
> 						if (i % 2 === 0 && pos < max) {
> 							/*plotLinesAndBands.push(new PlotLineOrBand({
> 								from: pos,
> 								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
> 								color: alternateGridColor 
> 							}));*/
> 							
> 							if (!alternateBands[pos]) {
> 								alternateBands[pos] = new PlotLineOrBand();
> 							}
> 							alternateBands[pos].options = {
> 								from: pos,
> 								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
> 								color: alternateGridColor 
> 							};
> 							alternateBands[pos].render();
> 							alternateBands[pos].isActive = true;
> 						}
> 					});
> 				}
> 				
> 				// custom plot bands (behind grid lines)
> 				/*if (!hasRendered) { // only first time
> 					each(options.plotBands || [], function(plotBandOptions) {
> 						plotLinesAndBands.push(new PlotLineOrBand(
> 							extend({ zIndex: 1 }, plotBandOptions)
> 						).render());
> 					});
> 				}*/
> 				
> 				
> 				
> 				
> 				// custom plot lines and bands
> 				if (!hasRendered) { // only first time
> 					each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
> 						plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
> 					});
> 				}
> 				
> 				
> 			
> 			} // end if hasData
> 			
> 			// remove inactive ticks
> 			each([ticks, minorTicks, alternateBands], function(coll) {
> 				var pos;
> 				for (pos in coll) {
> 					if (!coll[pos].isActive) {
> 						coll[pos].destroy();
> 						delete coll[pos];
> 					} else {
> 						coll[pos].isActive = false; // reset
> 					}
> 				}
> 			});
> 				
> 				
> 			
> 			
> 			// Static items. As the axis group is cleared on subsequent calls
> 			// to render, these items are added outside the group.	
> 			// axis line
> 			if (lineWidth) {
> 				lineLeft = plotLeft + (opposite ? plotWidth : 0) + offset;
> 				lineTop = chartHeight - marginBottom - (opposite ? plotHeight : 0) + offset;
> 				
> 				linePath = renderer.crispLine([
> 						M,
> 						horiz ? 
> 							plotLeft: 
> 							lineLeft,
> 						horiz ? 
> 							lineTop: 
> 							plotTop,
> 						L, 
> 						horiz ? 
> 							chartWidth - marginRight : 
> 							lineLeft,
> 						horiz ? 
> 							lineTop:
> 							chartHeight - marginBottom
> 					], lineWidth);
> 				if (!axisLine) {
> 					axisLine = renderer.path(linePath)
> 						.attr({ 
> 							stroke: options.lineColor, 
> 							'stroke-width': lineWidth,
> 							zIndex: 7
> 						})
> 						.add();
> 				} else {
> 					axisLine.animate({ d: linePath });
> 				}
> 					
> 			}
> 			
> 			if (axis.axisTitle) {
> 				// compute anchor points for each of the title align options
> 				var margin = horiz ? plotLeft : plotTop,
> 					fontSize = pInt(axisTitleOptions.style.fontSize || 12),
> 				// the position in the length direction of the axis
> 				alongAxis = { 
> 					low: margin + (horiz ? 0 : axisLength), 
> 					middle: margin + axisLength / 2, 
> 					high: margin + (horiz ? axisLength : 0)
> 				}[axisTitleOptions.align],
> 				
> 				// the position in the perpendicular direction of the axis
> 				offAxis = (horiz ? plotTop + plotHeight : plotLeft) +
> 					(horiz ? 1 : -1) * // horizontal axis reverses the margin
> 					(opposite ? -1 : 1) * // so does opposite axes
> 					axisTitleMargin +
> 					//(isIE ? fontSize / 3 : 0)+ // preliminary fix for vml's centerline
> 					(side === 2 ? fontSize : 0);
> 				
> 				axis.axisTitle[hasRendered ? 'animate' : 'attr']({
> 					x: horiz ? 
> 						alongAxis: 
> 						offAxis + (opposite ? plotWidth : 0) + offset +
> 							(axisTitleOptions.x || 0), // x
> 					y: horiz ? 
> 						offAxis - (opposite ? plotHeight : 0) + offset: 
> 						alongAxis + (axisTitleOptions.y || 0) // y
> 				});
> 				
> 			}
> 			
> 			// Stacked totals:
> 			if (stackLabelOptions && stackLabelOptions.enabled) {
> 				var stackKey, oneStack, stackCategory,
> 					stackTotalGroup = axis.stackTotalGroup;
> 
> 				// Create a separate group for the stack total labels
> 				if (!stackTotalGroup) {
> 					axis.stackTotalGroup = stackTotalGroup =
> 						renderer.g('stack-labels')
> 							.attr({ 
> 								visibility: VISIBLE,
> 								zIndex: 6
> 							})
> 							.translate(plotLeft, plotTop)
> 							.add();
> 				}
> 
> 				// Render each stack total
> 				for (stackKey in stacks) {
> 					oneStack = stacks[stackKey];
> 					for (stackCategory in oneStack) {
> 						oneStack[stackCategory].render(stackTotalGroup);
> 					}
> 				}
> 			}
> 			// End stacked totals
> 			
> 			axis.isDirty = false;
> 		}
> 		
> 		/**
> 		 * Remove a plot band or plot line from the chart by id
> 		 * @param {Object} id
> 		 */
> 		function removePlotBandOrLine(id) {
> 			var i = plotLinesAndBands.length;
> 			while (i--) {
> 				if (plotLinesAndBands[i].id === id) {
> 					plotLinesAndBands[i].destroy();
> 				}
> 			}
> 		}
> 		
> 		/**
> 		 * Redraw the axis to reflect changes in the data or axis extremes
> 		 */
> 		function redraw() {
> 			
> 			// hide tooltip and hover states
> 			if (tracker.resetTracker) {
> 				tracker.resetTracker();
> 			}
> 		
> 			// render the axis
> 			render();			
> 			
> 			// move plot lines and bands
> 			each(plotLinesAndBands, function(plotLine) {
> 				plotLine.render();
> 			});
> 			
> 			// mark associated series as dirty and ready for redraw
> 			each(associatedSeries, function(series) {
> 				series.isDirty = true;
> 			});
> 						
> 		}
> 		
> 		/**
> 		 * Set new axis categories and optionally redraw
> 		 * @param {Array} newCategories
> 		 * @param {Boolean} doRedraw
> 		 */
> 		function setCategories(newCategories, doRedraw) {
> 				// set the categories
> 				axis.categories = categories = newCategories;
> 				
> 				// force reindexing tooltips
> 				each(associatedSeries, function(series) {
> 					series.translate();
> 					series.setTooltipPoints(true);
> 				});
> 				
> 				
> 				// optionally redraw
> 				axis.isDirty = true;
> 				
> 				if (pick(doRedraw, true)) {
> 					chart.redraw();
> 				}
> 		}
> 		
> 		
> 		
> 		// Run Axis
> 			
> 		// inverted charts have reversed xAxes as default
> 		if (inverted && isXAxis && reversed === UNDEFINED) {
> 			reversed = true;
> 		}
> 		
> 			
> 		// expose some variables
> 		extend(axis, {
> 			addPlotBand: addPlotBandOrLine,
> 			addPlotLine: addPlotBandOrLine,
> 			adjustTickAmount: adjustTickAmount,
> 			categories: categories,
> 			getExtremes: getExtremes,
> 			getPlotLinePath: getPlotLinePath,
> 			getThreshold: getThreshold,
> 			isXAxis: isXAxis,
> 			options: options,
> 			plotLinesAndBands: plotLinesAndBands,
> 			getOffset: getOffset,
> 			render: render,
> 			setCategories: setCategories,
> 			setExtremes: setExtremes,
> 			setScale: setScale,
> 			setTickPositions: setTickPositions,
> 			translate: translate,
> 			redraw: redraw,
> 			removePlotBand: removePlotBandOrLine,
> 			removePlotLine: removePlotBandOrLine,
> 			reversed: reversed,
> 			stacks: stacks
> 		});
> 		
> 		// register event listeners
> 		for (eventType in events) {
> 			addEvent(axis, eventType, events[eventType]);
> 		}
> 		
> 		// set min and max
> 		setScale();
> 	
> 	} // end Axis
> 	
> 	
> 	/**
> 	 * The toolbar object
> 	 * 
> 	 * @param {Object} chart 
> 	 */
> 	function Toolbar(chart) {
> 		var buttons = {};
> 		
> 		function add(id, text, title, fn) {
> 			if (!buttons[id]) {
> 				var button = renderer.text(
> 					text,
> 					0,
> 					0
> 				)
> 				.css(options.toolbar.itemStyle)
> 				.align({
> 					align: 'right',
> 					x: - marginRight - 20,
> 					y: plotTop + 30
> 				})
> 				.on('click', fn)
> 				/*.on('touchstart', function(e) {
> 					e.stopPropagation(); // don't fire the container event
> 					fn();
> 				})*/
> 				.attr({
> 					align: 'right', 
> 					zIndex: 20
> 				})
> 				.add();
> 				buttons[id] = button;
> 			}
> 		}
> 		function remove(id) {
> 			discardElement(buttons[id].element);
> 			buttons[id] = null;
> 		}
> 		
> 		// public
> 		return {
> 			add: add,
> 			remove: remove
> 		};
> 	}
> 	
> 	/**
> 	 * The tooltip object
> 	 * @param {Object} options Tooltip options
> 	 */
> 	function Tooltip (options) {
> 		var currentSeries,
> 			borderWidth = options.borderWidth,
> 			crosshairsOptions = options.crosshairs,
> 			crosshairs = [],
> 			style = options.style,
> 			shared = options.shared,
> 			padding = pInt(style.padding),
> 			boxOffLeft = borderWidth + padding, // off left/top position as IE can't 
> 				//properly handle negative positioned shapes
> 			tooltipIsHidden = true,
> 			boxWidth,
> 			boxHeight,
> 			currentX = 0,			
> 			currentY = 0;
> 			
> 		// remove padding CSS and apply padding on box instead
> 		style.padding = 0;
> 		
> 		// create the elements
> 		var group = renderer.g('tooltip')
> 			.attr({	zIndex: 8 })
> 			.add(),
> 			
> 			box = renderer.rect(boxOffLeft, boxOffLeft, 0, 0, options.borderRadius, borderWidth)
> 				.attr({
> 					fill: options.backgroundColor,
> 					'stroke-width': borderWidth
> 				})
> 				.add(group)
> 				.shadow(options.shadow),
> 			label = renderer.text('', padding + boxOffLeft, pInt(style.fontSize) + padding + boxOffLeft)
> 				.attr({ zIndex: 1 })
> 				.css(style)
> 				.add(group);
> 				
> 		group.hide();
> 				
> 		/**
> 		 * In case no user defined formatter is given, this will be used
> 		 */
> 		function defaultFormatter() {
> 			var pThis = this,
> 				items = pThis.points || splat(pThis),
> 				xAxis = items[0].series.xAxis,				
> 				x = pThis.x,
> 				isDateTime = xAxis && xAxis.options.type === 'datetime',
> 				useHeader = isString(x) || isDateTime,
> 				series,
> 				s;
> 			
> 			// build the header	
> 			s = useHeader ? 
> 				['<span style="font-size: 10px">' +
> 				(isDateTime ? dateFormat('%A, %b %e, %Y', x) :  x) +
> 				'</span>'] : [];
> 						
> 			// build the values
> 			each(items, function(item) {
> 				s.push(item.point.tooltipFormatter(useHeader));
> 			});
> 			return s.join('<br/>');
> 		}
> 		
> 		/**
> 		 * Provide a soft movement for the tooltip
> 		 * 
> 		 * @param {Number} finalX
> 		 * @param {Number} finalY 
> 		 */
> 		function move(finalX, finalY) {
> 
> 			currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
> 			currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;
> 			
> 			group.translate(currentX, currentY);
> 			
> 			
> 			// run on next tick of the mouse tracker
> 			if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
> 				tooltipTick = function() {
> 					move(finalX, finalY);
> 				};
> 			} else {
> 				tooltipTick = null;
> 			}
> 		}
> 		
> 		/**
> 		 * Hide the tooltip
> 		 */
> 		function hide() {
> 			if (!tooltipIsHidden) {
> 				var hoverPoints = chart.hoverPoints;
> 				
> 				group.hide();
> 			
> 				each(crosshairs, function(crosshair) {
> 					if (crosshair) {
> 						crosshair.hide();
> 					}
> 				});
> 			
> 				// hide previous hoverPoints and set new
> 				if (hoverPoints) {
> 					each(hoverPoints, function(point) {
> 						point.setState();
> 					});
> 				}
> 				chart.hoverPoints = null;					
> 				
> 				
> 				tooltipIsHidden = true;
> 			}
> 					
> 		}
> 		
> 		/**
> 		 * Refresh the tooltip's text and position. 
> 		 * @param {Object} point
> 		 * 
> 		 */
> 		function refresh(point) {
> 			var x,
> 				y,
> 				boxX,
> 				boxY,
> 				show,
> 				bBox,
> 				plotX,
> 				plotY = 0,
> 				textConfig = {},
> 				text,
> 				pointConfig = [],
> 				tooltipPos = point.tooltipPos,
> 				formatter = options.formatter || defaultFormatter,
> 				hoverPoints = chart.hoverPoints;
> 				
> 			// shared tooltip, array is sent over
> 			if (shared) {
> 				
> 				// hide previous hoverPoints and set new
> 				if (hoverPoints) {
> 					each(hoverPoints, function(point) {
> 						point.setState();
> 					});
> 				}
> 				chart.hoverPoints = point;
> 				 
> 				each(point, function(item, i) {
> 					/*var series = item.series,
> 						hoverPoint = series.hoverPoint;
> 					if (hoverPoint) {
> 						hoverPoint.setState();
> 					}
> 					series.hoverPoint = item;*/
> 					item.setState(HOVER_STATE);
> 					plotY += item.plotY; // for average
> 					
> 					pointConfig.push(item.getLabelConfig());
> 				});
> 				
> 				plotX = point[0].plotX;
> 				plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here
> 				
> 				textConfig = {
> 					x: point[0].category
> 				};
> 				textConfig.points = pointConfig;
> 				point = point[0];
> 				
> 			// single point tooltip
> 			} else {
> 				textConfig = point.getLabelConfig();
> 			}
> 			text = formatter.call(textConfig);
> 			
> 			// register the current series
> 			currentSeries = point.series;
> 			
> 			// get the reference point coordinates (pie charts use tooltipPos)
> 			plotX = shared ? plotX : point.plotX;
> 			plotY = shared ? plotY : point.plotY;
> 			x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
> 			y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));
> 				
> 				
> 			// hide tooltip if the point falls outside the plot
> 			show = shared || !point.series.isCartesian || isInsidePlot(x, y);
> 			
> 			// update the inner HTML
> 			if (text === false || !show) { 
> 				hide();
> 			} else {
> 				
> 			    // show it
> 				if (tooltipIsHidden) {
> 					group.show();
> 					tooltipIsHidden = false;
> 				}
> 				
> 				// update text
> 				label.attr({
> 					text: text
> 				});
> 				
> 				// get the bounding box
> 				bBox = label.getBBox();
> 				boxWidth = bBox.width + 2 * padding;
> 				boxHeight = bBox.height + 2 * padding;
> 
> 				// set the size of the box
> 				box.attr({
> 					width: boxWidth,
> 					height: boxHeight,
> 					stroke: options.borderColor || point.color || currentSeries.color || '#606060'
> 				});
> 				
> 				// keep the box within the chart area
> 				boxX = x - boxWidth + plotLeft - 25;
> 				boxY = y - boxHeight + plotTop + 10;
> 				
> 				// it is too far to the left, adjust it
> 				if (boxX < 7) {
> 					boxX = 7;
> 					boxY -= 30;
> 				}
> 				
> 				
> 				if (boxY < 5) {
> 					boxY = 5; // above
> 				} else if (boxY + boxHeight > chartHeight) { 
> 					boxY = chartHeight - boxHeight - 5; // below
> 				}
> 				
> 				// do the move
> 				move(mathRound(boxX - boxOffLeft), mathRound(boxY - boxOffLeft));
> 				
> 				
> 			}
> 			
> 			
> 			// crosshairs
> 			if (crosshairsOptions) {
> 				crosshairsOptions = splat(crosshairsOptions); // [x, y]
> 				
> 				var path, 
> 					i = crosshairsOptions.length,
> 					attribs,
> 					axis;
> 				
> 				while (i--) {
> 					axis = point.series[i ? 'yAxis' : 'xAxis'];
> 					if (crosshairsOptions[i] && axis) {
> 						path = axis
> 							.getPlotLinePath(point[i ? 'y' : 'x'], 1);
> 						if (crosshairs[i]) {
> 							crosshairs[i].attr({ d: path, visibility: VISIBLE });
> 						
> 						} else {
> 							attribs = {
> 								'stroke-width': crosshairsOptions[i].width || 1,
> 								stroke: crosshairsOptions[i].color || '#C0C0C0',
> 								zIndex: 2
> 							};
> 							if (crosshairsOptions[i].dashStyle) {
> 								attribs.dashstyle = crosshairsOptions[i].dashStyle;
> 							}
> 							crosshairs[i] = renderer.path(path)
> 								.attr(attribs)
> 								.add();
> 						}
> 					}
> 				}				
> 			}		
> 		}
> 		
> 
> 		
> 		// public members
> 		return {
> 			shared: shared,
> 			refresh: refresh,
> 			hide: hide
> 		};	
> 	}
> 	
> 	/**
> 	 * The mouse tracker object
> 	 * @param {Object} chart
> 	 * @param {Object} options
> 	 */
> 	function MouseTracker (chart, options) {
> 
> 		
> 		var mouseDownX, 
> 			mouseDownY,
> 			hasDragged,
> 			selectionMarker,
> 			zoomType = optionsChart.zoomType,
> 			zoomX = /x/.test(zoomType),
> 			zoomY = /y/.test(zoomType),
> 			zoomHor = (zoomX && !inverted) || (zoomY && inverted),
> 			zoomVert = (zoomY && !inverted) || (zoomX && inverted);
> 			
> 		/**
> 		 * Add crossbrowser support for chartX and chartY
> 		 * @param {Object} e The event object in standard browsers
> 		 */
> 		function normalizeMouseEvent(e) {
> 			var ePos,
> 				pageZoomFix = isWebKit && doc.width / doc.documentElement.clientWidth - 1,
> 				chartPosLeft,
> 				chartPosTop,
> 				chartX,
> 				chartY;
> 			
> 			// common IE normalizing
> 			e = e || win.event;
> 			if (!e.target) {
> 				e.target = e.srcElement;
> 			}
> 			
> 			// iOS
> 			ePos = e.touches ? e.touches.item(0) : e;
> 			
> 			// in certain cases, get mouse position
> 			if (e.type !== 'mousemove' || win.opera || pageZoomFix) { // only Opera needs position on mouse move, see below
> 				chartPosition = getPosition(container);
> 				chartPosLeft = chartPosition.left;
> 				chartPosTop = chartPosition.top;
> 			}
> 			
> 			// chartX and chartY
> 			if (isIE) { // IE including IE9 that has chartX but in a different meaning
> 				chartX = e.x;
> 				chartY = e.y;
> 			} else {
> 				if (ePos.layerX === UNDEFINED) { // Opera and iOS
> 					chartX = ePos.pageX - chartPosLeft;
> 					chartY = ePos.pageY - chartPosTop;
> 				} else {
> 					chartX = e.layerX;
> 					chartY = e.layerY;
> 				}
> 			}
> 			
> 			// correct for page zoom bug in WebKit
> 			if (pageZoomFix) {
> 				chartX += mathRound((pageZoomFix + 1) * chartPosLeft - chartPosLeft);
> 				chartY += mathRound((pageZoomFix + 1) * chartPosTop - chartPosTop);
> 			}
> 			
> 			return extend(e, {
> 				chartX: chartX,
> 				chartY: chartY
> 			});
> 		}
> 		
> 		/**
> 		 * Get the click position in terms of axis values.
> 		 * 
> 		 * @param {Object} e A mouse event
> 		 */
> 		function getMouseCoordinates(e) {
> 			var coordinates = {
> 				xAxis: [],
> 				yAxis: []
> 			}; 
> 			each(axes, function(axis, i) {
> 				var translate = axis.translate,
> 					isXAxis = axis.isXAxis,
> 					isHorizontal = inverted ? !isXAxis : isXAxis;
> 					
> 				coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
> 					axis: axis,
> 					value: translate(
> 						isHorizontal ? 
> 							e.chartX - plotLeft  : 
> 							plotHeight - e.chartY + plotTop,
> 						true
> 					)								
> 				});
> 			});
> 			return coordinates;
> 		}
> 		
> 		/**
> 		 * With line type charts with a single tracker, get the point closest to the mouse
> 		 */
> 		function onmousemove (e) {
> 			var point,
> 				points,
> 				hoverPoint = chart.hoverPoint,
> 				hoverSeries = chart.hoverSeries,
> 				i,
> 				j,
> 				distance = chartWidth,
> 				index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?
> 				
> 			// shared tooltip
> 			if (tooltip && options.shared) {
> 				points = [];
> 				
> 				// loop over all series and find the ones with points closest to the mouse
> 				i = series.length;
> 				for (j = 0; j < i; j++) {
> 					if (series[j].visible && series[j].tooltipPoints.length) {
> 						point = series[j].tooltipPoints[index];
> 						point._dist = mathAbs(index - point.plotX);
> 						distance = mathMin(distance, point._dist);
> 						points.push(point);
> 					}
> 				}
> 				// remove furthest points
> 				i = points.length;
> 				while (i--) {
> 					if (points[i]._dist > distance) {
> 						points.splice(i, 1);
> 					}
> 				}
> 				// refresh the tooltip if necessary
> 				if (points.length && (points[0].plotX !== hoverX)) {
> 					tooltip.refresh(points);
> 					hoverX = points[0].plotX;
> 				}
> 			}
> 			
> 			// separate tooltip and general mouse events
> 			if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker
> 		
> 				// get the point
> 				point = hoverSeries.tooltipPoints[index];
> 				
> 				// a new point is hovered, refresh the tooltip
> 				if (point && point !== hoverPoint) {
> 					
> 					// trigger the events
> 					point.onMouseOver();
> 					
> 				}				
> 			}
> 		}
> 				
> 		
> 		
> 		/**
> 		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
> 		 */
> 		function resetTracker() {
> 			var hoverSeries = chart.hoverSeries,
> 				hoverPoint = chart.hoverPoint;				
> 
> 			if (hoverPoint) {
> 				hoverPoint.onMouseOut();
> 			}
> 			
> 			if (hoverSeries) {
> 				hoverSeries.onMouseOut();
> 			}
> 			
> 			if (tooltip) {
> 				tooltip.hide();
> 			}
> 			
> 			hoverX = null;
> 		}
> 		
> 		/**
> 		 * Mouse up or outside the plot area
> 		 */
> 		function drop() {
> 			if (selectionMarker) {
> 				var selectionData = {
> 						xAxis: [],
> 						yAxis: []
> 					},
> 					selectionBox = selectionMarker.getBBox(),
> 					selectionLeft = selectionBox.x - plotLeft,
> 					selectionTop = selectionBox.y - plotTop;
> 				
> 					
> 				// a selection has been made
> 				if (hasDragged) {
> 					
> 					// record each axis' min and max
> 					each(axes, function(axis, i) {
> 						var translate = axis.translate,
> 							isXAxis = axis.isXAxis,
> 							isHorizontal = inverted ? !isXAxis : isXAxis,
> 							selectionMin = translate(
> 								isHorizontal ? 
> 									selectionLeft : 
> 									plotHeight - selectionTop - selectionBox.height, 
> 								true,
> 								0,
> 								0,
> 								1
> 							),
> 							selectionMax = translate(
> 								isHorizontal ? 
> 									selectionLeft + selectionBox.width : 
> 									plotHeight - selectionTop, 
> 								true,
> 								0,
> 								0,
> 								1
> 							);
> 								
> 							selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
> 								axis: axis,
> 								min: mathMin(selectionMin, selectionMax), // for reversed axes,
> 								max: mathMax(selectionMin, selectionMax)
> 							});
> 							
> 					});
> 					fireEvent(chart, 'selection', selectionData, zoom);
> 
> 				}
> 				selectionMarker = selectionMarker.destroy();
> 			}
> 			
> 			chart.mouseIsDown = mouseIsDown = hasDragged = false;
> 			removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
> 
> 		}
> 		
> 		/**
> 		 * Set the JS events on the container element
> 		 */
> 		function setDOMEvents () {
> 			var lastWasOutsidePlot = true;
> 			
> 			/*
> 			 * Record the starting position of a dragoperation
> 			 */
> 			container.onmousedown = function(e) {
> 				e = normalizeMouseEvent(e);
> 				
> 				// record the start position
> 				//e.preventDefault && e.preventDefault();
> 				
> 				chart.mouseIsDown = mouseIsDown = true;
> 				mouseDownX = e.chartX;
> 				mouseDownY = e.chartY;
> 				
> 				addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
> 			};
> 						
> 			// The mousemove, touchmove and touchstart event handler
> 			var mouseMove = function(e) {
> 
> 				// let the system handle multitouch operations like two finger scroll
> 				// and pinching
> 				if (e && e.touches && e.touches.length > 1) {
> 					return;
> 				}
> 				
> 				// normalize
> 				e = normalizeMouseEvent(e);
> 				if (!hasTouch) { // not for touch devices
> 					e.returnValue = false;
> 				}
> 				
> 				var chartX = e.chartX,
> 					chartY = e.chartY,
> 					isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);
> 					
> 				// on touch devices, only trigger click if a handler is defined
> 				if (hasTouch && e.type === 'touchstart') {
> 					if (attr(e.target, 'isTracker')) {
> 						if (!chart.runTrackerClick) {
> 							e.preventDefault();
> 						}	
> 					} else if (!runChartClick && !isOutsidePlot) {
> 						e.preventDefault();
> 					}
> 				}
> 				
> 				// cancel on mouse outside
> 				if (isOutsidePlot) {
> 				
> 					if (!lastWasOutsidePlot) {
> 						// reset the tracker					
> 						resetTracker();	
> 					}
> 					
> 					// drop the selection if any and reset mouseIsDown and hasDragged
> 					//drop();
> 					if (chartX < plotLeft) {
> 						chartX = plotLeft;
> 					} else if (chartX > plotLeft + plotWidth) {
> 						chartX = plotLeft + plotWidth;
> 					}
> 					
> 					if (chartY < plotTop) {
> 						chartY = plotTop;
> 					} else if (chartY > plotTop + plotHeight) {
> 						chartY = plotTop + plotHeight;
> 					}	
> 					
> 				}	
> 					
> 				if (mouseIsDown && e.type !== 'touchstart') { // make selection
> 					
> 					// determine if the mouse has moved more than 10px
> 					hasDragged = Math.sqrt(
> 						Math.pow(mouseDownX - chartX, 2) + 
> 						Math.pow(mouseDownY - chartY, 2));
> 					if (hasDragged > 10) {
> 					
> 						// make a selection
> 						if (hasCartesianSeries && (zoomX || zoomY) && 
> 								isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop)) {
> 							if (!selectionMarker) {
> 								selectionMarker = renderer.rect(
> 									plotLeft,
> 									plotTop,
> 									zoomHor ? 1 : plotWidth,
> 									zoomVert ? 1 : plotHeight,
> 									0
> 								)
> 								.attr({
> 									fill: 'rgba(69,114,167,0.25)',
> 									zIndex: 7
> 								})
> 								.add();
> 							}
> 						}
> 						
> 						// adjust the width of the selection marker
> 						if (selectionMarker && zoomHor) {
> 							var xSize = chartX - mouseDownX;
> 							selectionMarker.attr({
> 								width: mathAbs(xSize),
> 								x: (xSize > 0 ? 0 : xSize) + mouseDownX
> 							});
> 						}
> 						// adjust the height of the selection marker
> 						if (selectionMarker && zoomVert) {
> 							var ySize = chartY - mouseDownY;
> 							selectionMarker.attr({
> 								height: mathAbs(ySize),
> 								y: (ySize > 0 ? 0 : ySize) + mouseDownY
> 							});
> 						}
> 					}
> 					
> 				} else if (!isOutsidePlot) {
> 					// show the tooltip
> 					onmousemove(e);
> 				}
> 				
> 				lastWasOutsidePlot = isOutsidePlot;
> 				
> 				// when outside plot, allow touch-drag by returning true
> 				return isOutsidePlot || !hasCartesianSeries;
> 			};
> 			
> 			/*
> 			 * When the mouse enters the container, run mouseMove
> 			 */
> 			container.onmousemove = mouseMove;
> 			
> 			/*
> 			 * When the mouse leaves the container, hide the tracking (tooltip).
> 			 */
> 			addEvent(container, 'mouseleave', resetTracker);
> 			
> 			
> 			container.ontouchstart = function(e) {
> 				// For touch devices, use touchmove to zoom
> 				if (zoomX || zoomY) {
> 					container.onmousedown(e);
> 				}
> 				// Show tooltip and prevent the lower mouse pseudo event
> 				mouseMove(e);
> 			};
> 			
> 			/*
> 			 * Allow dragging the finger over the chart to read the values on touch 
> 			 * devices
> 			 */
> 			container.ontouchmove = mouseMove;
> 			
> 			/*
> 			 * Allow dragging the finger over the chart to read the values on touch 
> 			 * devices
> 			 */
> 			container.ontouchend = function() {
> 				if (hasDragged) {
> 					resetTracker();
> 				}
> 			};			
> 			
> 			
> 			// MooTools 1.2.3 doesn't fire this in IE when using addEvent
> 			container.onclick = function(e) {
> 				var hoverPoint = chart.hoverPoint;
> 				e = normalizeMouseEvent(e);
> 				 
> 				e.cancelBubble = true; // IE specific
> 				
> 				
> 				if (!hasDragged) {
> 					if (hoverPoint && attr(e.target, 'isTracker')) {
> 						var plotX = hoverPoint.plotX,
> 							plotY = hoverPoint.plotY;
> 							
> 						// add page position info
> 						extend(hoverPoint, {
> 							pageX: chartPosition.left + plotLeft + 
> 								(inverted ? plotWidth - plotY : plotX),
> 							pageY: chartPosition.top + plotTop + 
> 								(inverted ? plotHeight - plotX : plotY)
> 						});
> 						
> 						// the series click event
> 						fireEvent(hoverPoint.series, 'click', extend(e, {
> 							point: hoverPoint
> 						}));
> 						
> 						// the point click event
> 						hoverPoint.firePointEvent('click', e);
> 					
> 					} else { 
> 						extend(e, getMouseCoordinates(e));
> 						
> 						// fire a click event in the chart
> 						if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
> 							fireEvent(chart, 'click', e);
> 						}
> 					}
> 					
> 					
> 				}
> 				// reset mouseIsDown and hasDragged
> 				hasDragged = false;
> 			};
> 			
> 		}
> 		
> 		/**
> 		 * Create the image map that listens for mouseovers
> 		 */
> 		placeTrackerGroup = function() {
> 			
> 			// first create - plot positions is not final at this stage
> 			if (!trackerGroup) {
> 				chart.trackerGroup = trackerGroup = renderer.g('tracker')
> 					.attr({ zIndex: 9 })
> 					.add();
> 			
> 			// then position - this happens on load and after resizing and changing
> 			// axis or box positions
> 			} else {				
> 				trackerGroup.translate(plotLeft, plotTop);
> 				if (inverted) {
> 					trackerGroup.attr({
> 						width: chart.plotWidth,
> 						height: chart.plotHeight
> 					}).invert();
> 				}
> 			}			
> 		};
> 		
> 		
> 		// Run MouseTracker
> 		placeTrackerGroup();
> 		if (options.enabled) {
> 			chart.tooltip = tooltip = Tooltip(options);
> 		}
> 		
> 		setDOMEvents();
> 		
> 		// set the fixed interval ticking for the smooth tooltip
> 		tooltipInterval = setInterval(function() {
> 			if (tooltipTick) {
> 				tooltipTick();
> 			}
> 		}, 32);
> 		
> 		// expose properties
> 		extend(this, {
> 			zoomX: zoomX,
> 			zoomY: zoomY,
> 			resetTracker: resetTracker
> 		});
> 	}
> 	
> 	
> 	
> 	/**
> 	 * The overview of the chart's series
> 	 * @param {Object} chart
> 	 */
> 	var Legend = function(chart) {
> 
> 		var options = chart.options.legend;
> 			
> 		if (!options.enabled) {
> 			return;
> 		}
> 		
> 		var horizontal = options.layout === 'horizontal',
> 			symbolWidth = options.symbolWidth,
> 			symbolPadding = options.symbolPadding,
> 			allItems,
> 			style = options.style,
> 			itemStyle = options.itemStyle,
> 			itemHoverStyle = options.itemHoverStyle,
> 			itemHiddenStyle = options.itemHiddenStyle,
> 			padding = pInt(style.padding),
> 			rightPadding = 20,
> 			//lineHeight = options.lineHeight || 16,
> 			y = 18,
> 			initialItemX = 4 + padding + symbolWidth + symbolPadding,
> 			itemX,
> 			itemY,
> 			lastItemY,
> 			itemHeight = 0,
> 			box,
> 			legendBorderWidth = options.borderWidth,
> 			legendBackgroundColor = options.backgroundColor,
> 			legendGroup,
> 			offsetWidth,
> 			widthOption = options.width,
> 			series = chart.series,
> 			reversedLegend = options.reversed;
> 			
> 			
> 		
> 		/**
> 		 * Set the colors for the legend item
> 		 * @param {Object} item A Series or Point instance
> 		 * @param {Object} visible Dimmed or colored
> 		 */
> 		function colorizeItem(item, visible) {
> 			var legendItem = item.legendItem,
> 				legendLine = item.legendLine,
> 				legendSymbol = item.legendSymbol,
> 				hiddenColor = itemHiddenStyle.color,
> 				textColor = visible ? options.itemStyle.color : hiddenColor,
> 				lineColor = visible ? item.color : hiddenColor,
> 				symbolAttr = visible ? item.pointAttr[NORMAL_STATE] : {
> 					stroke: hiddenColor,
> 					fill: hiddenColor
> 				};
> 					
> 			if (legendItem) {
> 				legendItem.css({ fill: textColor });
> 			}
> 			if (legendLine) {
> 				legendLine.attr({ stroke: lineColor });
> 			}
> 			if (legendSymbol) {
> 				legendSymbol.attr(symbolAttr);
> 			}
> 			
> 		}
> 		
> 		/**
> 		 * Position the legend item
> 		 * @param {Object} item A Series or Point instance
> 		 * @param {Object} visible Dimmed or colored
> 		 */
> 		function positionItem(item, itemX, itemY) {
> 			var legendItem = item.legendItem,
> 				legendLine = item.legendLine,
> 				legendSymbol = item.legendSymbol,
> 				checkbox = item.checkbox;
> 			if (legendItem) {
> 				legendItem.attr({ 
> 					x: itemX,
> 					y: itemY
> 				});
> 			}
> 			if (legendLine) {
> 				legendLine.translate(itemX, itemY - 4);
> 			}
> 			if (legendSymbol) {
> 				legendSymbol.attr({
> 					x: itemX + legendSymbol.xOff, 
> 					y: itemY + legendSymbol.yOff
> 				});
> 			}
> 			if (checkbox) {
> 				checkbox.x = itemX;
> 				checkbox.y = itemY;
> 			}
> 		}
> 		
> 		/**
> 		 * Destroy a single legend item
> 		 * @param {Object} item The series or point
> 		 */
> 		function destroyItem(item) {
> 			var checkbox = item.checkbox;
> 				
> 			// pull out from the array
> 			//erase(allItems, item);
> 				
> 			// destroy SVG elements
> 			each(['legendItem', 'legendLine', 'legendSymbol'], function(key) {
> 				if (item[key]) {
> 					item[key].destroy();
> 				}
> 			});
> 			
> 			if (checkbox) {
> 				discardElement(item.checkbox);
> 			}
> 			
> 			
> 		}
> 		
> 		
> 		/**
> 		 * Position the checkboxes after the width is determined
> 		 */ 
> 		function positionCheckboxes() {
> 			each(allItems, function(item) {
> 				var checkbox = item.checkbox,
> 					alignAttr = legendGroup.alignAttr;
> 				if (checkbox) {
> 					css(checkbox, {
> 						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) +PX,
> 						top: (alignAttr.translateY + checkbox.y - 11) + PX 
> 					});
> 				}
> 			});
> 		}
> 		
> 		/**
> 		 * Render a single specific legend item
> 		 * @param {Object} item A series or point
> 		 */
> 		function renderItem(item) {
> 			var bBox,
> 				itemWidth,
> 				legendSymbol,
> 				symbolX,
> 				symbolY,
> 				attribs,
> 				simpleSymbol,
> 				li = item.legendItem,
> 				series = item.series || item,
> 				i = allItems.length,
> 				itemOptions = series.options,
> 				strokeWidth = (itemOptions && itemOptions.borderWidth) || 0;				
> 			
> 			if (!li) { // generate it once, later move it
> 			
> 				// let these series types use a simple symbol
> 				simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);
> 				
> 				// generate the list item text
> 				item.legendItem = li = renderer.text(
> 						options.labelFormatter.call(item),
> 						0, 
> 						0
> 					)
> 					.css(item.visible ? itemStyle : itemHiddenStyle)
> 					.on('mouseover', function() {
> 						item.setState(HOVER_STATE);
> 						li.css(itemHoverStyle);
> 					})
> 					.on('mouseout', function() {
> 						li.css(item.visible ? itemStyle : itemHiddenStyle);
> 						item.setState();
> 					})
> 					.on('click', function(event) {
> 						var strLegendItemClick = 'legendItemClick',
> 							fnLegendItemClick = function() {
> 								item.setVisible();
> 							};
> 						
> 						// click the name or symbol
> 						if (item.firePointEvent) { // point
> 							item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
> 						} else {
> 							fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
> 						}
> 					})
> 					.attr({ zIndex: 2 })
> 					.add(legendGroup);
> 				
> 				// draw the line
> 				if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
> 					var attrs = {
> 							'stroke-width': itemOptions.lineWidth,
> 							zIndex: 2
> 						};
> 					if (itemOptions.dashStyle) {
> 						attrs.dashstyle = itemOptions.dashStyle;
> 					}
> 					item.legendLine = renderer.path([
> 						M,
> 						-symbolWidth - symbolPadding, 
> 						0,
> 						L, 
> 						-symbolPadding, 
> 						0
> 					])
> 					.attr(attrs)
> 					.add(legendGroup);
> 				}
> 					
> 				// draw a simple symbol
> 				if (simpleSymbol) { // bar|pie|area|column
> 					
> 					legendSymbol = renderer.rect(
> 						(symbolX = -symbolWidth - symbolPadding),
> 						(symbolY = -11),
> 						symbolWidth,
> 						12,
> 						2
> 					).attr({
> 						//'stroke-width': 0,
> 						zIndex: 3
> 					}).add(legendGroup);
> 				}
> 					
> 				// draw the marker
> 				else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) {
> 					legendSymbol = renderer.symbol(
> 						item.symbol,
> 						(symbolX = -symbolWidth / 2 - symbolPadding), 
> 						(symbolY = -4),
> 						itemOptions.marker.radius
> 					)
> 					//.attr(item.pointAttr[NORMAL_STATE])
> 					.attr({ zIndex: 3 })
> 					.add(legendGroup);
> 				
> 				}
> 				if (legendSymbol) {
> 					legendSymbol.xOff = symbolX + (strokeWidth % 2 / 2);
> 					legendSymbol.yOff = symbolY + (strokeWidth % 2 / 2);
> 				}
> 				
> 				item.legendSymbol = legendSymbol;
> 					
> 				// colorize the items
> 				colorizeItem(item, item.visible);
> 				
> 				
> 				// add the HTML checkbox on top
> 				if (itemOptions && itemOptions.showCheckbox) {
> 					item.checkbox = createElement('input', {
> 						type: 'checkbox',
> 						checked: item.selected,
> 						defaultChecked: item.selected // required by IE7						
> 					}, options.itemCheckboxStyle, container);
> 					
> 					addEvent(item.checkbox, 'click', function(event) {
> 						var target = event.target;
> 						fireEvent(item, 'checkboxClick', { 
> 								checked: target.checked 
> 							}, 
> 							function() {
> 								item.select();
> 							}
> 						);
> 					});
> 				}
> 			}
> 			
> 			
> 			// calculate the positions for the next line
> 			bBox = li.getBBox();
> 			
> 			itemWidth = item.legendItemWidth =  
> 				options.itemWidth || symbolWidth + symbolPadding + bBox.width + rightPadding;
> 			itemHeight = bBox.height;
> 			
> 			// if the item exceeds the width, start a new line
> 			if (horizontal && itemX - initialItemX + itemWidth > 
> 					(widthOption || (chartWidth - 2 * padding - initialItemX))) {
> 				itemX = initialItemX;
> 				itemY += itemHeight;
> 			}		
> 			lastItemY = itemY;
> 			
> 			// position the newly generated or reordered items
> 			positionItem(item, itemX, itemY);
> 			
> 			// advance
> 			if (horizontal)  {
> 				itemX += itemWidth;
> 			} else {
> 				itemY += itemHeight;
> 			}
> 			
> 			// the width of the widest item
> 			offsetWidth = widthOption || mathMax(
> 				horizontal ? itemX - initialItemX : itemWidth, 
> 				offsetWidth
> 			);
> 			
> 					
> 			
> 			// add it all to an array to use below
> 			//allItems.push(item);
> 		}
> 
> 		/**
> 		 * Render the legend. This method can be called both before and after
> 		 * chart.render. If called after, it will only rearrange items instead
> 		 * of creating new ones.
> 		 */
> 		function renderLegend() {
> 			itemX = initialItemX;
> 			itemY = y;
> 			offsetWidth = 0;
> 			lastItemY = 0;
> 			
> 			if (!legendGroup) {
> 				legendGroup = renderer.g('legend')
> 					.attr({ zIndex: 7 })
> 					.add();
> 			}
> 			
> 			
> 			// add each series or point
> 			allItems = [];
> 			each(series, function(serie) {
> 				var seriesOptions = serie.options;
> 				
> 				if (!seriesOptions.showInLegend) {
> 					return;
> 				}
> 				
> 				// use points or series for the legend item depending on legendType
> 				allItems = allItems.concat(seriesOptions.legendType === 'point' ?
> 					serie.data : 
> 					serie
> 				);
> 				
> 			});
> 			
> 			// sort by legendIndex
> 			allItems.sort(function(a, b) {
> 				return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
> 			});
> 			
> 			// reversed legend
> 			if (reversedLegend) {
> 				allItems.reverse();
> 			}
> 			
> 			// render the items
> 			each(allItems, renderItem);
> 			
> 			
> 			
> 			// Draw the border
> 			legendWidth = widthOption || offsetWidth;
> 			legendHeight = lastItemY - y + itemHeight;
> 			
> 			if (legendBorderWidth || legendBackgroundColor) {
> 				legendWidth += 2 * padding;
> 				legendHeight += 2 * padding;
> 				
> 				if (!box) {
> 					box = renderer.rect(
> 						0, 
> 						0,
> 						legendWidth,
> 						legendHeight,
> 						options.borderRadius,
> 						legendBorderWidth || 0
> 					).attr({
> 						stroke: options.borderColor,
> 						'stroke-width': legendBorderWidth || 0,
> 						fill: legendBackgroundColor || NONE
> 					})
> 					.add(legendGroup)
> 					.shadow(options.shadow);
> 				
> 				} else if (legendWidth > 0 && legendHeight > 0) {
> 					box.animate(
> 						box.crisp(null, null, null, legendWidth, legendHeight)
> 					);
> 				}
> 				
> 				// hide the border if no items
> 				box[allItems.length ? 'show' : 'hide']();
> 			}
> 			
> 			// 1.x compatibility: positioning based on style
> 			var props = ['left', 'right', 'top', 'bottom'],
> 				prop,
> 				i = 4;
> 			while(i--) {
> 				prop = props[i];
> 				if (style[prop] && style[prop] !== 'auto') {
> 					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
> 					options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
> 				}
> 			}
> 			
> 			legendGroup.align(extend(options, {
> 				width: legendWidth,
> 				height: legendHeight
> 			}), true, spacingBox);
> 			
> 			if (!isResizing) {
> 				positionCheckboxes();
> 			}
> 		}
> 		
> 		
> 		// run legend
> 		renderLegend();
> 		
> 		// move checkboxes
> 		addEvent(chart, 'endResize', positionCheckboxes);
> 		
> 		// expose 
> 		return {
> 			colorizeItem: colorizeItem,
> 			destroyItem: destroyItem,
> 			renderLegend: renderLegend
> 		};
> 	};
> 	
> 	
> 	
> 		
> 	
> 
> 	/** 
> 	 * Initialize an individual series, called internally before render time
> 	 */
> 	function initSeries(options) {
> 		var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
> 			typeClass = seriesTypes[type],
> 			serie,
> 			hasRendered = chart.hasRendered;
> 			
> 		// an inverted chart can't take a column series and vice versa
> 		if (hasRendered) {
> 			if (inverted && type === 'column') {
> 				typeClass = seriesTypes.bar;
> 			} else if (!inverted && type === 'bar') {
> 				typeClass = seriesTypes.column;
> 			}
> 		}
> 		
> 		serie = new typeClass();
> 		
> 		serie.init(chart, options);
> 		
> 		// set internal chart properties
> 		if (!hasRendered && serie.inverted) {
> 			inverted = true;
> 		}
> 		if (serie.isCartesian) {
> 			hasCartesianSeries = serie.isCartesian;
> 		}
> 		
> 		series.push(serie);
> 		
> 		return serie;
> 	}
> 
> 	/**
> 	 * Add a series dynamically after  time
> 	 * 
> 	 * @param {Object} options The config options
> 	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
> 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
> 	 *    configuration
> 	 * 
> 	 * @return {Object} series The newly created series object
> 	 */
> 	function addSeries(options, redraw, animation) {
> 		var series;
> 		
> 		if (options) {
> 			setAnimation(animation, chart);
> 			redraw = pick(redraw, true); // defaults to true
> 			
> 			fireEvent(chart, 'addSeries', { options: options }, function() {
> 				series = initSeries(options);
> 				series.isDirty = true;
> 				
> 				chart.isDirtyLegend = true; // the series array is out of sync with the display
> 				if (redraw) {
> 					chart.redraw();
> 				}
> 			});
> 		}
> 		
> 		return series;
> 	}
> 	
> 	/**
> 	 * Check whether a given point is within the plot area
> 	 * 
> 	 * @param {Number} x Pixel x relative to the coordinateSystem
> 	 * @param {Number} y Pixel y relative to the coordinateSystem
> 	 */
> 	isInsidePlot = function(x, y) {
> 		return x >= 0 &&
> 			x <= plotWidth &&
> 			y >= 0 &&
> 			y <= plotHeight;
> 	};
> 		
> 	/**
> 	 * Adjust all axes tick amounts
> 	 */
> 	function adjustTickAmounts() {
> 		if (optionsChart.alignTicks !== false) {
> 			each(axes, function(axis) {
> 				axis.adjustTickAmount();
> 			});
> 		}
> 		maxTicks = null;
> 	}
> 
> 	/**
> 	 * Redraw legend, axes or series based on updated data
> 	 * 
> 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
> 	 *    configuration
> 	 */
> 	function redraw(animation) {
> 		var redrawLegend = chart.isDirtyLegend,
> 			hasStackedSeries,
> 			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
> 			seriesLength = series.length,
> 			i = seriesLength,
> 			clipRect = chart.clipRect,
> 			serie;
> 			
> 		setAnimation(animation, chart);
> 		
> 		// link stacked series
> 		while (i--) {
> 			serie = series[i];
> 			if (serie.isDirty && serie.options.stacking) {
> 				hasStackedSeries = true;
> 				break;
> 			}
> 		}
> 		if (hasStackedSeries) { // mark others as dirty
> 			i = seriesLength;
> 			while (i--) {
> 				serie = series[i];
> 				if (serie.options.stacking) {
> 					serie.isDirty = true;
> 				}
> 			}
> 		}
> 		
> 		// handle updated data in the series		
> 		each(series, function(serie) {
> 			if (serie.isDirty) { // prepare the data so axis can read it
> 				serie.cleanData();
> 				serie.getSegments();
> 				
> 				if (serie.options.legendType === 'point') {
> 					redrawLegend = true;
> 				}
> 			}
> 		});
> 		
> 		// handle added or removed series
> 		if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
> 			// draw legend graphics
> 			legend.renderLegend();
> 			
> 			chart.isDirtyLegend = false;
> 		}
> 				
> 		if (hasCartesianSeries) {
> 			if (!isResizing) {
> 				
> 				// reset maxTicks
> 				maxTicks = null;				
> 				
> 				// set axes scales
> 				each(axes, function(axis) {
> 					axis.setScale();
> 				});
> 			}
> 			adjustTickAmounts();
> 			getMargins();
> 	
> 			// redraw axes
> 			each(axes, function(axis) {
> 				if (axis.isDirty || isDirtyBox) {
> 					axis.redraw();
> 					isDirtyBox = true; // always redraw box to reflect changes in the axis labels 
> 				}
> 			});
> 			
> 			
> 		}
> 		
> 		// the plot areas size has changed
> 		if (isDirtyBox) {
> 			drawChartBox();
> 			placeTrackerGroup();
> 			
> 			// move clip rect
> 			if (clipRect) {
> 				stop(clipRect);
> 				clipRect.animate({ // for chart resize
> 					width: chart.plotSizeX,
> 					height: chart.plotSizeY
> 				});
> 			}
> 		
> 		}
> 		
> 					
> 		// redraw affected series
> 		each(series, function(serie) {
> 			if (serie.isDirty && serie.visible && 
> 					(!serie.isCartesian || serie.xAxis)) { // issue #153 
> 				serie.redraw();
> 			}
> 		});
> 		
> 		
> 		// hide tooltip and hover states
> 		if (tracker && tracker.resetTracker) {
> 			tracker.resetTracker();
> 		}
> 		
> 		// fire the event
> 		fireEvent(chart, 'redraw');
> 	}
> 	
> 	
> 	
> 	/**
> 	 * Dim the chart and show a loading text or symbol
> 	 * @param {String} str An optional text to show in the loading label instead of the default one
> 	 */
> 	function showLoading(str) {
> 		var loadingOptions = options.loading;
> 
> 		// create the layer at the first call
> 		if (!loadingDiv) {
> 			loadingDiv = createElement(DIV, {
> 				className: 'highcharts-loading'
> 			}, extend(loadingOptions.style, {
> 				left: plotLeft + PX,
> 				top: plotTop + PX,
> 				width: plotWidth + PX,
> 				height: plotHeight + PX,
> 				zIndex: 10,
> 				display: NONE
> 			}), container);
> 			
> 			loadingSpan = createElement(
> 				'span', 
> 				null, 
> 				loadingOptions.labelStyle, 
> 				loadingDiv
> 			);
> 
> 		}
> 		
> 		// update text
> 		loadingSpan.innerHTML = str || options.lang.loading;
> 		
> 		// show it
> 		if (!loadingShown) {
> 			css(loadingDiv, { opacity: 0, display: '' });
> 			animate(loadingDiv, {
> 				opacity: loadingOptions.style.opacity
> 			}, {
> 				duration: loadingOptions.showDuration
> 			});
> 			loadingShown = true;
> 		}
> 	}
> 	/**
> 	 * Hide the loading layer
> 	 */
> 	function hideLoading() {
> 		animate(loadingDiv, {
> 			opacity: 0
> 		}, {
> 			duration: options.loading.hideDuration, 
> 			complete: function() {
> 				css(loadingDiv, { display: NONE });
> 			}
> 		});
> 		loadingShown = false;
> 	}
> 	
> 	/**
> 	 * Get an axis, series or point object by id.
> 	 * @param id {String} The id as given in the configuration options
> 	 */
> 	function get(id) {
> 		var i,
> 			j,
> 			data;
> 		
> 		// search axes
> 		for (i = 0; i < axes.length; i++) {
> 			if (axes[i].options.id === id) {
> 				return axes[i];
> 			}
> 		}
> 		
> 		// search series
> 		for (i = 0; i < series.length; i++) {
> 			if (series[i].options.id === id) {
> 				return series[i];
> 			}
> 		}
> 		
> 		// search points
> 		for (i = 0; i < series.length; i++) {
> 			data = series[i].data;
> 			for (j = 0; j < data.length; j++) {
> 				if (data[j].id === id) {
> 					return data[j];
> 				}
> 			}
> 		}
> 		return null;	
> 	}
> 	
> 	/** 
> 	 * Create the Axis instances based on the config options
> 	 */
> 	function getAxes() {
> 		var xAxisOptions = options.xAxis || {},
> 			yAxisOptions = options.yAxis || {},
> 			axis;
> 			
> 		// make sure the options are arrays and add some members
> 		xAxisOptions = splat(xAxisOptions);
> 		each(xAxisOptions, function(axis, i) {
> 			axis.index = i; 
> 			axis.isX = true;
> 		});
> 		
> 		yAxisOptions = splat(yAxisOptions);
> 		each(yAxisOptions, function(axis, i) {
> 			axis.index = i;
> 		});
> 		
> 		// concatenate all axis options into one array
> 		axes = xAxisOptions.concat(yAxisOptions);
> 		
> 		// loop the options and construct axis objects
> 		chart.xAxis = [];
> 		chart.yAxis = [];
> 		axes = map(axes, function(axisOptions) {
> 			axis = new Axis(chart, axisOptions);
> 			chart[axis.isXAxis ? 'xAxis' : 'yAxis'].push(axis);
> 			
> 			return axis;
> 		});
> 		
> 		adjustTickAmounts();
> 	}
> 
> 	
> 	/**
> 	 * Get the currently selected points from all series
> 	 */
> 	function getSelectedPoints() {
> 		var points = [];
> 		each(series, function(serie) {
> 			points = points.concat( grep( serie.data, function(point) {
> 				return point.selected;
> 			}));
> 		});
> 		return points;
> 	}
> 	
> 	/**
> 	 * Get the currently selected series
> 	 */
> 	function getSelectedSeries() {
> 		return grep(series, function (serie) {
> 			return serie.selected;
> 		});
> 	}
> 	
> 	/**
> 	 * Zoom out to 1:1
> 	 */
> 	zoomOut = function () {
> 		fireEvent(chart, 'selection', { resetSelection: true }, zoom);
> 		chart.toolbar.remove('zoom');
> 
> 	};
> 	/**
> 	 * Zoom into a given portion of the chart given by axis coordinates
> 	 * @param {Object} event
> 	 */
> 	zoom = function (event) {
> 		
> 		// add button to reset selection
> 		var lang = defaultOptions.lang,
> 			animate = chart.pointCount < 100;
> 		chart.toolbar.add('zoom', lang.resetZoom, lang.resetZoomTitle, zoomOut);
> 		
> 		// if zoom is called with no arguments, reset the axes
> 		if (!event || event.resetSelection) {
> 			each(axes, function(axis) {
> 				axis.setExtremes(null, null, false, animate);
> 			});
> 		}
> 			
> 		// else, zoom in on all axes
> 		else {
> 			each(event.xAxis.concat(event.yAxis), function(axisData) {
> 				var axis = axisData.axis;
> 				
> 				// don't zoom more than maxZoom
> 				if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
> 					axis.setExtremes(axisData.min, axisData.max, false, animate);
> 				}
> 			});
> 		}
> 		
> 		// redraw chart
> 		redraw();
> 	};
> 	
> 	/**
> 	 * Show the title and subtitle of the chart
> 	 * 
> 	 * @param titleOptions {Object} New title options
> 	 * @param subtitleOptions {Object} New subtitle options
> 	 * 
> 	 */
> 	function setTitle (titleOptions, subtitleOptions) {
> 		
> 		chartTitleOptions = merge(options.title, titleOptions);
> 		chartSubtitleOptions = merge(options.subtitle, subtitleOptions);
> 		
> 		// add title and subtitle
> 		each([
> 			['title', titleOptions, chartTitleOptions],
> 			['subtitle', subtitleOptions, chartSubtitleOptions]
> 		], function(arr) {
> 			var name = arr[0],
> 				title = chart[name],
> 				titleOptions = arr[1],
> 				chartTitleOptions = arr[2];
> 				
> 			if (title && titleOptions) {
> 				title.destroy(); // remove old
> 				title = null;
> 			}
> 			if (chartTitleOptions && chartTitleOptions.text && !title) {
> 				chart[name] = renderer.text(
> 					chartTitleOptions.text, 
> 					0,
> 					0
> 				)
> 				.attr({
> 					align: chartTitleOptions.align,
> 					'class': 'highcharts-'+ name,
> 					zIndex: 1
> 				})
> 				.css(chartTitleOptions.style)
> 				.add()
> 				.align(chartTitleOptions, false, spacingBox);
> 			}
> 		});
> 		
> 	}
> 	
> 	/**
> 	 * Get chart width and height according to options and container size
> 	 */
> 	function getChartSize() {
> 
> 		containerWidth = (renderToClone || renderTo).offsetWidth;
> 		containerHeight = (renderToClone || renderTo).offsetHeight;
> 		chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
> 		chart.chartHeight = chartHeight = optionsChart.height || 
> 			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
> 			(containerHeight > 19 ? containerHeight : 400);
> 	}
> 
> 	
> 	/**
> 	 * Get the containing element, determine the size and create the inner container
> 	 * div to hold the chart
> 	 */
> 	function getContainer() {
> 		renderTo = optionsChart.renderTo;
> 		containerId = PREFIX + idCounter++;
> 	
> 		if (isString(renderTo)) {
> 			renderTo = doc.getElementById(renderTo);
> 		}
> 	
> 		// remove previous chart
> 		renderTo.innerHTML = '';
> 		
> 		// If the container doesn't have an offsetWidth, it has or is a child of a node
> 		// that has display:none. We need to temporarily move it out to a visible
> 		// state to determine the size, else the legend and tooltips won't render
> 		// properly 
> 		if (!renderTo.offsetWidth) {
> 			renderToClone = renderTo.cloneNode(0);
> 			css(renderToClone, {
> 				position: ABSOLUTE,
> 				top: '-9999px',
> 				display: ''
> 			});
> 			doc.body.appendChild(renderToClone);
> 		}
> 		
> 		// get the width and height
> 		getChartSize();
> 		
> 		// create the inner container
> 		chart.container = container = createElement(DIV, {
> 				className: 'highcharts-container' + 
> 					(optionsChart.className ? ' '+ optionsChart.className : ''),
> 				id: containerId
> 			}, extend({
> 				position: RELATIVE,
> 				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and  
> 					// content overflow in IE
> 				width: chartWidth + PX,
> 				height: chartHeight + PX,
> 				textAlign: 'left'
> 			}, optionsChart.style),
> 			renderToClone || renderTo
> 		);
> 		
> 		chart.renderer = renderer = 
> 			optionsChart.forExport ? // force SVG, used for SVG export
> 				new SVGRenderer(container, chartWidth, chartHeight, true) : 
> 				new Renderer(container, chartWidth, chartHeight);
> 				
> 		// Issue 110 workaround:
> 		// In Firefox, if a div is positioned by percentage, its pixel position may land
> 		// between pixels. The container itself doesn't display this, but an SVG element
> 		// inside this container will be drawn at subpixel precision. In order to draw
> 		// sharp lines, this must be compensated for. This doesn't seem to work inside
> 		// iframes though (like in jsFiddle).
> 		var subPixelFix, rect;
> 		if (isFirefox && container.getBoundingClientRect) {
> 			subPixelFix = function() {
> 				css(container, { left: 0, top: 0 });
> 				rect = container.getBoundingClientRect();
> 				css(container, {
> 					left: (-(rect.left - pInt(rect.left))) + PX,
> 					top: (-(rect.top - pInt(rect.top))) + PX
> 				});
> 			};
> 			
> 			// run the fix now
> 			subPixelFix();
> 			
> 			// run it on resize
> 			addEvent(win, 'resize', subPixelFix);
> 			
> 			// remove it on chart destroy
> 			addEvent(chart, 'destroy', function() {
> 				removeEvent(win, 'resize', subPixelFix);
> 			});
> 		}
> 	}
> 	
> 	/**
> 	 * Calculate margins by rendering axis labels in a preliminary position. Title,
> 	 * subtitle and legend have already been rendered at this stage, but will be 
> 	 * moved into their final positions
> 	 */
> 	getMargins = function() {
> 		var legendOptions = options.legend,
> 			legendMargin = pick(legendOptions.margin, 10),
> 			legendX = legendOptions.x,
> 			legendY = legendOptions.y,
> 			align = legendOptions.align,
> 			verticalAlign = legendOptions.verticalAlign,
> 			titleOffset;
> 
> 		resetMargins();
> 
> 		// adjust for title and subtitle
> 		if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
> 			titleOffset = mathMax(
> 				(chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0, 
> 				(chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0				
> 			);
> 			if (titleOffset) {
> 				plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
> 			}
> 		}
> 		// adjust for legend
> 		if (legendOptions.enabled && !legendOptions.floating) {
> 			if (align === 'right') { // horizontal alignment handled first
> 				if (!defined(optionsMarginRight)) {
> 					marginRight = mathMax(
> 						marginRight,
> 						legendWidth - legendX + legendMargin + spacingRight
> 					);
> 				}
> 			} else if (align === 'left') {
> 				if (!defined(optionsMarginLeft)) {
> 					plotLeft = mathMax(
> 						plotLeft,
> 						legendWidth + legendX + legendMargin + spacingLeft
> 					);
> 				}
> 				
> 			} else if (verticalAlign === 'top') {
> 				if (!defined(optionsMarginTop)) {
> 					plotTop = mathMax(
> 						plotTop, 
> 						legendHeight + legendY + legendMargin + spacingTop
> 					);
> 				}
> 			
> 			} else if (verticalAlign === 'bottom') {
> 				if (!defined(optionsMarginBottom)) {
> 					marginBottom = mathMax(
> 						marginBottom, 
> 						legendHeight - legendY + legendMargin + spacingBottom
> 					);
> 				}
> 			}
> 		}
> 		
> 		// pre-render axes to get labels offset width
> 		if (hasCartesianSeries) {
> 			each(axes, function(axis) {
> 				axis.getOffset();
> 			});
> 		}
> 		
> 		if (!defined(optionsMarginLeft)) {
> 			plotLeft += axisOffset[3];
> 		}
> 		if (!defined(optionsMarginTop)) {
> 			plotTop += axisOffset[0];
> 		}
> 		if (!defined(optionsMarginBottom)) {
> 			marginBottom += axisOffset[2];
> 		}
> 		if (!defined(optionsMarginRight)) {
> 			marginRight += axisOffset[1];
> 		}
> 		
> 		setChartSize();
> 		
> 	};
> 	
> 	/**
> 	 * Add the event handlers necessary for auto resizing
> 	 * 
> 	 */
> 	function initReflow() {
> 		var reflowTimeout;
> 		function reflow() {
> 			var width = optionsChart.width || renderTo.offsetWidth,
> 				height = optionsChart.height || renderTo.offsetHeight;
> 			
> 			if (width && height) { // means container is display:none
> 				if (width !== containerWidth || height !== containerHeight) {
> 					clearTimeout(reflowTimeout);
> 					reflowTimeout = setTimeout(function() {
> 						resize(width, height, false);
> 					}, 100);
> 				}
> 				containerWidth = width;
> 				containerHeight = height;
> 			}
> 		}
> 		addEvent(win, 'resize', reflow);
> 		addEvent(chart, 'destroy', function() {
> 			removeEvent(win, 'resize', reflow);
> 		});
> 	}
> 	
> 	/**
> 	 * Resize the chart to a given width and height
> 	 * @param {Number} width
> 	 * @param {Number} height
> 	 * @param {Object|Boolean} animation
> 	 */
> 	resize = function(width, height, animation) {
> 		var chartTitle = chart.title,
> 			chartSubtitle = chart.subtitle;
> 		
> 		isResizing += 1;
> 		
> 		// set the animation for the current process
> 		setAnimation(animation, chart);
> 		
> 		oldChartHeight = chartHeight;
> 		oldChartWidth = chartWidth;
> 		chart.chartWidth = chartWidth = mathRound(width);
> 		chart.chartHeight = chartHeight = mathRound(height);
> 		
> 		css(container, {
> 			width: chartWidth + PX,
> 			height: chartHeight + PX
> 		});
> 		renderer.setSize(chartWidth, chartHeight, animation);
> 		
> 		// update axis lengths for more correct tick intervals:
> 		plotWidth = chartWidth - plotLeft - marginRight; 
> 		plotHeight = chartHeight - plotTop - marginBottom;
> 		
> 		// handle axes
> 		maxTicks = null;
> 		each(axes, function(axis) {
> 			axis.isDirty = true;
> 			axis.setScale();
> 		});
> 		
> 		// make sure non-cartesian series are also handled
> 		each(series, function(serie) {
> 			serie.isDirty = true;
> 		});
> 		
> 		chart.isDirtyLegend = true; // force legend redraw
> 		chart.isDirtyBox = true; // force redraw of plot and chart border
> 		
> 		getMargins();
> 		 
> 		// move titles
> 		if (chartTitle) {
> 			chartTitle.align(null, null, spacingBox);
> 		}
> 		if (chartSubtitle) {
> 			chartSubtitle.align(null, null, spacingBox);
> 		}
> 		
> 		redraw(animation);
> 		
> 		
> 		oldChartHeight = null;
> 		fireEvent(chart, 'resize');
> 		
> 		// fire endResize and set isResizing back 
> 		setTimeout(function() {
> 			fireEvent(chart, 'endResize', null, function() {
> 				isResizing -= 1;
> 			});
> 		}, (globalAnimation && globalAnimation.duration) || 500);
> 	};
> 	
> 	/**
> 	 * Set the public chart properties. This is done before and after the pre-render
> 	 * to determine margin sizes
> 	 */
> 	setChartSize = function() {
> 		
> 		chart.plotLeft = plotLeft = mathRound(plotLeft);
> 		chart.plotTop = plotTop = mathRound(plotTop);
> 		chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
> 		chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);
> 		
> 		chart.plotSizeX = inverted ? plotHeight : plotWidth;
> 		chart.plotSizeY = inverted ? plotWidth : plotHeight;
> 		
> 		spacingBox = {
> 			x: spacingLeft,
> 			y: spacingTop,
> 			width: chartWidth - spacingLeft - spacingRight,
> 			height: chartHeight - spacingTop - spacingBottom
> 		};
> 	};
> 	
> 	/**
> 	 * Initial margins before auto size margins are applied
> 	 */
> 	resetMargins = function() {
> 		plotTop = pick(optionsMarginTop, spacingTop);
> 		marginRight = pick(optionsMarginRight, spacingRight);
> 		marginBottom = pick(optionsMarginBottom, spacingBottom);
> 		plotLeft = pick(optionsMarginLeft, spacingLeft);
> 		axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
> 	};
> 	
> 	/**
> 	 * Draw the borders and backgrounds for chart and plot area
> 	 */
> 	drawChartBox = function() {
> 		var chartBorderWidth = optionsChart.borderWidth || 0,
> 			chartBackgroundColor = optionsChart.backgroundColor,
> 			plotBackgroundColor = optionsChart.plotBackgroundColor,
> 			plotBackgroundImage = optionsChart.plotBackgroundImage,
> 			mgn,
> 			plotSize = {
> 				x: plotLeft,
> 				y: plotTop,
> 				width: plotWidth,
> 				height: plotHeight
> 			};
> 
> 		// Chart area
> 		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
> 			
> 		if (chartBorderWidth || chartBackgroundColor) {
> 			if (!chartBackground) {
> 				chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn, 
> 						optionsChart.borderRadius, chartBorderWidth)
> 					.attr({ 
> 						stroke: optionsChart.borderColor,
> 						'stroke-width': chartBorderWidth,
> 						fill: chartBackgroundColor || NONE
> 					})
> 					.add()
> 					.shadow(optionsChart.shadow);
> 			} else { // resize
> 				chartBackground.animate(
> 					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
> 				);
> 			}
> 		}
> 		
> 		
> 		// Plot background
> 		if (plotBackgroundColor) {
> 			if (!plotBackground) {
> 				plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
> 					.attr({
> 						fill: plotBackgroundColor
> 					})
> 					.add()
> 					.shadow(optionsChart.plotShadow);
> 			} else {
> 				plotBackground.animate(plotSize);
> 			}
> 		}
> 		if (plotBackgroundImage) {
> 			if (!plotBGImage) {
> 				plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
> 					.add();
> 			} else {
> 				plotBGImage.animate(plotSize);
> 			}
> 		}
> 		
> 		// Plot area border
> 		if (optionsChart.plotBorderWidth) {
> 			if (!plotBorder) {
> 				plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
> 					.attr({
> 						stroke: optionsChart.plotBorderColor,
> 						'stroke-width': optionsChart.plotBorderWidth,
> 						zIndex: 4
> 					})
> 					.add();
> 			} else {
> 				plotBorder.animate(
> 					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
> 				);
> 			}
> 		}
> 		
> 		// reset
> 		chart.isDirtyBox = false;
> 	};
> 	
> 	/**
> 	 * Render all graphics for the chart
> 	 */
> 	function render () {
> 		var labels = options.labels,
> 			credits = options.credits,
> 			creditsHref;
> 		
> 		// Title
> 		setTitle();
> 		
> 		
> 		// Legend
> 		legend = chart.legend = new Legend(chart);
> 		
> 		// Get margins by pre-rendering axes
> 		getMargins();
> 		each(axes, function(axis) {
> 			axis.setTickPositions(true); // update to reflect the new margins 
> 		});
> 		adjustTickAmounts();
> 		getMargins(); // second pass to check for new labels
> 		
> 		
> 		// Draw the borders and backgrounds
> 		drawChartBox();
> 						
> 		// Axes
> 		if (hasCartesianSeries) {
> 			each(axes, function(axis) { 
> 				axis.render();
> 			});
> 		}
> 		
> 		
> 		// The series
> 		if (!chart.seriesGroup) {
> 			chart.seriesGroup = renderer.g('series-group')
> 				.attr({ zIndex: 3 })
> 				.add();
> 		}
> 		each(series, function(serie) {
> 			serie.translate();
> 			serie.setTooltipPoints();
> 			serie.render();
> 		});
> 		
> 		
> 		// Labels
> 		if (labels.items) {
> 			each(labels.items, function() {
> 				var style = extend(labels.style, this.style),
> 					x = pInt(style.left) + plotLeft,
> 					y = pInt(style.top) + plotTop + 12;
> 				
> 				// delete to prevent rewriting in IE
> 				delete style.left;
> 				delete style.top;
> 				
> 				renderer.text(
> 					this.html,
> 					x,
> 					y
> 				)
> 				.attr({ zIndex: 2 })
> 				.css(style)
> 				.add();
> 					
> 			});
> 		}
> 		
> 		// Toolbar (don't redraw)
> 		if (!chart.toolbar) {
> 			chart.toolbar = Toolbar(chart);
> 		}
> 		
> 		// Credits
> 		if (credits.enabled && !chart.credits) {
> 			creditsHref = credits.href;
> 			renderer.text(
> 				credits.text,
> 				0,
> 				0
> 			)
> 			.on('click', function() {
> 				if (creditsHref) {
> 					location.href = creditsHref;
> 				}
> 			})
> 			.attr({
> 				align: credits.position.align, 
> 				zIndex: 8
> 			})
> 			.css(credits.style)
> 			.add()
> 			.align(credits.position); 
> 		}
> 		
> 		placeTrackerGroup();
> 
> 		// Set flag
> 		chart.hasRendered = true;
> 		
> 		// If the chart was rendered outside the top container, put it back in
> 		if (renderToClone) {
> 			renderTo.appendChild(container);
> 			discardElement(renderToClone);
> 			//updatePosition(container);
> 		}
> 	}
> 	
> 	/**
> 	 * Clean up memory usage
> 	 */
> 	function destroy() {
> 		var i = series.length,
> 			parentNode = container && container.parentNode;
> 		
> 		// fire the chart.destoy event
> 		fireEvent(chart, 'destroy');
> 
> 		// remove events
> 		removeEvent(win, 'unload', destroy);
> 		removeEvent(chart);
> 		
> 		each(axes, function(axis) {
> 			removeEvent(axis);
> 		});
> 
> 		// destroy each series
> 		while (i--) {
> 			series[i].destroy();
> 		}
> 		
> 		// remove container and all SVG
> 		if (container) { // can break in IE when destroyed before finished loading
> 			container.innerHTML = '';
> 			removeEvent(container);
> 			if (parentNode) {
> 				parentNode.removeChild(container);
> 			}
> 			
> 			// IE6 leak 
> 			container =	null;
> 		}
> 		
> 		// IE7 leak
> 		if (renderer) { // can break in IE when destroyed before finished loading
> 			renderer.alignedObjects = null;
> 		}
> 			
> 		// memory and CPU leak
> 		clearInterval(tooltipInterval);
> 		
> 		// clean it all up
> 		for (i in chart) {
> 			delete chart[i];
> 		}
> 		
> 	}
> 	/**
> 	 * Prepare for first rendering after all data are loaded
> 	 */
> 	function firstRender() {
> 
> 		// VML namespaces can't be added until after complete. Listening
> 		// for Perini's doScroll hack is not enough.
> 		var ONREADYSTATECHANGE = 'onreadystatechange',
> 			COMPLETE = 'complete';
> 		// Note: in spite of JSLint's complaints, win == win.top is required
> 		if (!hasSVG && win == win.top && doc.readyState !== COMPLETE) {
> 			doc.attachEvent(ONREADYSTATECHANGE, function() {
> 				doc.detachEvent(ONREADYSTATECHANGE, firstRender);
> 				if (doc.readyState === COMPLETE) {
> 					firstRender();
> 				}
> 			});
> 			return;
> 		}
> 
> 		// Set to zero for each new chart
> 		colorCounter = 0;
> 		symbolCounter = 0;
> 
> 		// create the container
> 		getContainer();
> 		
> 		resetMargins();
> 		setChartSize();
> 		
> 		// Initialize the series
> 		each(options.series || [], function(serieOptions) {
> 			initSeries(serieOptions);
> 		});
> 	
> 		// Set the common inversion and transformation for inverted series after initSeries
> 		chart.inverted = inverted = pick(inverted, options.chart.inverted); 
> 			
> 		
> 		getAxes();
> 		
> 		
> 		chart.render = render;
> 		
> 		// depends on inverted and on margins being set	
> 		chart.tracker = tracker = new MouseTracker(chart, options.tooltip);
> 		
> 		//globalAnimation = false;
> 		render();
> 		
> 		fireEvent(chart, 'load');
> 		
> 		//globalAnimation = true;
> 		
> 		// run callbacks
> 		if (callback) {
> 			callback.apply(chart, [chart]);
> 		}
> 		each(chart.callbacks, function(fn) {
> 			fn.apply(chart, [chart]);
> 		});
> 	}
> 	
> 	// Run chart
> 		
> 	
> 	// Destroy the chart and free up memory. 
> 	addEvent(win, 'unload', destroy);
> 	
> 	// Set up auto resize
> 	if (optionsChart.reflow !== false) {
> 		addEvent(chart, 'load', initReflow);
> 	}
> 	
> 	// Chart event handlers
> 	if (chartEvents) {
> 		for (eventType in chartEvents) { 
> 			addEvent(chart, eventType, chartEvents[eventType]);
> 		}
> 	}
> 	
> 	
> 	chart.options = options;
> 	chart.series = series;
> 
> 	
> 	
> 	
> 	
> 	
> 	// Expose methods and variables
> 	chart.addSeries = addSeries;
> 	chart.animation = pick(optionsChart.animation, true);
> 	chart.destroy = destroy;
> 	chart.get = get;
> 	chart.getSelectedPoints = getSelectedPoints;
> 	chart.getSelectedSeries = getSelectedSeries;
> 	chart.hideLoading = hideLoading;
> 	chart.isInsidePlot = isInsidePlot;
> 	chart.redraw = redraw;
> 	chart.setSize = resize;
> 	chart.setTitle = setTitle;
> 	chart.showLoading = showLoading;	
> 	chart.pointCount = 0;
> 	/*
> 	if ($) $(function() {
> 		$container = $('#container');
> 		var origChartWidth,
> 			origChartHeight;
> 		if ($container) {
> 			$('<button>+</button>')
> 				.insertBefore($container)
> 				.click(function() {
> 					if (origChartWidth === UNDEFINED) {
> 						origChartWidth = chartWidth;
> 						origChartHeight = chartHeight;
> 					}				
> 					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
> 				});
> 			$('<button>-</button>')
> 				.insertBefore($container)
> 				.click(function() {
> 					if (origChartWidth === UNDEFINED) {
> 						origChartWidth = chartWidth;
> 						origChartHeight = chartHeight;
> 					}							
> 					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
> 				});
> 			$('<button>1:1</button>')
> 				.insertBefore($container)
> 				.click(function() {				
> 					if (origChartWidth === UNDEFINED) {
> 						origChartWidth = chartWidth;
> 						origChartHeight = chartHeight;
> 					}							
> 					chart.resize(origChartWidth, origChartHeight);
> 				});
> 		}
> 	})
> 	*/
> 	
> 	
> 	
> 		
> 	firstRender();
> 	
> 	
> } // end Chart
> 
> // Hook for exporting module
> Chart.prototype.callbacks = [];
> /**
>  * The Point object and prototype. Inheritable and used as base for PiePoint
1472c8176,8177
<     function SVGElement () {}
---
> var Point = function() {};
> Point.prototype = {
1474,1488c8179,8182
<     SVGElement.prototype = {
<         /**
< 	 * Initialize the SVG renderer
< 	 * @param {Object} renderer
< 	 * @param {String} nodeName
< 	 */
<         init: function(renderer, nodeName) {
<             this.element = doc.createElementNS(SVG_NS, nodeName);
<             this.renderer = renderer;
<         },
<         /**
< 	 * Animate a given attribute
< 	 * @param {Object} params
< 	 * @param {Number} options The same options as in jQuery animation
< 	 * @param {Function} complete Function to perform at the end of animation
---
> 	/**
> 	 * Initialize the point
> 	 * @param {Object} series The series object containing this point
> 	 * @param {Object} options The data in either number, array or object format
1490,1696c8184,8196
<         animate: function(params, options, complete) {
<             var animOptions = pick(options, globalAnimation, true);
<             if (animOptions) {
<                 animOptions = merge(animOptions);
<                 if (complete) { // allows using a callback with the global animation without overwriting it
<                     animOptions.complete = complete;
<                 }
<                 animate(this, params, animOptions);
<             } else {
<                 this.attr(params);
<                 if (complete) {
<                     complete();
<                 }
<             }
<         },
<         /**
< 	 * Set or get a given attribute
< 	 * @param {Object|String} hash
< 	 * @param {Mixed|Undefined} val
< 	 */
<         attr: function(hash, val) {
<             var key,
<             value,
<             i,
<             child,
<             element = this.element,
<             nodeName = element.nodeName,
<             renderer = this.renderer,
<             skipAttr,
<             shadows = this.shadows,
<             hasSetSymbolSize,
<             ret = this;
< 			
<             // single key-value pair
<             if (isString(hash) && defined(val)) {
<                 key = hash;
<                 hash = {};
<                 hash[key] = val;
<             }
< 		
<             // used as a getter: first argument is a string, second is undefined
<             if (isString(hash)) {
<                 key = hash;
<                 if (nodeName === 'circle') {
<                     key = {
<                         x: 'cx',
<                         y: 'cy'
<                     }
<                     [key] || key;
<                 } else if (key === 'strokeWidth') {
<                     key = 'stroke-width';
<                 }
<                 ret = attr(element, key) || this[key] || 0;
< 			
<                 if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
<                     ret = parseFloat(ret);
<                 }
< 			
<             // setter
<             } else {
< 		
<                 for (key in hash) {
<                     skipAttr = false; // reset
<                     value = hash[key];
< 				
<                     // paths
<                     if (key === 'd') {
<                         if (value && value.join) { // join path
<                             value = value.join(' ');
<                         }
<                         if (/(NaN| {2}|^$)/.test(value)) {
<                             value = 'M 0 0';
<                         }
<                         this.d = value; // shortcut for animations
< 					
<                     // update child tspans x values
<                     } else if (key === 'x' && nodeName === 'text') {
<                         for (i = 0; i < element.childNodes.length; i++ ) {
<                             child = element.childNodes[i];
<                             // if the x values are equal, the tspan represents a linebreak
<                             if (attr(child, 'x') === attr(element, 'x')) {
<                                 //child.setAttribute('x', value);
<                                 attr(child, 'x', value);
<                             }
<                         }
< 					
<                         if (this.rotation) {
<                             attr(element, 'transform', 'rotate('+ this.rotation +' '+ value +' '+
<                                 pInt(hash.y || attr(element, 'y')) +')');
<                         }
< 					
<                     // apply gradients
<                     } else if (key === 'fill') {
<                         value = renderer.color(value, element, key);
< 				
<                     // circle x and y
<                     } else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
<                         key = {
<                             x: 'cx',
<                             y: 'cy'
<                         }
<                         [key] || key;
< 					
<                     // translation and text rotation
<                     } else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
<                         this[key] = value;
<                         this.updateTransform();
<                         skipAttr = true;
< 	
<                     // apply opacity as subnode (required by legacy WebKit and Batik)
<                     } else if (key === 'stroke') {
<                         value = renderer.color(value, element, key);
< 					
<                     // emulate VML's dashstyle implementation
<                     } else if (key === 'dashstyle') {
<                         key = 'stroke-dasharray';
<                         value = value && value.toLowerCase();
<                         if (value === 'solid') {
<                             value = NONE;
<                         } else if (value) {
<                             value = value
<                             .replace('shortdashdotdot', '3,1,1,1,1,1,')
<                             .replace('shortdashdot', '3,1,1,1')
<                             .replace('shortdot', '1,1,')
<                             .replace('shortdash', '3,1,')
<                             .replace('longdash', '8,3,')
<                             .replace(/dot/g, '1,3,')
<                             .replace('dash', '4,3,')
<                             .replace(/,$/, '')
<                             .split(','); // ending comma
< 						
<                             i = value.length;
<                             while (i--) {
<                                 value[i] = pInt(value[i]) * hash['stroke-width'];
<                             }
< 						
<                             value = value.join(',');
<                         }
< 					
<                     // special
<                     } else if (key === 'isTracker') {
<                         this[key] = value;
< 				
<                     // IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
<                     // is unable to cast them. Test again with final IE9.
<                     } else if (key === 'width') {
<                         value = pInt(value);
< 				
<                     // Text alignment
<                     } else if (key === 'align') {
<                         key = 'text-anchor';
<                         value = {
<                             left: 'start',
<                             center: 'middle',
<                             right: 'end'
<                         }
<                         [value];
<                     }
< 				
< 				
< 				
<                     // jQuery animate changes case
<                     if (key === 'strokeWidth') {
<                         key = 'stroke-width';
<                     }
< 				
<                     // Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)
<                     if (isWebKit && key === 'stroke-width' && value === 0) {
<                         value = 0.000001;
<                     }
< 				
<                     // symbols
<                     if (this.symbolName && /^(x|y|r|start|end|innerR)/.test(key)) {
< 					
< 					
<                         if (!hasSetSymbolSize) {
<                             this.symbolAttr(hash);
<                             hasSetSymbolSize = true;
<                         }
<                         skipAttr = true;
<                     }
< 				
<                     // let the shadow follow the main element
<                     if (shadows && /^(width|height|visibility|x|y|d)$/.test(key)) {
<                         i = shadows.length;
<                         while (i--) {
<                             attr(shadows[i], key, value);
<                         }
<                     }
< 				
<                     // validate heights
<                     if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
<                         value = 0;
<                     }
< 				
<                     if (key === 'text') {
<                         // only one node allowed
<                         this.textStr = value;
<                         if (this.added) {
<                             renderer.buildText(this);
<                         }
<                     } else if (!skipAttr) {
<                         //element.setAttribute(key, value);
<                         attr(element, key, value);
<                     }
< 				
<                 }
---
> 	init: function(series, options) {
> 		var point = this,
> 			defaultColors;
> 		point.series = series;
> 		point.applyOptions(options);
> 		point.pointAttr = {};
> 		
> 		if (series.options.colorByPoint) {
> 			defaultColors = series.chart.options.colors;
> 			if (!point.options) {
> 				point.options = {};
> 			}
> 			point.color = point.options.color = point.color || defaultColors[colorCounter++];
1698,1824c8198,8202
<             }
<             return ret;
<         },
< 	
<         /**
< 	 * If one of the symbol size affecting parameters are changed,
< 	 * check all the others only once for each call to an element's
< 	 * .attr() method
< 	 * @param {Object} hash
< 	 */
<         symbolAttr: function(hash) {
<             var wrapper = this;
< 		
<             each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR'], function(key) {
<                 wrapper[key] = pick(hash[key], wrapper[key]);
<             });
< 		
<             wrapper.attr({
<                 d: wrapper.renderer.symbols[wrapper.symbolName](
<                     mathRound(wrapper.x * 2) / 2, // Round to halves. Issue #274.
<                     mathRound(wrapper.y * 2) / 2,
<                     wrapper.r,
<                     {
<                         start: wrapper.start,
<                         end: wrapper.end,
<                         width: wrapper.width,
<                         height: wrapper.height,
<                         innerR: wrapper.innerR
<                     })
<             });
<         },
< 	
<         /**
< 	 * Apply a clipping path to this object
< 	 * @param {String} id
< 	 */
<         clip: function(clipRect) {
<             return this.attr('clip-path', 'url('+ this.renderer.url +'#'+ clipRect.id +')');
<         },
< 	
<         /**
< 	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
< 	 * calculated attributes
< 	 * @param {Number} strokeWidth
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<         crisp: function(strokeWidth, x, y, width, height) {
< 		
<             var wrapper = this,
<             key,
<             attr = {},
<             values = {},
<             normalizer;
< 			
<             strokeWidth = strokeWidth || wrapper.strokeWidth || 0;
<             normalizer = strokeWidth % 2 / 2;
< 
<             // normalize for crisp edges
<             values.x = mathFloor(x || wrapper.x || 0) + normalizer;
<             values.y = mathFloor(y || wrapper.y || 0) + normalizer;
<             values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
<             values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
<             values.strokeWidth = strokeWidth;
< 		
<             for (key in values) {
<                 if (wrapper[key] !== values[key]) { // only set attribute if changed
<                     wrapper[key] = attr[key] = values[key];
<                 }
<             }
< 		
<             return attr;
<         },
< 	
<         /**
< 	 * Set styles for the element
< 	 * @param {Object} styles
< 	 */
<         css: function(styles) {
<             var elemWrapper = this,
<             elem = elemWrapper.element,
<             textWidth = styles && styles.width && elem.nodeName === 'text',
<             camelStyles = styles,
<             n;
< 			
<             // convert legacy
<             if (styles && styles.color) {
<                 styles.fill = styles.color;
<             }
< 		
<             // save the styles in an object
<             styles = extend(
<                 elemWrapper.styles,
<                 styles
<                 );
< 		
< 		
<             // store object
<             elemWrapper.styles = styles;
< 		
<             // hyphenate
<             if (defined(styles)) {
<                 styles = {};
<                 for (n in camelStyles) {
<                     styles[hyphenate(n)] = camelStyles[n];
<                 }
<             }
< 		
<             // serialize and set style attribute
<             if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
<                 if (textWidth) {
<                     delete styles.width;
<                 }
<                 css(elemWrapper.element, styles);
<             } else {
<                 elemWrapper.attr({
<                     style: serializeCSS(styles)
<                 });
<             }
< 		
< 		
<             // re-build text
<             if (textWidth && elemWrapper.added) {
<                 elemWrapper.renderer.buildText(elemWrapper);
<             }
---
> 			// loop back to zero
> 			if (colorCounter >= defaultColors.length) {
> 				colorCounter = 0;
> 			}
> 		}
1826,1922c8204,8209
<             return elemWrapper;
<         },
< 	
<         /**
< 	 * Add an event listener
< 	 * @param {String} eventType
< 	 * @param {Function} handler
< 	 */
<         on: function(eventType, handler) {
<             var fn = handler;
<             // touch
<             if (hasTouch && eventType === 'click') {
<                 eventType = 'touchstart';
<                 fn = function(e) {
<                     e.preventDefault();
<                     handler();
<                 };
<             }
<             // simplest possible event model for internal use
<             this.element['on'+ eventType] = fn;
<             return this;
<         },
< 	
< 	
<         /**
< 	 * Move an object and its children by x and y values
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 */
<         translate: function(x, y) {
<             return this.attr({
<                 translateX: x,
<                 translateY: y
<             });
<         },
< 	
<         /**
< 	 * Invert a group, rotate and flip
< 	 */
<         invert: function() {
<             var wrapper = this;
<             wrapper.inverted = true;
<             wrapper.updateTransform();
<             return wrapper;
<         },
< 	
<         /**
< 	 * Private method to update the transform attribute based on internal 
< 	 * properties
< 	 */
<         updateTransform: function() {
<             var wrapper = this,
<             translateX = wrapper.translateX || 0,
<             translateY = wrapper.translateY || 0,
<             inverted = wrapper.inverted,
<             rotation = wrapper.rotation,
<             transform = [];
< 			
<             // flipping affects translate as adjustment for flipping around the group's axis
<             if (inverted) {
<                 translateX += wrapper.attr('width');
<                 translateY += wrapper.attr('height');
<             }
< 			
<             // apply translate
<             if (translateX || translateY) {
<                 transform.push('translate('+ translateX +','+ translateY +')');
<             }
< 		
<             // apply rotation
<             if (inverted) {
<                 transform.push('rotate(90) scale(-1,1)');
<             } else if (rotation) { // text rotation
<                 transform.push('rotate('+ rotation +' '+ wrapper.x +' '+ wrapper.y +')');
<             }
< 		
<             if (transform.length) {
<                 attr(wrapper.element, 'transform', transform.join(' '));
<             }
<         },
<         /**
< 	 * Bring the element to the front
< 	 */
<         toFront: function() {
<             var element = this.element;
<             element.parentNode.appendChild(element);
<             return this;
<         },
< 	
< 	
<         /**
< 	 * Break down alignment options like align, verticalAlign, x and y 
< 	 * to x and y relative to the chart.
< 	 * 
< 	 * @param {Object} alignOptions
< 	 * @param {Boolean} alignByTranslate
< 	 * @param {Object} box The box to align to, needs a width and height
---
> 		series.chart.pointCount++;
> 		return point;
> 	},
> 	/**
> 	 * Apply the options containing the x and y data and possible some extra properties.
> 	 * This is called on point init or from point.update.
1923a8211
> 	 * @param {Object} options
1925,1926c8213,8222
<         align: function(alignOptions, alignByTranslate, box) {
<             var elemWrapper = this;
---
> 	applyOptions: function(options) {
> 		var point = this,
> 			series = point.series;
> 	
> 		point.config = options;
> 		
> 		// onedimensional array input
> 		if (isNumber(options) || options === null) {
> 			point.y = options;	
> 		}
1928,2020c8224,8225
<             if (!alignOptions) { // called on resize
<                 alignOptions = elemWrapper.alignOptions;
<                 alignByTranslate = elemWrapper.alignByTranslate;
<             } else { // first call on instanciate
<                 elemWrapper.alignOptions = alignOptions;
<                 elemWrapper.alignByTranslate = alignByTranslate;
<                 if (!box) { // boxes other than renderer handle this internally
<                     elemWrapper.renderer.alignedObjects.push(elemWrapper);
<                 }
<             }
< 		
<             box = pick(box, elemWrapper.renderer);
< 		
<             var align = alignOptions.align,
<             vAlign = alignOptions.verticalAlign,
<             x = (box.x || 0) + (alignOptions.x || 0), // default: left align
<             y = (box.y || 0) + (alignOptions.y || 0), // default: top align
<             attribs = {};
< 			
< 			
<             // align
<             if (/^(right|center)$/.test(align)) {
<                 x += (box.width - (alignOptions.width || 0) ) /
<                 {
<                     right: 1,
<                     center: 2
<                 }
<                 [align];
<             }
<             attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);
< 		
< 		
<             // vertical align
<             if (/^(bottom|middle)$/.test(vAlign)) {
<                 y += (box.height - (alignOptions.height || 0)) /
<                 ({
<                     bottom: 1,
<                     middle: 2
<                 }
<                 [vAlign] || 1);
< 			
<             }
<             attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);
< 		
<             // animate only if already placed
<             elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
<             elemWrapper.placed = true;
<             elemWrapper.alignAttr = attribs;
< 		
<             return elemWrapper;
<         },
< 	
<         /**
< 	 * Get the bounding box (width, height, x and y) for the element
< 	 */
<         getBBox: function() {
<             var bBox,
<             width,
<             height,
<             rotation = this.rotation,
<             rad = rotation * deg2rad;
< 			
<             try { // fails in Firefox if the container has display: none
<                 // use extend because IE9 is not allowed to change width and height in case
<                 // of rotation (below)
<                 bBox = extend({}, this.element.getBBox());
<             } catch(e) {
<                 bBox = {
<                     width: 0,
<                     height: 0
<                 };
<             }
<             width = bBox.width;
<             height = bBox.height;
< 			
<             // adjust for rotated text
<             if (rotation) {
<                 bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
<                 bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
<             }
< 		
<             return bBox;
<         },
< 	
<         /* *
< 	 * Manually compute width and height of rotated text from non-rotated. Shared by SVG and VML
< 	 * @param {Object} bBox
< 	 * @param {number} rotation
< 	 * /
< 	rotateBBox: function(bBox, rotation) {
< 		var rad = rotation * math.PI * 2 / 360, // radians
< 			width = bBox.width,
< 			height = bBox.height;
---
> 		// object input
> 		else if (isObject(options) && !isNumber(options.length)) {
2021a8227,8230
> 			// copy options directly to point
> 			extend(point, options);
> 			point.options = options;
> 		}
2023c8232,8252
< 	},*/
---
> 		// categorized data with name in first position
> 		else if (isString(options[0])) {
> 			point.name = options[0];
> 			point.y = options[1];
> 		}
> 		
> 		// two-dimentional array
> 		else if (isNumber(options[0])) {
> 			point.x = options[0];
> 			point.y = options[1];
> 		}
> 		
> 		/* 
> 		 * If no x is set by now, get auto incremented value. All points must have an
> 		 * x value, however the y value can be null to create a gap in the series
> 		 */
> 		if (point.x === UNDEFINED) {
> 			point.x = series.autoIncrement();
> 		}
> 		
> 	},
2025,2026c8254,8255
<         /**
< 	 * Show the element
---
> 	/**
> 	 * Destroy a point to clear memory. Its reference still stays in series.data.
2028,2185c8257,8260
<         show: function() {
<             return this.attr({
<                 visibility: VISIBLE
<             });
<         },
< 	
<         /**
< 	 * Hide the element
< 	 */
<         hide: function() {
<             return this.attr({
<                 visibility: HIDDEN
<             });
<         },
< 	
<         /**
< 	 * Add the element
< 	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
< 	 *    to append the element to the renderer.box.
< 	 */ 
<         add: function(parent) {
< 	
<             var renderer = this.renderer,
<             parentWrapper = parent || renderer,
<             parentNode = parentWrapper.element || renderer.box,
<             childNodes = parentNode.childNodes,
<             element = this.element,
<             zIndex = attr(element, 'zIndex'),
<             otherElement,
<             otherZIndex,
<             i;
< 			
<             // mark as inverted
<             this.parentInverted = parent && parent.inverted;
< 		
<             // build formatted text
<             if (this.textStr !== undefined) {
<                 renderer.buildText(this);
<             }
< 		
<             // mark the container as having z indexed children
<             if (zIndex) {
<                 parentWrapper.handleZ = true;
<                 zIndex = pInt(zIndex);
<             }
< 
<             // insert according to this and other elements' zIndex
<             if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
<                 for (i = 0; i < childNodes.length; i++) {
<                     otherElement = childNodes[i];
<                     otherZIndex = attr(otherElement, 'zIndex');
<                     if (otherElement !== element && (
<                         // insert before the first element with a higher zIndex
<                         pInt(otherZIndex) > zIndex ||
<                         // if no zIndex given, insert before the first element with a zIndex
<                         (!defined(zIndex) && defined(otherZIndex))
< 						
<                         )) {
<                         parentNode.insertBefore(element, otherElement);
<                         return this;
<                     }
<                 }
<             }
< 		
<             // default: append at the end
<             parentNode.appendChild(element);
< 		
<             this.added = true;
< 		
<             return this;
<         },
< 
<         /**
< 	 * Destroy the element and element wrapper
< 	 */
<         destroy: function() {
<             var wrapper = this,
<             element = wrapper.element || {},
<             shadows = wrapper.shadows,
<             parentNode = element.parentNode,
<             key;
< 		
<             // remove events
<             element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
<             stop(wrapper); // stop running animations
< 		
<             // remove element
<             if (parentNode) {
<                 parentNode.removeChild(element);
<             }
< 		
<             // destroy shadows
<             if (shadows) {
<                 each(shadows, function(shadow) {
<                     parentNode = shadow.parentNode;
<                     if (parentNode) { // the entire chart HTML can be overwritten
<                         parentNode.removeChild(shadow);
<                     }
<                 });
<             }
< 		
<             // remove from alignObjects
<             erase(wrapper.renderer.alignedObjects, wrapper);
< 				
<             for (key in wrapper) {
<                 delete wrapper[key];
<             }
< 		
<             return null;
<         },
< 	
<         /**
< 	 * Empty a group element
< 	 */
<         empty: function() {
<             var element = this.element,
<             childNodes = element.childNodes,
<             i = childNodes.length;
< 			
<             while (i--) {
<                 element.removeChild(childNodes[i]);
<             }
<         },
< 	
<         /**
< 	 * Add a shadow to the element. Must be done after the element is added to the DOM
< 	 * @param {Boolean} apply
< 	 */
<         shadow: function(apply, group) {
<             var shadows = [],
<             i,
<             shadow,
<             element = this.element,
< 			
<             // compensate for inverted plot area
<             transform = this.parentInverted ? '(-1,-1)' : '(1,1)';
< 			
< 		
<             if (apply) {
<                 for (i = 1; i <= 3; i++) {
<                     shadow = element.cloneNode(0);
<                     attr(shadow, {
<                         'isShadow': 'true',
<                         'stroke': 'rgb(0, 0, 0)',
<                         'stroke-opacity': 0.05 * i,
<                         'stroke-width': 7 - 2 * i,
<                         'transform': 'translate'+ transform,
<                         'fill': NONE
<                     });
< 				
<                     if (group) {
<                         group.element.appendChild(shadow);
<                     } else {
<                         element.parentNode.insertBefore(shadow, element);
<                     }
< 				
<                     shadows.push(shadow);
<                 }
---
> 	destroy: function() {
> 		var point = this,
> 			series = point.series,
> 			prop;
2187,2189c8262,8287
<                 this.shadows = shadows;
<             }
<             return this;
---
> 		series.chart.pointCount--;
> 			
> 		if (point === series.chart.hoverPoint) {
> 			point.onMouseOut();
> 		}
> 		series.chart.hoverPoints = null; // remove reference
> 		
> 		// remove all events
> 		removeEvent(point);
> 		
> 		each(['graphic', 'tracker', 'group', 'dataLabel', 'connector'], function(prop) {
> 			if (point[prop]) {
> 				point[prop].destroy();
> 			}
> 		});		
> 		
> 		if (point.legendItem) { // pies have legend items
> 			point.series.chart.legend.destroyItem(point);
> 		}
> 		
> 		for (prop in point) {
> 			point[prop] = null;
> 		}
> 		
> 		
> 	},
2191,2244c8289,8332
<         }
<     };
< 
<     /**
<  * The default SVG renderer
<  */
<     var SVGRenderer = function() {
<         this.init.apply(this, arguments);
<     };
<     SVGRenderer.prototype = {
< 	
<         Element: SVGElement,
< 	
<         /**
< 	 * Initialize the SVGRenderer
< 	 * @param {Object} container
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 * @param {Boolean} forExport
< 	 */
<         init: function(container, width, height, forExport) {
<             var renderer = this,
<             loc = location,
<             boxWrapper;
< 					
<             boxWrapper = renderer.createElement('svg')
<             .attr({
<                 xmlns: SVG_NS,
<                 version: '1.1'
<             });
<             container.appendChild(boxWrapper.element);
< 		
<             // object properties
<             renderer.box = boxWrapper.element;
<             renderer.boxWrapper = boxWrapper;
<             renderer.alignedObjects = [];
<             renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, ''); // page url used for internal references
<             renderer.defs = this.createElement('defs').add();
<             renderer.forExport = forExport;
< 		
<             renderer.setSize(width, height, false);
< 		
<         },
< 	
< 	
<         /**
< 	 * Create a wrapper for an SVG element
< 	 * @param {Object} nodeName
< 	 */
<         createElement: function(nodeName) {
<             var wrapper = new this.Element();
<             wrapper.init(this, nodeName);
<             return wrapper;
<         },
---
> 	/**
> 	 * Return the configuration hash needed for the data label and tooltip formatters
> 	 */
> 	getLabelConfig: function() {
> 		var point = this;
> 		return {
> 			x: point.category,
> 			y: point.y,
> 			series: point.series,
> 			point: point,
> 			percentage: point.percentage,
> 			total: point.total || point.stackTotal
> 		};
> 	},
> 		
> 	/**
> 	 * Toggle the selection status of a point
> 	 * @param {Boolean} selected Whether to select or unselect the point.
> 	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
> 	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
> 	 */
> 	select: function(selected, accumulate) {
> 		var point = this,
> 			series = point.series,
> 			chart = series.chart;
> 			
> 		point.selected = selected = pick(selected, !point.selected);
> 		
> 		//series.isDirty = true;
> 		point.firePointEvent(selected ? 'select' : 'unselect');
> 		point.setState(selected && SELECT_STATE);
> 		
> 		// unselect all other points unless Ctrl or Cmd + click
> 		if (!accumulate) {
> 			each(chart.getSelectedPoints(), function (loopPoint) {
> 				if (loopPoint.selected && loopPoint !== point) {
> 					loopPoint.selected = false;
> 					loopPoint.setState(NORMAL_STATE);
> 					loopPoint.firePointEvent('unselect');
> 				}
> 			});
> 		}
> 		
> 	},
2245a8334,8364
> 	onMouseOver: function() {
> 		var point = this,
> 			chart = point.series.chart,
> 			tooltip = chart.tooltip,
> 			hoverPoint = chart.hoverPoint;
> 			
> 		// set normal state to previous series
> 		if (hoverPoint && hoverPoint !== point) {
> 			hoverPoint.onMouseOut();
> 		}
> 		
> 		// trigger the event
> 		point.firePointEvent('mouseOver');
> 		
> 		// update the tooltip
> 		if (tooltip && !tooltip.shared) {
> 			tooltip.refresh(point);
> 		}
> 		
> 		// hover this
> 		point.setState(HOVER_STATE);
> 		chart.hoverPoint = point;
> 	},
> 	
> 	onMouseOut: function() {
> 		var point = this;
> 		point.firePointEvent('mouseOut');
> 		
> 		point.setState();
> 		point.series.chart.hoverPoint = null;
> 	},
2247,2248c8366,8369
<         /**
< 	 * Parse a simple HTML string into SVG tspans
---
> 	/**
> 	 * Extendable method for formatting each point's tooltip line 
> 	 * 
> 	 * @param {Boolean} useHeader Whether a common header is used for multiple series in the tooltip
2250c8371
< 	 * @param {Object} textNode The parent text SVG node
---
> 	 * @return {String} A string to be concatenated in to the common tooltip text
2252,2511c8373,8389
<         buildText: function(wrapper) {
<             var textNode = wrapper.element,
<             lines = pick(wrapper.textStr, '').toString()
<             .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
<             .replace(/<(i|em)>/g, '<span style="font-style:italic">')
<             .replace(/<a/g, '<span')
<             .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
<             .split(/<br.*?>/g),
<             childNodes = textNode.childNodes,
<             styleRegex = /style="([^"]+)"/,
<             hrefRegex = /href="([^"]+)"/,
<             parentX = attr(textNode, 'x'),
<             textStyles = wrapper.styles,
<             reverse = isFirefox && textStyles && textStyles['-hc-direction'] === 'rtl' &&
<             !this.forExport && pInt(userAgent.split('Firefox/')[1]) < 4, // issue #38
<             arr,
<             width = textStyles && pInt(textStyles.width),
<             textLineHeight = textStyles && textStyles['line-height'],
<             lastLine,
<             GET_COMPUTED_STYLE = 'getComputedStyle',
<             i = childNodes.length;
< 		
<             // remove old text
<             while (i--) {
<                 textNode.removeChild(childNodes[i]);
<             }
< 		
<             if (width && !wrapper.added) {
<                 this.box.appendChild(textNode); // attach it to the DOM to read offset width
<             }
< 		
<             each(lines, function(line, lineNo) {
<                 var spans, spanNo = 0, lineHeight;
< 			
<                 line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
<                 spans = line.split('|||');
< 			
<                 each(spans, function (span) {
<                     if (span !== '' || spans.length === 1) {
<                         var attributes = {},
<                         tspan = doc.createElementNS(SVG_NS, 'tspan');
<                         if (styleRegex.test(span)) {
<                             attr(
<                                 tspan,
<                                 'style',
<                                 span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
<                                 );
<                         }
<                         if (hrefRegex.test(span)) {
<                             attr(tspan, 'onclick', 'location.href=\"'+ span.match(hrefRegex)[1] +'\"');
<                             css(tspan, {
<                                 cursor: 'pointer'
<                             });
<                         }
< 					
<                         span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
<                         .replace(/&lt;/g, '<')
<                         .replace(/&gt;/g, '>');
< 					
<                         // issue #38 workaround.
<                         if (reverse) {
<                             arr = [];
<                             i = span.length;
<                             while (i--) {
<                                 arr.push(span.charAt(i));
<                             }
<                             span = arr.join('');
<                         }
< 					
<                         // add the text node
<                         tspan.appendChild(doc.createTextNode(span));
< 					
<                         if (!spanNo) { // first span in a line, align it to the left
<                             attributes.x = parentX;
<                         } else {
<                             // Firefox ignores spaces at the front or end of the tspan
<                             attributes.dx = 3; // space
<                         }
< 					
<                         // first span on subsequent line, add the line height
<                         if (!spanNo) {
<                             if (lineNo) {
< 							
<                                 // allow getting the right offset height in exporting in IE
<                                 if (!hasSVG && wrapper.renderer.forExport) {
<                                     css(tspan, {
<                                         display: 'block'
<                                     });
<                                 }
< 							
<                                 // Webkit and opera sometimes return 'normal' as the line height. In that
<                                 // case, webkit uses offsetHeight, while Opera falls back to 18
<                                 lineHeight = win[GET_COMPUTED_STYLE] &&
<                                 win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height');
< 							
<                                 if (!lineHeight || isNaN(lineHeight)) {
<                                     lineHeight = textLineHeight || lastLine.offsetHeight || 18;
<                                 }
<                                 attr(tspan, 'dy', lineHeight);
<                             }
<                             lastLine = tspan; // record for use in next line
<                         }
< 					
<                         // add attributes
<                         attr(tspan, attributes);
< 					
<                         // append it
<                         textNode.appendChild(tspan);
< 					
<                         spanNo++;
< 					
<                         // check width and apply soft breaks
<                         if (width) {
<                             var words = span.replace(/-/g, '- ').split(' '),
<                             tooLong,
<                             actualWidth,
<                             rest = [];
< 							
<                             while (words.length || rest.length) {
<                                 actualWidth = textNode.getBBox().width;
<                                 tooLong = actualWidth > width;
<                                 if (!tooLong || words.length === 1) { // new line needed
<                                     words = rest;
<                                     rest = [];
<                                     if (words.length) {
<                                         tspan = doc.createElementNS(SVG_NS, 'tspan');
<                                         attr(tspan, {
<                                             dy: textLineHeight || 16,
<                                             x: parentX
<                                         });
<                                         textNode.appendChild(tspan);
< 								
<                                         if (actualWidth > width) { // a single word is pressing it out
<                                             width = actualWidth;
<                                         }
<                                     }
<                                 } else { // append to existing line tspan
<                                     tspan.removeChild(tspan.firstChild);
<                                     rest.unshift(words.pop());
<                                 }
<                                 if (words.length) {
<                                     tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
<                                 }
<                             }
<                         }
<                     }
<                 });
<             });
< 		
< 		
<         },
< 	
<         /**
< 	 * Make a straight line crisper by not spilling out to neighbour pixels
< 	 * @param {Array} points
< 	 * @param {Number} width 
< 	 */
<         crispLine: function(points, width) {
<             // points format: [M, 0, 0, L, 100, 0]
<             // normalize to a crisp line
<             if (points[1] === points[4]) {
<                 points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
<             }
<             if (points[2] === points[5]) {
<                 points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
<             }
<             return points;
<         },
< 	
< 	
<         /**
< 	 * Draw a path
< 	 * @param {Array} path An SVG path in array form
< 	 */
<         path: function (path) {
<             return this.createElement('path').attr({
<                 d: path,
<                 fill: NONE
<             });
<         },
< 	
<         /**
< 	 * Draw and return an SVG circle
< 	 * @param {Number} x The x position
< 	 * @param {Number} y The y position
< 	 * @param {Number} r The radius
< 	 */
<         circle: function (x, y, r) {
<             var attr = isObject(x) ?
<             x :
<             {
<                 x: x,
<                 y: y,
<                 r: r
<             };
< 		
<             return this.createElement('circle').attr(attr);
<         },
< 	
<         /**
< 	 * Draw and return an arc
< 	 * @param {Number} x X position
< 	 * @param {Number} y Y position
< 	 * @param {Number} r Radius
< 	 * @param {Number} innerR Inner radius like used in donut charts
< 	 * @param {Number} start Starting angle
< 	 * @param {Number} end Ending angle
< 	 */
<         arc: function (x, y, r, innerR, start, end) {
<             // arcs are defined as symbols for the ability to set
<             // attributes in attr and animate
< 		
<             if (isObject(x)) {
<                 y = x.y;
<                 r = x.r;
<                 innerR = x.innerR;
<                 start = x.start;
<                 end = x.end;
<                 x = x.x;
<             }
< 		
<             return this.symbol('arc', x || 0, y || 0, r || 0, {
<                 innerR: innerR || 0,
<                 start: start || 0,
<                 end: end || 0
<             });
<         },
< 	
<         /**
< 	 * Draw and return a rectangle
< 	 * @param {Number} x Left position
< 	 * @param {Number} y Top position
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 * @param {Number} r Border corner radius
< 	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
< 	 */
<         rect: function (x, y, width, height, r, strokeWidth) {
<             if (isObject(x)) {
<                 y = x.y;
<                 width = x.width;
<                 height = x.height;
<                 r = x.r;
<                 strokeWidth = x.strokeWidth;
<                 x = x.x;
<             }
<             var wrapper = this.createElement('rect').attr({
<                 rx: r,
<                 ry: r,
<                 fill: NONE
<             });
< 		
<             return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
<         },
< 	
<         /**
< 	 * Resize the box and re-align all aligned elements
< 	 * @param {Object} width
< 	 * @param {Object} height
< 	 * @param {Boolean} animate
---
> 	tooltipFormatter: function(useHeader) {
> 		var point = this,
> 			series = point.series;
> 				
> 		return ['<span style="color:'+ series.color +'">', (point.name || series.name), '</span>: ',
> 			(!useHeader ? ('<b>x = '+ (point.name || point.x) + ',</b> ') : ''), 
> 			'<b>', (!useHeader ? 'y = ' : '' ), point.y, '</b>'].join('');
> 		
> 	},
> 	
> 	/**
> 	 * Update the point with new options (typically x/y data) and optionally redraw the series.
> 	 * 
> 	 * @param {Object} options Point options as defined in the series.data array
> 	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
> 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
> 	 *    configuration
2514,2579c8392,8412
<         setSize: function(width, height, animate) {
<             var renderer = this,
<             alignedObjects = renderer.alignedObjects,
<             i = alignedObjects.length;
< 		
<             renderer.width = width;
<             renderer.height = height;
< 		
<             renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
<                 width: width,
<                 height: height
<             });
< 		
<             while (i--) {
<                 alignedObjects[i].align();
<             }
<         },
< 	
<         /**
< 	 * Create a group
< 	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
< 	 *     This can be used for styling and scripting.
< 	 */
<         g: function(name) {
<             return this.createElement('g').attr(
<                 defined(name) && {
<                     'class': PREFIX + name
<                 }
<                 );
<         },
< 	
<         /**
< 	 * Display an image
< 	 * @param {String} src
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<         image: function(src, x, y, width, height) {
<             var attribs = {
<                 preserveAspectRatio: NONE
<             },
<             elemWrapper;
< 			
<             // optional properties
<             if (arguments.length > 1) {
<                 extend(attribs, {
<                     x: x,
<                     y: y,
<                     width: width,
<                     height: height
<                 });
<             }
< 		
<             elemWrapper = this.createElement('image').attr(attribs);
< 		
<             // set the href in the xlink namespace
<             if (elemWrapper.element.setAttributeNS) {
<                 elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
<                     'href', src);
<             } else {
<                 // could be exporting in IE
<                 // using href throws "not supported" in ie7 and under, requries regex shim to fix later
<                 elemWrapper.element.setAttribute('hc-svg-href', src);
<             }
---
> 	update: function(options, redraw, animation) {
> 		var point = this,
> 			series = point.series,
> 			dataLabel = point.dataLabel,
> 			graphic = point.graphic,
> 			chart = series.chart;
> 		
> 		redraw = pick(redraw, true);
> 		
> 		// fire the event with a default handler of doing the update
> 		point.firePointEvent('update', { options: options }, function() {
> 
> 			point.applyOptions(options);
> 			
> 			// update visuals
> 			if (isObject(options)) {
> 				series.getAttribs();
> 				if (graphic) {
> 					graphic.attr(point.pointAttr[series.state]);
> 				}
> 			}
2581,2582c8414,8420
<             return elemWrapper;
<         },
---
> 			// redraw
> 			series.isDirty = true;
> 			if (redraw) {
> 				chart.redraw(animation);
> 			}
> 		});
> 	},
2584,2591c8422,8426
<         /**
< 	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
< 	 * 
< 	 * @param {Object} symbol
< 	 * @param {Object} x
< 	 * @param {Object} y
< 	 * @param {Object} radius
< 	 * @param {Object} options
---
> 	/**
> 	 * Remove a point and optionally redraw the series and if necessary the axes
> 	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
> 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
> 	 *    configuration
2593c8428,8435
<         symbol: function(symbol, x, y, radius, options) {
---
> 	remove: function(redraw, animation) {
> 		var point = this,
> 			series = point.series,
> 			chart = series.chart,
> 			data = series.data;
> 		
> 		setAnimation(animation, chart);
> 		redraw = pick(redraw, true);
2595c8437,8440
<             var obj,
---
> 		// fire the event with a default handler of removing the point			
> 		point.firePointEvent('remove', null, function() {
> 
> 			erase(data, point);
2597,8574c8442
<             // get the symbol definition function
<             symbolFn = this.symbols[symbol],
< 			
<             // check if there's a path defined for this symbol
<             path = symbolFn && symbolFn(
<                 mathRound(x),
<                 mathRound(y),
<                 radius,
<                 options
<                 ),
< 			
<             imageRegex = /^url\((.*?)\)$/,
<             imageSrc,
<             imageSize;
< 			
<             if (path) {
< 		
<                 obj = this.path(path);
<                 // expando properties for use in animate and attr
<                 extend(obj, {
<                     symbolName: symbol,
<                     x: x,
<                     y: y,
<                     r: radius
<                 });
<                 if (options) {
<                     extend(obj, options);
<                 }
< 			
< 			
<             // image symbols
<             } else if (imageRegex.test(symbol)) {
< 			
<                 var centerImage = function(img, size) {
<                     img.attr({
<                         width: size[0],
<                         height: size[1]
<                     }).translate(
<                         -mathRound(size[0] / 2),
<                         -mathRound(size[1] / 2)
<                         );
<                 };
< 			
<                 imageSrc = symbol.match(imageRegex)[1];
<                 imageSize = symbolSizes[imageSrc];
< 			
<                 // create the image synchronously, add attribs async
<                 obj = this.image(imageSrc)
<                 .attr({
<                     x: x,
<                     y: y
<                 });
< 
<                 if (imageSize) {
<                     centerImage(obj, imageSize);
<                 } else {
<                     // initialize image to be 0 size so export will still function if there's no cached sizes
<                     obj.attr({
<                         width: 0,
<                         height: 0
<                     });
< 
<                     // create a dummy JavaScript image to get the width and height
<                     createElement('img', {
<                         onload: function() {
<                             var img = this;
<                             centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
<                         },
<                         src: imageSrc
<                     });
<                 }
< 				
<             // default circles
<             } else {
<                 obj = this.circle(x, y, radius);
<             }
< 		
<             return obj;
<         },
< 	
<         /**
< 	 * An extendable collection of functions for defining symbol paths.
< 	 */
<         symbols: {
<             'square': function (x, y, radius) {
<                 var len = 0.707 * radius;
<                 return [
<                 M, x-len, y-len,
<                 L, x+len, y-len,
<                 x+len, y+len,
<                 x-len, y+len,
<                 'Z'
<                 ];
<             },
< 			
<             'triangle': function (x, y, radius) {
<                 return [
<                 M, x, y-1.33 * radius,
<                 L, x+radius, y + 0.67 * radius,
<                 x-radius, y + 0.67 * radius,
<                 'Z'
<                 ];
<             },
< 			
<             'triangle-down': function (x, y, radius) {
<                 return [
<                 M, x, y + 1.33 * radius,
<                 L, x-radius, y-0.67 * radius,
<                 x+radius, y-0.67 * radius,
<                 'Z'
<                 ];
<             },
<             'diamond': function (x, y, radius) {
<                 return [
<                 M, x, y-radius,
<                 L, x+radius, y,
<                 x, y+radius,
<                 x-radius, y,
<                 'Z'
<                 ];
<             },
<             'arc': function (x, y, radius, options) {
<                 var start = options.start,
<                 end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
<                 innerRadius = options.innerR,
<                 cosStart = mathCos(start),
<                 sinStart = mathSin(start),
<                 cosEnd = mathCos(end),
<                 sinEnd = mathSin(end),
<                 longArc = options.end - start < mathPI ? 0 : 1;
< 				
<                 return [
<                 M,
<                 x + radius * cosStart,
<                 y + radius * sinStart,
<                 'A', // arcTo
<                 radius, // x radius
<                 radius, // y radius
<                 0, // slanting
<                 longArc, // long or short arc
<                 1, // clockwise
<                 x + radius * cosEnd,
<                 y + radius * sinEnd,
<                 L,
<                 x + innerRadius * cosEnd,
<                 y + innerRadius * sinEnd,
<                 'A', // arcTo
<                 innerRadius, // x radius
<                 innerRadius, // y radius
<                 0, // slanting
<                 longArc, // long or short arc
<                 0, // clockwise
<                 x + innerRadius * cosStart,
<                 y + innerRadius * sinStart,
< 				
<                 'Z' // close
<                 ];
<             }
<         },
< 	
<         /**
< 	 * Define a clipping rectangle
< 	 * @param {String} id
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<         clipRect: function (x, y, width, height) {
<             var wrapper,
<             id = PREFIX + idCounter++,
< 			
<             clipPath = this.createElement('clipPath').attr({
<                 id: id
<             }).add(this.defs);
< 		
<             wrapper = this.rect(x, y, width, height, 0).add(clipPath);
<             wrapper.id = id;
< 		
<             return wrapper;
<         },
< 	
< 	
<         /**
< 	 * Take a color and return it if it's a string, make it a gradient if it's a
< 	 * gradient configuration object
< 	 * 
< 	 * @param {Object} color The color or config object
< 	 */
<         color: function(color, elem, prop) {
<             var colorObject,
<             regexRgba = /^rgba/;
<             if (color && color.linearGradient) {
<                 var renderer = this,
<                 strLinearGradient = 'linearGradient',
<                 linearGradient = color[strLinearGradient],
<                 id = PREFIX + idCounter++,
<                 gradientObject,
<                 stopColor,
<                 stopOpacity;
<                 gradientObject = renderer.createElement(strLinearGradient).attr({
<                     id: id,
<                     gradientUnits: 'userSpaceOnUse',
<                     x1: linearGradient[0],
<                     y1: linearGradient[1],
<                     x2: linearGradient[2],
<                     y2: linearGradient[3]
<                 }).add(renderer.defs);
< 			
<                 each(color.stops, function(stop) {
<                     if (regexRgba.test(stop[1])) {
<                         colorObject = Color(stop[1]);
<                         stopColor = colorObject.get('rgb');
<                         stopOpacity = colorObject.get('a');
<                     } else {
<                         stopColor = stop[1];
<                         stopOpacity = 1;
<                     }
<                     renderer.createElement('stop').attr({
<                         offset: stop[0],
<                         'stop-color': stopColor,
<                         'stop-opacity': stopOpacity
<                     }).add(gradientObject);
<                 });
< 			
<                 return 'url('+ this.url +'#'+ id +')';
< 			
<             // Webkit and Batik can't show rgba.
<             } else if (regexRgba.test(color)) {
<                 colorObject = Color(color);
<                 attr(elem, prop +'-opacity', colorObject.get('a'));
< 			
<                 return colorObject.get('rgb');
< 			
< 			
<             } else {
<                 return color;
<             }
< 		
<         },
< 	
< 		
<         /**
< 	 * Add text to the SVG object
< 	 * @param {String} str
< 	 * @param {Number} x Left position
< 	 * @param {Number} y Top position
< 	 */
<         text: function(str, x, y) {
< 		
<             // declare variables
<             var defaultChartStyle = defaultOptions.chart.style,
<             wrapper;
< 	
<             x = mathRound(pick(x, 0));
<             y = mathRound(pick(y, 0));
< 		
<             wrapper = this.createElement('text')
<             .attr({
<                 x: x,
<                 y: y,
<                 text: str
<             })
<             .css({
<                 'font-family': defaultChartStyle.fontFamily,
<                 'font-size': defaultChartStyle.fontSize
<             });
< 			
<             wrapper.x = x;
<             wrapper.y = y;
<             return wrapper;
<         }
<     }; // end SVGRenderer
< 
<     // general renderer
<     Renderer = SVGRenderer;
< 
< 
< 
<     /* ****************************************************************************
<  *                                                                            * 
<  * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
<  *                                                                            *
<  * For applications and websites that don't need IE support, like platform    *
<  * targeted mobile apps and web apps, this code can be removed.               *
<  *                                                                            *
<  *****************************************************************************/
<     var VMLRenderer;
<     if (!hasSVG) {
< 
<         /**
<  * The VML element wrapper.
<  */
<         var VMLElement = extendClass( SVGElement, {
< 	
<             /**
< 	 * Initialize a new VML element wrapper. It builds the markup as a string
< 	 * to minimize DOM traffic.
< 	 * @param {Object} renderer
< 	 * @param {Object} nodeName
< 	 */
<             init: function(renderer, nodeName) {
<                 var markup =  ['<', nodeName, ' filled="f" stroked="f"'],
<                 style = ['position: ', ABSOLUTE, ';'];
< 		
<                 // divs and shapes need size
<                 if (nodeName === 'shape' || nodeName === DIV) {
<                     style.push('left:0;top:0;width:10px;height:10px;');
<                 }
<                 if (docMode8) {
<                     style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
<                 }
< 		
<                 markup.push(' style="', style.join(''), '"/>');
< 		
<                 // create element with default attributes and style
<                 if (nodeName) {
<                     markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ?
<                     markup.join('')
<                     : renderer.prepVML(markup);
<                     this.element = createElement(markup);
<                 }
< 		
<                 this.renderer = renderer;
<             },
< 	
<             /**
< 	 * Add the node to the given parent
< 	 * @param {Object} parent
< 	 */
<             add: function(parent) {
<                 var wrapper = this,
<                 renderer = wrapper.renderer,
<                 element = wrapper.element,
<                 box = renderer.box,
<                 inverted = parent && parent.inverted,
< 		
<                 // get the parent node
<                 parentNode = parent ?
<                 parent.element || parent :
<                 box;
< 			
< 			
<                 // if the parent group is inverted, apply inversion on all children
<                 if (inverted) { // only on groups
<                     renderer.invertChild(element, parentNode);
<                 }
< 		
<                 // issue #140 workaround - related to #61 and #74
<                 if (docMode8 && parentNode.gVis === HIDDEN) {
<                     css(element, {
<                         visibility: HIDDEN
<                     });
<                 }
< 		
<                 // append it
<                 parentNode.appendChild(element);
< 		
<                 // align text after adding to be able to read offset
<                 wrapper.added = true;
<                 if (wrapper.alignOnAdd) {
<                     wrapper.updateTransform();
<                 }
< 		
<                 return wrapper;
<             },
< 	
<             /**
< 	 * Get or set attributes
< 	 */
<             attr: function(hash, val) {
<                 var key,
<                 value,
<                 i,
<                 element = this.element || {},
<                 elemStyle = element.style,
<                 nodeName = element.nodeName,
<                 renderer = this.renderer,
<                 symbolName = this.symbolName,
<                 childNodes,
<                 hasSetSymbolSize,
<                 shadows = this.shadows,
<                 skipAttr,
<                 ret = this;
< 			
<                 // single key-value pair
<                 if (isString(hash) && defined(val)) {
<                     key = hash;
<                     hash = {};
<                     hash[key] = val;
<                 }
< 		
<                 // used as a getter, val is undefined
<                 if (isString(hash)) {
<                     key = hash;
<                     if (key === 'strokeWidth' || key === 'stroke-width') {
<                         ret = this.strokeweight;
<                     } else {
<                         ret = this[key];
<                     }
< 			
<                 // setter
<                 } else {
<                     for (key in hash) {
<                         value = hash[key];
<                         skipAttr = false;
< 				
<                         // prepare paths
<                         // symbols
<                         if (symbolName && /^(x|y|r|start|end|width|height|innerR)/.test(key)) {
<                             // if one of the symbol size affecting parameters are changed,
<                             // check all the others only once for each call to an element's
<                             // .attr() method
<                             if (!hasSetSymbolSize) {
<                                 this.symbolAttr(hash);
< 					
<                                 hasSetSymbolSize = true;
<                             }
< 					
<                             skipAttr = true;
< 					
<                         } else if (key === 'd') {
<                             value = value || [];
<                             this.d = value.join(' '); // used in getter for animation
< 					
<                             // convert paths
<                             i = value.length;
<                             var convertedPath = [];
<                             while (i--) {
< 						
<                                 // Multiply by 10 to allow subpixel precision.
<                                 // Substracting half a pixel seems to make the coordinates
<                                 // align with SVG, but this hasn't been tested thoroughly
<                                 if (isNumber(value[i])) {
<                                     convertedPath[i] = mathRound(value[i] * 10) - 5;
<                                 }
<                                 // close the path
<                                 else if (value[i] === 'Z') {
<                                     convertedPath[i] = 'x';
<                                 }
<                                 else {
<                                     convertedPath[i] = value[i];
<                                 }
< 						
<                             }
<                             value = convertedPath.join(' ') || 'x';
<                             element.path = value;
< 			
<                             // update shadows
<                             if (shadows) {
<                                 i = shadows.length;
<                                 while (i--) {
<                                     shadows[i].path = value;
<                                 }
<                             }
<                             skipAttr = true;
< 	
<                         // directly mapped to css
<                         } else if (key === 'zIndex' || key === 'visibility') {
< 					
<                             // issue 61 workaround
<                             if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
<                                 element.gVis = value;
<                                 childNodes = element.childNodes;
<                                 i = childNodes.length;
<                                 while (i--) {
<                                     css(childNodes[i], {
<                                         visibility: value
<                                     });
<                                 }
<                                 if (value === VISIBLE) { // issue 74
<                                     value = null;
<                                 }
<                             }
< 					
<                             if (value) {
<                                 elemStyle[key] = value;
<                             }
< 					
< 					
< 					
<                             skipAttr = true;
< 				
<                         // width and height
<                         } else if (/^(width|height)$/.test(key)) {
< 					
< 										
<                             // clipping rectangle special
<                             if (this.updateClipping) {
<                                 this[key] = value;
<                                 this.updateClipping();
< 						
<                             } else {
<                                 // normal
<                                 elemStyle[key] = value;
<                             }
< 					
<                             skipAttr = true;
< 					
<                         // x and y
<                         } else if (/^(x|y)$/.test(key)) {
< 
<                             this[key] = value; // used in getter
< 					
<                             if (element.tagName === 'SPAN') {
<                                 this.updateTransform();
< 					
<                             } else {
<                                 elemStyle[{
<                                     x: 'left',
<                                     y: 'top'
<                                 }
<                                 [key]] = value;
<                             }
< 					
<                         // class name
<                         } else if (key === 'class') {
<                             // IE8 Standards mode has problems retrieving the className
<                             element.className = value;
< 			
<                         // stroke
<                         } else if (key === 'stroke') {
< 					
<                             value = renderer.color(value, element, key);
< 						
<                             key = 'strokecolor';
< 					
<                         // stroke width
<                         } else if (key === 'stroke-width' || key === 'strokeWidth') {
<                             element.stroked = value ? true : false;
<                             key = 'strokeweight';
<                             this[key] = value; // used in getter, issue #113
<                             if (isNumber(value)) {
<                                 value += PX;
<                             }
< 					
<                         // dashStyle
<                         } else if (key === 'dashstyle') {
<                             var strokeElem = element.getElementsByTagName('stroke')[0] ||
<                             createElement(renderer.prepVML(['<stroke/>']), null, null, element);
<                             strokeElem[key] = value || 'solid';
<                             this.dashstyle = value; /* because changing stroke-width will change the dash length
< 						and cause an epileptic effect */ 
<                             skipAttr = true;
< 					
<                         // fill
<                         } else if (key === 'fill') {
< 					
<                             if (nodeName === 'SPAN') { // text color
<                                 elemStyle.color = value;
<                             } else {
<                                 element.filled = value !== NONE ? true : false;
< 						
<                                 value = renderer.color(value, element, key);
< 						
<                                 key = 'fillcolor';
<                             }
< 				
<                         // translation for animation
<                         } else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'align') {
<                             if (key === 'align') {
<                                 key = 'textAlign';
<                             }
<                             this[key] = value;
<                             this.updateTransform();
< 					
<                             skipAttr = true;
<                         }
< 				
<                         // text for rotated and non-rotated elements
<                         else if (key === 'text') {
<                             this.bBox = null;
<                             element.innerHTML = value;
<                             skipAttr = true;
<                         }
< 				
< 					
<                         // let the shadow follow the main element
<                         if (shadows && key === 'visibility') {
<                             i = shadows.length;
<                             while (i--) {
<                                 shadows[i].style[key] = value;
<                             }
<                         }
< 				
< 				
< 				
<                         if (!skipAttr) {
<                             if (docMode8) { // IE8 setAttribute bug
<                                 element[key] = value;
<                             } else {
<                                 attr(element, key, value);
<                             }
<                         }
<                     }
<                 }
<                 return ret;
<             },
< 	
<             /**
< 	 * Set the element's clipping to a predefined rectangle
< 	 * 
< 	 * @param {String} id The id of the clip rectangle
< 	 */
<             clip: function(clipRect) {
<                 var wrapper = this,
<                 clipMembers = clipRect.members;
< 			
<                 clipMembers.push(wrapper);
<                 wrapper.destroyClip = function() {
<                     erase(clipMembers, wrapper);
<                 };
<                 return wrapper.css(clipRect.getCSS(wrapper.inverted));
<             },
< 	
<             /**
< 	 * Set styles for the element
< 	 * @param {Object} styles
< 	 */
<             css: function(styles) {
<                 var wrapper = this,
<                 element = wrapper.element,
<                 textWidth = styles && element.tagName === 'SPAN' && styles.width;
< 		
<                 /*if (textWidth) {
< 			extend(styles, {
< 				display: 'block',
< 				whiteSpace: 'normal'
< 			});	
< 		}*/
<                 if (textWidth) {
<                     delete styles.width;
<                     wrapper.textWidth = textWidth;
<                     wrapper.updateTransform();
<                 }
< 		
<                 wrapper.styles = extend(wrapper.styles, styles);
<                 css(wrapper.element, styles);
< 		
<                 return wrapper;
<             },
< 	
<             /**
< 	 * Extend element.destroy by removing it from the clip members array
< 	 */
<             destroy: function() {
<                 var wrapper = this;
< 		
<                 if (wrapper.destroyClip) {
<                     wrapper.destroyClip();
<                 }
< 		
<                 SVGElement.prototype.destroy.apply(wrapper);
<             },
< 	
<             /**
< 	 * Remove all child nodes of a group, except the v:group element
< 	 */
<             empty: function() {
<                 var element = this.element,
<                 childNodes = element.childNodes,
<                 i = childNodes.length,
<                 node;
< 			
<                 while (i--) {
<                     node = childNodes[i];
<                     node.parentNode.removeChild(node);
<                 }
<             },
< 	
<             /**
< 	 * VML override for calculating the bounding box based on offsets
< 	 * 
< 	 * @return {Object} A hash containing values for x, y, width and height
< 	 */
< 	
<             getBBox: function() {
<                 var wrapper = this,
<                 element = wrapper.element,
<                 bBox = wrapper.bBox;
< 		
<                 if (!bBox) {
<                     // faking getBBox in exported SVG in legacy IE
<                     if (element.nodeName === 'text') {
<                         element.style.position = ABSOLUTE;
<                     }
< 			
<                     bBox = wrapper.bBox = {
<                         x: element.offsetLeft,
<                         y: element.offsetTop,
<                         width: element.offsetWidth,
<                         height: element.offsetHeight
<                     };
<                 }
<                 return bBox;
< 					
<             },
< 	
<             /**
< 	 * Add an event listener. VML override for normalizing event parameters.
< 	 * @param {String} eventType
< 	 * @param {Function} handler
< 	 */
<             on: function(eventType, handler) {
<                 // simplest possible event model for internal use
<                 this.element['on'+ eventType] = function() {
<                     var evt = win.event;
<                     evt.target = evt.srcElement;
<                     handler(evt);
<                 };
<                 return this;
<             },
< 	
< 	
<             /**
< 	 * VML override private method to update elements based on internal 
< 	 * properties based on SVG transform
< 	 */
<             updateTransform: function(hash) {
<                 // aligning non added elements is expensive
<                 if (!this.added) {
<                     this.alignOnAdd = true;
<                     return;
<                 }
< 		
<                 var wrapper = this,
<                 elem = wrapper.element,
<                 translateX = wrapper.translateX || 0,
<                 translateY = wrapper.translateY || 0,
<                 x = wrapper.x || 0,
<                 y = wrapper.y || 0,
<                 align = wrapper.textAlign || 'left',
<                 alignCorrection = {
<                     left: 0,
<                     center: 0.5,
<                     right: 1
<                 }
<                 [align],
<                 nonLeft = align && align !== 'left';
< 		
<                 // apply translate
<                 if (translateX || translateY) {
<                     wrapper.css({
<                         marginLeft: translateX,
<                         marginTop: translateY
<                     });
<                 }
< 		
<                 // apply inversion
<                 if (wrapper.inverted) { // wrapper is a group
<                     each(elem.childNodes, function(child) {
<                         wrapper.renderer.invertChild(child, elem);
<                     });
<                 }
< 		
<                 if (elem.tagName === 'SPAN') {
< 			
<                     var width, height,
<                     rotation = wrapper.rotation,
<                     lineHeight,
<                     radians = 0,
<                     costheta = 1,
<                     sintheta = 0,
<                     quad,
<                     textWidth = pInt(wrapper.textWidth),
<                     xCorr = wrapper.xCorr || 0,
<                     yCorr = wrapper.yCorr || 0,
<                     currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');
< 				
<                     if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed
< 				
<                         if (defined(rotation)) {
<                             radians = rotation * deg2rad; // deg to rad
<                             costheta = mathCos(radians);
<                             sintheta = mathSin(radians);
< 					 
<                             // Adjust for alignment and rotation.
<                             // Test case: http://highcharts.com/tests/?file=text-rotation
<                             css(elem, {
<                                 filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
<                                 ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
<                                 ', sizingMethod=\'auto expand\')'].join('') : NONE
<                             });
<                         }
< 				
<                         width = elem.offsetWidth;
<                         height = elem.offsetHeight;
< 				
<                         // update textWidth
<                         if (width > textWidth) {
<                             css(elem, {
<                                 width: textWidth +PX,
<                                 display: 'block',
<                                 whiteSpace: 'normal'
<                             });
<                             width = textWidth;
<                         }
< 				
<                         // correct x and y
<                         lineHeight = mathRound((pInt(elem.style.fontSize) || 12) * 1.2);
<                         xCorr = costheta < 0 && -width;
<                         yCorr = sintheta < 0 && -height;
< 				
<                         // correct for lineHeight and corners spilling out after rotation
<                         quad = costheta * sintheta < 0;
<                         xCorr += sintheta * lineHeight * (quad ? 1 - alignCorrection : alignCorrection);
<                         yCorr -= costheta * lineHeight * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
< 				
<                         // correct for the length/height of the text
<                         if (nonLeft) {
<                             xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
<                             if (rotation) {
<                                 yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
<                             }
<                             css(elem, {
<                                 textAlign: align
<                             });
<                         }
< 				
<                         // record correction
<                         wrapper.xCorr = xCorr;
<                         wrapper.yCorr = yCorr;
<                     }
< 			
<                     // apply position with correction
<                     css(elem, {
<                         left: x + xCorr,
<                         top: y + yCorr
<                     });
< 			
<                     // record current text transform
<                     wrapper.cTT = currentTextTransform;
<                 }
<             },
< 	
<             /**
< 	 * Apply a drop shadow by copying elements and giving them different strokes 
< 	 * @param {Boolean} apply
< 	 */
<             shadow: function(apply, group) {
<                 var shadows = [],
<                 i,
<                 element = this.element,
<                 renderer = this.renderer,
<                 shadow,
<                 elemStyle = element.style,
<                 markup,
<                 path = element.path;
< 			
<                 // some times empty paths are not strings
<                 if (path && typeof path.value !== 'string') {
<                     path = 'x';
<                 }
< 			
<                 if (apply) {
<                     for (i = 1; i <= 3; i++) {
<                         markup = ['<shape isShadow="true" strokeweight="', ( 7 - 2 * i ) ,
<                         '" filled="false" path="', path,
<                         '" coordsize="100,100" style="', element.style.cssText, '" />'];
<                         shadow = createElement(renderer.prepVML(markup),
<                             null, {
<                                 left: pInt(elemStyle.left) + 1,
<                                 top: pInt(elemStyle.top) + 1
<                             }
<                             );
< 				
<                         // apply the opacity
<                         markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
<                         createElement(renderer.prepVML(markup), null, null, shadow);
< 				
< 				
<                         // insert it
<                         if (group) {
<                             group.element.appendChild(shadow);
<                         } else {
<                             element.parentNode.insertBefore(shadow, element);
<                         }
< 				
<                         // record it
<                         shadows.push(shadow);
< 				
<                     }
< 			
<                     this.shadows = shadows;
<                 }
<                 return this;
< 	
<             }
<         });
< 	
<         /**
<  * The VML renderer
<  */
<         VMLRenderer = function() {
<             this.init.apply(this, arguments);
<         };
<         VMLRenderer.prototype = merge( SVGRenderer.prototype, { // inherit SVGRenderer
< 	
<             Element: VMLElement,
<             isIE8: userAgent.indexOf('MSIE 8.0') > -1,
< 	
< 
<             /**
< 	 * Initialize the VMLRenderer
< 	 * @param {Object} container
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<             init: function(container, width, height) {
<                 var renderer = this,
<                 boxWrapper;
< 
<                 renderer.alignedObjects = [];
< 		
<                 boxWrapper = renderer.createElement(DIV);
<                 container.appendChild(boxWrapper.element);
< 		
< 		
<                 // generate the containing box
<                 renderer.box = boxWrapper.element;
<                 renderer.boxWrapper = boxWrapper;
< 		
< 		
<                 renderer.setSize(width, height, false);
< 		
<                 // The only way to make IE6 and IE7 print is to use a global namespace. However,
<                 // with IE8 the only way to make the dynamic shapes visible in screen and print mode
<                 // seems to be to add the xmlns attribute and the behaviour style inline.
<                 if (!doc.namespaces.hcv) {
< 			
<                     doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');
< 			
<                     // setup default css
<                     doc.createStyleSheet().cssText =
<                     'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'+
<                 '{ behavior:url(#default#VML); display: inline-block; } ';
< 			
<                 }
<             },
< 	
<             /**
< 	 * Define a clipping rectangle. In VML it is accomplished by storing the values
< 	 * for setting the CSS style to all associated members.
< 	 * 
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<             clipRect: function (x, y, width, height) {
< 				
<                 // create a dummy element
<                 var clipRect = this.createElement();
< 		
<                 // mimic a rectangle with its style object for automatic updating in attr
<                 return extend(clipRect, {
<                     members: [],
<                     left: x,
<                     top: y,
<                     width: width,
<                     height: height,
<                     getCSS: function(inverted) {
<                         var rect = this,//clipRect.element.style,
<                         top = rect.top,
<                         left = rect.left,
<                         right = left + rect.width,
<                         bottom = top + rect.height,
<                         ret = {
<                             clip: 'rect('+
<                             mathRound(inverted ? left : top) + 'px,'+
<                             mathRound(inverted ? bottom : right) + 'px,'+
<                             mathRound(inverted ? right : bottom) + 'px,'+
<                             mathRound(inverted ? top : left) +'px)'
<                         };
< 					
<                         // issue 74 workaround
<                         if (!inverted && docMode8) {
<                             extend(ret, {
<                                 width: right +PX,
<                                 height: bottom +PX
<                             });
<                         }
<                         return ret;
<                     },
< 			
<                     // used in attr and animation to update the clipping of all members
<                     updateClipping: function() {
<                         each(clipRect.members, function(member) {
<                             member.css(clipRect.getCSS(member.inverted));
<                         });
<                     }
<                 });
< 		
<             },
< 	
< 	
<             /**
< 	 * Take a color and return it if it's a string, make it a gradient if it's a
< 	 * gradient configuration object, and apply opacity.
< 	 * 
< 	 * @param {Object} color The color or config object
< 	 */
<             color: function(color, elem, prop) {
<                 var colorObject,
<                 regexRgba = /^rgba/,
<                 markup;
< 			
<                 if (color && color.linearGradient) {
< 			
<                     var stopColor,
<                     stopOpacity,
<                     linearGradient = color.linearGradient,
<                     angle,
<                     color1,
<                     opacity1,
<                     color2,
<                     opacity2;
< 				
<                     each(color.stops, function(stop, i) {
<                         if (regexRgba.test(stop[1])) {
<                             colorObject = Color(stop[1]);
<                             stopColor = colorObject.get('rgb');
<                             stopOpacity = colorObject.get('a');
<                         } else {
<                             stopColor = stop[1];
<                             stopOpacity = 1;
<                         }
< 				
<                         if (!i) { // first
<                             color1 = stopColor;
<                             opacity1 = stopOpacity;
<                         } else {
<                             color2 = stopColor;
<                             opacity2 = stopOpacity;
<                         }
<                     });
< 			
< 			
< 			
<                     // calculate the angle based on the linear vector
<                     angle = 90  - math.atan(
<                         (linearGradient[3] - linearGradient[1]) / // y vector
<                         (linearGradient[2] - linearGradient[0]) // x vector
<                         ) * 180 / mathPI;
< 			
<                     // when colors attribute is used, the meanings of opacity and o:opacity2
<                     // are reversed.
<                     markup = ['<', prop, ' colors="0% ', color1, ',100% ', color2, '" angle="', angle,
<                     '" opacity="', opacity2, '" o:opacity2="', opacity1,
<                     '" type="gradient" focus="100%" />'];
<                     createElement(this.prepVML(markup), null, null, elem);
< 			
< 			
< 		
<                 // if the color is an rgba color, split it and add a fill node
<                 // to hold the opacity component
<                 } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {
< 			
<                     colorObject = Color(color);
< 			
<                     markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
<                     createElement(this.prepVML(markup), null, null, elem);
< 			
<                     return colorObject.get('rgb');
< 			
< 			
<                 } else {
<                     return color;
<                 }
< 		
<             },
< 	
<             /**
< 	 * Take a VML string and prepare it for either IE8 or IE6/IE7. 
< 	 * @param {Array} markup A string array of the VML markup to prepare
< 	 */
<             prepVML: function(markup) {
<                 var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
<                 isIE8 = this.isIE8;
< 	
<                 markup = markup.join('');
< 		
<                 if (isIE8) { // add xmlns and style inline
<                     markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
<                     if (markup.indexOf('style="') === -1) {
<                         markup = markup.replace('/>', ' style="'+ vmlStyle +'" />');
<                     } else {
<                         markup = markup.replace('style="', 'style="'+ vmlStyle);
<                     }
< 
<                 } else { // add namespace
<                     markup = markup.replace('<', '<hcv:');
<                 }
< 
<                 return markup;
<             },
< 	
<             /**
< 	 * Create rotated and aligned text
< 	 * @param {String} str
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 */
<             text: function(str, x, y) {
< 		
<                 var defaultChartStyle = defaultOptions.chart.style;
< 			
<                 return this.createElement('span')
<                 .attr({
<                     text: str,
<                     x: mathRound(x),
<                     y: mathRound(y)
<                 })
<                 .css({
<                     whiteSpace: 'nowrap',
<                     fontFamily: defaultChartStyle.fontFamily,
<                     fontSize: defaultChartStyle.fontSize
<                 });
<             },
< 	
<             /**
< 	 * Create and return a path element
< 	 * @param {Array} path
< 	 */
<             path: function (path) {
<                 // create the shape
<                 return this.createElement('shape').attr({
<                     // subpixel precision down to 0.1 (width and height = 10px)
<                     coordsize: '100 100',
<                     d: path
<                 });
<             },
< 	
<             /**
< 	 * Create and return a circle element. In VML circles are implemented as
< 	 * shapes, which is faster than v:oval
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} r
< 	 */
<             circle: function(x, y, r) {
<                 return this.symbol('circle').attr({
<                     x: x,
<                     y: y,
<                     r: r
<                 });
<             },
< 	
<             /**
< 	 * Create a group using an outer div and an inner v:group to allow rotating 
< 	 * and flipping. A simple v:group would have problems with positioning
< 	 * child HTML elements and CSS clip.
< 	 * 
< 	 * @param {String} name The name of the group
< 	 */
<             g: function(name) {
<                 var wrapper,
<                 attribs;
< 		
<                 // set the class name
<                 if (name) {
<                     attribs = {
<                         'className': PREFIX + name,
<                         'class': PREFIX + name
<                     };
<                 }
< 		
<                 // the div to hold HTML and clipping
<                 wrapper = this.createElement(DIV).attr(attribs);
< 		
<                 return wrapper;
<             },
< 	
<             /**
< 	 * VML override to create a regular HTML image
< 	 * @param {String} src
< 	 * @param {Number} x
< 	 * @param {Number} y
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 */
<             image: function(src, x, y, width, height) {
<                 var obj = this.createElement('img')
<                 .attr({
<                     src: src
<                 });
< 			
<                 if (arguments.length > 1) {
<                     obj.css({
<                         left: x,
<                         top: y,
<                         width: width,
<                         height: height
<                     });
<                 }
<                 return obj;
<             },
< 	
<             /**
< 	 * VML uses a shape for rect to overcome bugs and rotation problems
< 	 */
<             rect: function(x, y, width, height, r, strokeWidth) {
< 		
<                 if (isObject(x)) {
<                     y = x.y;
<                     width = x.width;
<                     height = x.height;
<                     r = x.r;
<                     strokeWidth = x.strokeWidth;
<                     x = x.x;
<                 }
<                 var wrapper = this.symbol('rect');
<                 wrapper.r = r;
< 		
<                 return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
<             },
< 	
<             /**
< 	 * In the VML renderer, each child of an inverted div (group) is inverted
< 	 * @param {Object} element
< 	 * @param {Object} parentNode
< 	 */
<             invertChild: function(element, parentNode) {
<                 var parentStyle = parentNode.style;
< 			
<                 css(element, {
<                     flip: 'x',
<                     left: pInt(parentStyle.width) - 10,
<                     top: pInt(parentStyle.height) - 10,
<                     rotation: -90
<                 });
<             },
< 	
<             /**
< 	 * Symbol definitions that override the parent SVG renderer's symbols
< 	 * 
< 	 */
<             symbols: {
<                 // VML specific arc function
<                 arc: function (x, y, radius, options) {
<                     var start = options.start,
<                     end = options.end,
<                     cosStart = mathCos(start),
<                     sinStart = mathSin(start),
<                     cosEnd = mathCos(end),
<                     sinEnd = mathSin(end),
<                     innerRadius = options.innerR,
<                     circleCorrection = 0.07 / radius,
<                     innerCorrection = (innerRadius && 0.1 / innerRadius) || 0;
< 				
<                     if (end - start === 0) { // no angle, don't show it.
<                         return ['x'];
< 				
<                     //} else if (end - start == 2 * mathPI) { // full circle
<                     } else if (2 * mathPI - end + start < circleCorrection) { // full circle
<                         // empirical correction found by trying out the limits for different radii
<                         cosEnd = - circleCorrection;
<                     } else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
<                         cosEnd = mathCos(start + innerCorrection);
<                     }
< 								
<                     return [
<                     'wa', // clockwise arc to
<                     x - radius, // left
<                     y - radius, // top
<                     x + radius, // right
<                     y + radius, // bottom
<                     x + radius * cosStart, // start x
<                     y + radius * sinStart, // start y
<                     x + radius * cosEnd, // end x
<                     y + radius * sinEnd, // end y
< 				
< 				
<                     'at', // anti clockwise arc to
<                     x - innerRadius, // left
<                     y - innerRadius, // top
<                     x + innerRadius, // right
<                     y + innerRadius, // bottom
<                     x + innerRadius * cosEnd, // start x
<                     y + innerRadius * sinEnd, // start y
<                     x + innerRadius * cosStart, // end x
<                     y + innerRadius * sinStart, // end y
< 				
<                     'x', // finish path
<                     'e' // close
<                     ];
< 			
<                 },
<                 // Add circle symbol path. This performs significantly faster than v:oval.
<                 circle: function (x, y, r) {
<                     return [
<                     'wa', // clockwisearcto
<                     x - r, // left
<                     y - r, // top
<                     x + r, // right
<                     y + r, // bottom
<                     x + r, // start x
<                     y,     // start y
<                     x + r, // end x
<                     y,     // end y
<                     //'x', // finish path
<                     'e' // close
<                     ];
<                 },
<                 /**
< 		 * Add rectangle symbol path which eases rotation and omits arcsize problems
< 		 * compared to the built-in VML roundrect shape
< 		 * 
< 		 * @param {Number} left Left position
< 		 * @param {Number} top Top position
< 		 * @param {Number} r Border radius
< 		 * @param {Object} options Width and height
< 		 */
< 		
<                 rect: function (left, top, r, options) {
<                     if (!defined(options)) {
<                         return [];
<                     }
<                     var width = options.width,
<                     height = options.height,
<                     right = left + width,
<                     bottom = top + height;
< 		
<                     r = mathMin(r, width, height);
< 			
<                     return [
<                     M,
<                     left + r, top,
< 				
<                     L,
<                     right - r, top,
<                     'wa',
<                     right - 2 * r, top,
<                     right, top + 2 * r,
<                     right - r, top,
<                     right, top + r,
< 				
<                     L,
<                     right, bottom - r,
<                     'wa',
<                     right - 2 * r, bottom - 2 * r,
<                     right, bottom,
<                     right, bottom - r,
<                     right - r, bottom,
< 				
<                     L,
<                     left + r, bottom,
<                     'wa',
<                     left, bottom - 2 * r,
<                     left + 2 * r, bottom,
<                     left + r, bottom,
<                     left, bottom - r,
< 				
<                     L,
<                     left, top + r,
<                     'wa',
<                     left, top,
<                     left + 2 * r, top + 2 * r,
<                     left, top + r,
<                     left + r, top,
< 				
< 				
<                     'x',
<                     'e'
<                     ];
< 				
<                 }
<             }
<         });
< 
<         // general renderer
<         Renderer = VMLRenderer;
<     }
<     /* ****************************************************************************
<  *                                                                            * 
<  * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
<  *                                                                            *
<  *****************************************************************************/
< 	
< 
<     /**
<  * The chart class
<  * @param {Object} options
<  * @param {Function} callback Function to run when the chart has loaded
<  */
<     function Chart (options, callback) {
< 	
<         defaultXAxisOptions = merge(defaultXAxisOptions, defaultOptions.xAxis);
<         defaultYAxisOptions = merge(defaultYAxisOptions, defaultOptions.yAxis);
<         defaultOptions.xAxis = defaultOptions.yAxis = null;
< 		
<         // Handle regular options
<         options = merge(defaultOptions, options);
< 	
<         // Define chart variables
<         var optionsChart = options.chart,
<         optionsMargin = optionsChart.margin,
<         margin = isObject(optionsMargin) ?
<         optionsMargin :
<         [optionsMargin, optionsMargin, optionsMargin, optionsMargin],
<         optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
<         optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
<         optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
<         optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
<         spacingTop = optionsChart.spacingTop,
<         spacingRight = optionsChart.spacingRight,
<         spacingBottom = optionsChart.spacingBottom,
<         spacingLeft = optionsChart.spacingLeft,
<         spacingBox,
<         chartTitleOptions,
<         chartSubtitleOptions,
<         plotTop,
<         marginRight,
<         marginBottom,
<         plotLeft,
<         axisOffset,
<         renderTo,
<         renderToClone,
<         container,
<         containerId,
<         containerWidth,
<         containerHeight,
<         chartWidth,
<         chartHeight,
<         oldChartWidth,
<         oldChartHeight,
<         chartBackground,
<         plotBackground,
<         plotBGImage,
<         plotBorder,
<         chart = this,
<         chartEvents = optionsChart.events,
<         runChartClick = chartEvents && !!chartEvents.click,
<         eventType,
<         isInsidePlot, // function
<         tooltip,
<         mouseIsDown,
<         loadingDiv,
<         loadingSpan,
<         loadingShown,
<         plotHeight,
<         plotWidth,
<         tracker,
<         trackerGroup,
<         placeTrackerGroup,
<         legend,
<         legendWidth,
<         legendHeight,
<         chartPosition,// = getPosition(container),
<         hasCartesianSeries = optionsChart.showAxes,
<         isResizing = 0,
<         axes = [],
<         maxTicks, // handle the greatest amount of ticks on grouped axes
<         series = [],
<         inverted,
<         renderer,
<         tooltipTick,
<         tooltipInterval,
<         hoverX,
<         drawChartBox, // function
<         getMargins, // function
<         resetMargins, // function
<         setChartSize, // function
<         resize,
<         zoom, // function
<         zoomOut; // function
< 		
< 
<         /**
< 	 * Create a new axis object
< 	 * @param {Object} chart
< 	 * @param {Object} options
< 	 */
<         function Axis (chart, options) {
< 
<             // Define variables
<             var isXAxis = options.isX,
<             opposite = options.opposite, // needed in setOptions
<             horiz = inverted ? !isXAxis : isXAxis,
<             side = horiz ?
<             (opposite ? 0 /* top */  : 2 /* bottom */) :
<             (opposite ? 1 /* right*/ : 3 /* left */  ),
<             stacks = {};
< 			
< 	
<             options = merge(
<                 isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
<                 [defaultTopAxisOptions, defaultRightAxisOptions,
<                 defaultBottomAxisOptions, defaultLeftAxisOptions][side],
<                 options
<                 );
< 	
<             var axis = this,
<             type = options.type,
<             isDatetimeAxis = type === 'datetime',
<             isLog = type === 'logarithmic',
<             offset = options.offset || 0,
<             xOrY = isXAxis ? 'x' : 'y',
<             axisLength,
<             transA, // translation factor
<             oldTransA, // used for prerendering
<             transB = horiz ? plotLeft : marginBottom, // translation addend
<             translate, // fn
<             getPlotLinePath, // fn
<             axisGroup,
<             gridGroup,
<             axisLine,
<             dataMin,
<             dataMax,
<             associatedSeries,
<             userMin,
<             userMax,
<             max = null,
<             min = null,
<             oldMin,
<             oldMax,
<             minPadding = options.minPadding,
<             maxPadding = options.maxPadding,
<             isLinked = defined(options.linkedTo),
<             ignoreMinPadding, // can be set to true by a column or bar series
<             ignoreMaxPadding,
<             usePercentage,
<             events = options.events,
<             eventType,
<             plotLinesAndBands = [],
<             tickInterval,
<             minorTickInterval,
<             magnitude,
<             tickPositions, // array containing predefined positions
<             ticks = {},
<             minorTicks = {},
<             alternateBands = {},
<             tickAmount,
<             labelOffset,
<             axisTitleMargin,// = options.title.margin,
<             dateTimeLabelFormat,
<             categories = options.categories,
<             labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
<             function() {
<                 var value = this.value,
<                 ret;
< 					
<                 if (dateTimeLabelFormat) { // datetime axis
<                     ret = dateFormat(dateTimeLabelFormat, value);
< 						
<                 } else if (tickInterval % 1000000 === 0) { // use M abbreviation
<                     ret = (value / 1000000) +'M';
< 						
<                 } else if (tickInterval % 1000 === 0) { // use k abbreviation
<                     ret = (value / 1000) +'k';
< 						
<                 } else if (!categories && value >= 1000) { // add thousands separators
<                     ret = numberFormat(value, 0);
< 					
<                 } else { // strings (categories) and small numbers
<                     ret = value;
<                 }
<                 return ret;
<             },
< 				
<             staggerLines = horiz && options.labels.staggerLines,
<             reversed = options.reversed,
<             tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;
< 
<             /**
< 		 * The Tick class
< 		 */
<             function Tick(pos, minor) {
<                 var tick = this;
<                 tick.pos = pos;
<                 tick.minor = minor;
<                 tick.isNew = true;
< 			
<                 if (!minor) {
<                     tick.addLabel();
<                 }
<             }
<             Tick.prototype = {
<                 /**
< 			 * Write the tick label
< 			 */
<                 addLabel: function() {
<                     var pos = this.pos,
<                     labelOptions = options.labels,
<                     str,
<                     withLabel = !((pos === min && !pick(options.showFirstLabel, 1)) ||
<                         (pos === max && !pick(options.showLastLabel, 0))),
<                     width = (categories && horiz && categories.length &&
<                         !labelOptions.step && !labelOptions.staggerLines &&
<                         !labelOptions.rotation &&
<                         plotWidth / categories.length) ||
<                     (!horiz && plotWidth / 2),
<                     css,
<                     label = this.label;
< 					
< 				
<                     // get the string
<                     str = labelFormatter.call({
<                         isFirst: pos === tickPositions[0],
<                         isLast: pos === tickPositions[tickPositions.length - 1],
<                         dateTimeLabelFormat: dateTimeLabelFormat,
<                         value: (categories && categories[pos] ? categories[pos] : pos)
<                     });
< 				
< 				
<                     // prepare CSS
<                     css = width && {
<                         width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) +PX
<                     };
<                     css = extend(css, labelOptions.style);
< 				
<                     // first call
<                     if (label === UNDEFINED) {
<                         this.label =
<                         defined(str) && withLabel && labelOptions.enabled ?
<                         renderer.text(
<                             str,
<                             0,
<                             0
<                             )
<                         .attr({
<                             align: labelOptions.align,
<                             rotation: labelOptions.rotation
<                         })
<                         // without position absolute, IE export sometimes is wrong
<                         .css(css)
<                         .add(axisGroup):
<                         null;
< 							
<                     // update
<                     } else if (label) {
<                         label.attr({
<                             text: str
<                         })
<                         .css(css);
<                     }
<                 },
<                 /**
< 			 * Get the offset height or width of the label
< 			 */
<                 getLabelSize: function() {
<                     var label = this.label;
<                     return label ?
<                     ((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
<                     0;
<                 },
<                 /**
< 			 * Put everything in place
< 			 * 
< 			 * @param index {Number}
< 			 * @param old {Boolean} Use old coordinates to prepare an animation into new position
< 			 */
<                 render: function(index, old) {
<                     var tick = this,
<                     major = !tick.minor,
<                     label = tick.label,
<                     pos = tick.pos,
<                     labelOptions = options.labels,
<                     gridLine = tick.gridLine,
<                     gridLineWidth = major ? options.gridLineWidth : options.minorGridLineWidth,
<                     gridLineColor = major ? options.gridLineColor : options.minorGridLineColor,
<                     dashStyle = major ?
<                     options.gridLineDashStyle :
<                     options.minorGridLineDashStyle,
<                     gridLinePath,
<                     mark = tick.mark,
<                     markPath,
<                     tickLength = major ? options.tickLength : options.minorTickLength,
<                     tickWidth = major ? options.tickWidth : (options.minorTickWidth || 0),
<                     tickColor = major ? options.tickColor : options.minorTickColor,
<                     tickPosition = major ? options.tickPosition : options.minorTickPosition,
<                     step = labelOptions.step,
<                     cHeight = (old && oldChartHeight) || chartHeight,
<                     attribs,
<                     x,
<                     y;
< 					
<                     // get x and y position for ticks and labels
<                     x = horiz ?
<                     translate(pos + tickmarkOffset, null, null, old) + transB :
<                     plotLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - marginRight - plotLeft : 0);
< 					
<                     y = horiz ?
<                     cHeight - marginBottom + offset - (opposite ? plotHeight : 0) :
<                     cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;
< 					
<                     // create the grid line
<                     if (gridLineWidth) {
<                         gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);
< 					
<                         if (gridLine === UNDEFINED) {
<                             attribs = {
<                                 stroke: gridLineColor,
<                                 'stroke-width': gridLineWidth
<                             };
<                             if (dashStyle) {
<                                 attribs.dashstyle = dashStyle;
<                             }
<                             tick.gridLine = gridLine =
<                             gridLineWidth ?
<                             renderer.path(gridLinePath)
<                             .attr(attribs).add(gridGroup) :
<                             null;
<                         }
<                         if (gridLine && gridLinePath) {
<                             gridLine.animate({
<                                 d: gridLinePath
<                             });
<                         }
<                     }
< 				
<                     // create the tick mark
<                     if (tickWidth) {
< 					
<                         // negate the length
<                         if (tickPosition === 'inside') {
<                             tickLength = -tickLength;
<                         }
<                         if (opposite) {
<                             tickLength = -tickLength;
<                         }
< 			
<                         markPath = renderer.crispLine([
<                             M,
<                             x,
<                             y,
<                             L,
<                             x + (horiz ? 0 : -tickLength),
<                             y + (horiz ? tickLength : 0)
<                             ], tickWidth);
< 					
<                         if (mark) { // updating
<                             mark.animate({
<                                 d: markPath
<                             });
<                         } else { // first time
<                             tick.mark = renderer.path(
<                                 markPath
<                                 ).attr({
<                                 stroke: tickColor,
<                                 'stroke-width': tickWidth
<                             }).add(axisGroup);
<                         }
<                     }
< 				
<                     // the label is created on init - now move it into place
<                     if (label && !isNaN(x)) {
<                         x = x + labelOptions.x - (tickmarkOffset && horiz ?
<                             tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
<                         y = y + labelOptions.y - (tickmarkOffset && !horiz ?
<                             tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
< 						
<                         // vertically centered
<                         if (!defined(labelOptions.y)) {
<                             y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
<                         }
< 					
< 						
<                         // correct for staggered labels
<                         if (staggerLines) {
<                             y += (index / (step || 1) % staggerLines) * 16;
<                         }
<                         // apply step
<                         if (step) {
<                             // show those indices dividable by step
<                             label[index % step ? 'hide' : 'show']();
<                         }
< 					
<                         label[tick.isNew ? 'attr' : 'animate']({
<                             x: x,
<                             y: y
<                         });
<                     }
< 				
<                     tick.isNew = false;
<                 },
<                 /**
< 			 * Destructor for the tick prototype
< 			 */
<                 destroy: function() {
<                     var tick = this,
<                     n;
<                     for (n in tick) {
<                         if (tick[n] && tick[n].destroy) {
<                             tick[n].destroy();
<                         }
<                     }
<                 }
<             };
< 		
<             /**
< 		 * The object wrapper for plot lines and plot bands
< 		 * @param {Object} options
< 		 */
<             function PlotLineOrBand(options) {
<                 var plotLine = this;
<                 if (options) {
<                     plotLine.options = options;
<                     plotLine.id = options.id;
<                 }
< 			
<                 //plotLine.render()
<                 return plotLine;
<             }
< 		
<             PlotLineOrBand.prototype = {
< 
<                 /**
< 		 * Render the plot line or plot band. If it is already existing,
< 		 * move it.
< 		 */
<                 render: function () {
<                     var plotLine = this,
<                     options = plotLine.options,
<                     optionsLabel = options.label,
<                     label = plotLine.label,
<                     width = options.width,
<                     to = options.to,
<                     toPath, // bands only
<                     from = options.from,
<                     dashStyle = options.dashStyle,
<                     svgElem = plotLine.svgElem,
<                     path = [],
<                     addEvent,
<                     eventType,
<                     xs,
<                     ys,
<                     x,
<                     y,
<                     color = options.color,
<                     zIndex = options.zIndex,
<                     events = options.events,
<                     attribs;
< 			
<                     // plot line
<                     if (width) {
<                         path = getPlotLinePath(options.value, width);
<                         attribs = {
<                             stroke: color,
<                             'stroke-width': width
<                         };
<                         if (dashStyle) {
<                             attribs.dashstyle = dashStyle;
<                         }
<                     }
< 			
<                     // plot band
<                     else if (defined(from) && defined(to)) {
<                         // keep within plot area
<                         from = mathMax(from, min);
<                         to = mathMin(to, max);
< 			
<                         toPath = getPlotLinePath(to);
<                         path = getPlotLinePath(from);
<                         if (path && toPath) {
<                             path.push(
<                                 toPath[4],
<                                 toPath[5],
<                                 toPath[1],
<                                 toPath[2]
<                                 );
<                         } else { // outside the axis area
<                             path = null;
<                         }
<                         attribs = {
<                             fill: color
<                         };
<                     } else {
<                         return;
<                     }
<                     // zIndex
<                     if (defined(zIndex)) {
<                         attribs.zIndex = zIndex;
<                     }
< 			
<                     // common for lines and bands
<                     if (svgElem) {
<                         if (path) {
<                             svgElem.animate({
<                                 d: path
<                             }, null, svgElem.onGetPath);
<                         } else {
<                             svgElem.hide();
<                             svgElem.onGetPath = function() {
<                                 svgElem.show();
<                             };
<                         }
<                     } else if (path && path.length) {
<                         plotLine.svgElem = svgElem = renderer.path(path)
<                         .attr(attribs).add();
< 					
<                         // events
<                         if (events) {
<                             addEvent = function(eventType) {
<                                 svgElem.on(eventType, function(e) {
<                                     events[eventType].apply(plotLine, [e]);
<                                 });
<                             };
<                             for (eventType in events) {
<                                 addEvent(eventType);
<                             }
<                         }
<                     }
< 			
<                     // the plot band/line label
<                     if (optionsLabel && defined(optionsLabel.text) && path && path.length && plotWidth > 0 && plotHeight > 0) {
<                         // apply defaults
<                         optionsLabel = merge({
<                             align: horiz && toPath && 'center',
<                             x: horiz ? !toPath && 4 : 10,
<                             verticalAlign : !horiz && toPath && 'middle',
<                             y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
<                             rotation: horiz && !toPath && 90
<                         }, optionsLabel);
< 				
<                         // add the SVG element
<                         if (!label) {
<                             plotLine.label = label = renderer.text(
<                                 optionsLabel.text,
<                                 0,
<                                 0
<                                 )
<                             .attr({
<                                 align: optionsLabel.textAlign || optionsLabel.align,
<                                 rotation: optionsLabel.rotation,
<                                 zIndex: zIndex
<                             })
<                             .css(optionsLabel.style)
<                             .add();
<                         }
< 				
<                         // get the bounding box and align the label
<                         xs = [path[1], path[4], pick(path[6], path[1])];
<                         ys = [path[2], path[5], pick(path[7], path[2])];
<                         x = mathMin.apply(math, xs);
<                         y = mathMin.apply(math, ys);
< 				
<                         label.align(optionsLabel, false, {
<                             x: x,
<                             y: y,
<                             width: mathMax.apply(math, xs) - x,
<                             height: mathMax.apply(math, ys) - y
<                         });
<                         label.show();
< 				
<                     } else if (label) { // move out of sight
<                         label.hide();
<                     }
< 			
<                     // chainable
<                     return plotLine;
<                 },
< 		
<                 /**
< 		 * Remove the plot line or band
< 		 */
<                 destroy: function() {
<                     var obj = this,
<                     n;
< 				
<                     for (n in obj) {
<                         if (obj[n] && obj[n].destroy) {
<                             obj[n].destroy(); // destroy SVG wrappers
<                         }
<                         delete obj[n];
<                     }
<                     // remove it from the lookup
<                     erase(plotLinesAndBands, obj);
<                 }
<             };
< 		
<             /**
< 		 * The class for stack items
< 		 */
<             function StackItem(options, isNegative, x) {
<                 var stackItem = this;
< 		
<                 // Tells if the stack is negative
<                 stackItem.isNegative = isNegative;
< 			
<                 // Save the options to be able to style the label
<                 stackItem.options = options;
< 			
<                 // Save the x value to be able to position the label later
<                 stackItem.x = x;
< 			
<                 // The align options and text align varies on whether the stack is negative and
<                 // if the chart is inverted or not.
<                 // First test the user supplied value, then use the dynamic.
<                 stackItem.alignOptions = {
<                     align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
<                     verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
<                     y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
<                     x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
<                 };
< 			
<                 stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
<             }
< 		
<             StackItem.prototype = {
<                 /**
< 			 * Sets the total of this stack. Should be called when a serie is hidden or shown
< 			 * since that will affect the total of other stacks.
< 			 */
<                 setTotal: function(total) {
<                     this.total = total;
<                     this.cum = total;
<                 },
< 
<                 /**
< 			 * Renders the stack total label and adds it to the stack label group.
< 			 */
<                 render: function(group) {
<                     var stackItem = this,									// aliased this
<                     str = stackItem.options.formatter.call(stackItem);	// format the text in the label
< 
<                     // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
<                     if (stackItem.label) {
<                         stackItem.label.attr({
<                             text: str,
<                             visibility: HIDDEN
<                         });
<                     // Create new label
<                     } else {
<                         stackItem.label =
<                         chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
<                         .css(stackItem.options.style)			// apply style
<                         .attr({
<                             align: stackItem.textAlign,			// fix the text-anchor
<                             rotation: stackItem.options.rotation,	// rotation
<                             visibility: HIDDEN
<                         })					// hidden until setOffset is called
<                         .add(group);							// add to the labels-group
<                     }
<                 },
< 
<                 /**
< 			 * Sets the offset that the stack has from the x value and repositions the label.
< 			 */
<                 setOffset: function(xOffset, xWidth) {
<                     var stackItem = this,										// aliased this
<                     neg = stackItem.isNegative,								// special treatment is needed for negative stacks
<                     y = axis.translate(stackItem.total),					// stack value translated mapped to chart coordinates
<                     yZero = axis.translate(0),								// stack origin
<                     h = mathAbs(y - yZero),									// stack height
<                     x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
<                     plotHeight = chart.plotHeight,
<                     stackBox = {	// this is the box for the complete stack
<                         x: inverted ? (neg ? y : y - h) : x,
<                         y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
<                         width: inverted ? h : xWidth,
<                         height: inverted ? xWidth : h
<                     };
< 				
<                     if (stackItem.label) {
<                         stackItem.label
<                         .align(stackItem.alignOptions, null, stackBox)	// align the label to the box
<                         .attr({
<                             visibility: VISIBLE
<                         });					// set visibility
<                     }
<                 }
<             };
< 		
<             /**
< 		 * Get the minimum and maximum for the series of each axis 
< 		 */
<             function getSeriesExtremes() {
<                 var posStack = [],
<                 negStack = [],
<                 run;
< 				
<                 // reset dataMin and dataMax in case we're redrawing
<                 dataMin = dataMax = null;
< 			
<                 // get an overview of what series are associated with this axis
<                 associatedSeries = [];
< 			
<                 each(series, function(serie) {
<                     run = false;
< 				
< 				
<                     // match this axis against the series' given or implicated axis
<                     each(['xAxis', 'yAxis'], function(strAxis) {
<                         if (
<                             // the series is a cartesian type, and...
<                             serie.isCartesian &&
<                             // we're in the right x or y dimension, and...
<                             ((strAxis === 'xAxis' && isXAxis) || (strAxis === 'yAxis' && !isXAxis)) && (
<                                 // the axis number is given in the options and matches this axis index, or
<                                 (serie.options[strAxis] === options.index) ||
<                                 // the axis index is not given
<                                 (serie.options[strAxis] === UNDEFINED && options.index === 0)
<                                 )
<                             ) {
<                             serie[strAxis] = axis;
<                             associatedSeries.push(serie);
< 						
<                             // the series is visible, run the min/max detection
<                             run = true;
<                         }
<                     });
<                     // ignore hidden series if opted
<                     if (!serie.visible && optionsChart.ignoreHiddenSeries) {
<                         run = false;
<                     }
< 				
<                     if (run) {
< 					
<                         var stacking,
<                         posPointStack,
<                         negPointStack,
<                         stackKey,
<                         negKey;
< 		
<                         if (!isXAxis) {
<                             stacking = serie.options.stacking;
<                             usePercentage = stacking === 'percent';
< 	
<                             // create a stack for this particular series type
<                             if (stacking) {
<                                 stackKey = serie.type + pick(serie.options.stack, '');
<                                 negKey = '-'+ stackKey;
<                                 serie.stackKey = stackKey; // used in translate
< 									
<                                 posPointStack = posStack[stackKey] || []; // contains the total values for each x
<                                 posStack[stackKey] = posPointStack;
< 							
<                                 negPointStack = negStack[negKey] || [];
<                                 negStack[negKey] = negPointStack;
<                             }
<                             if (usePercentage) {
<                                 dataMin = 0;
<                                 dataMax = 99;
<                             }
<                         }
<                         if (serie.isCartesian) { // line, column etc. need axes, pie doesn't
<                             each(serie.data, function(point, i) {
<                                 var pointX = point.x,
<                                 pointY = point.y,
<                                 isNegative = pointY < 0,
<                                 pointStack = isNegative ? negPointStack : posPointStack,
<                                 key = isNegative ? negKey : stackKey,
<                                 totalPos,
<                                 pointLow;
< 							
<                                 // initial values
<                                 if (dataMin === null) {
< 
<                                     // start out with the first point
<                                     dataMin = dataMax = point[xOrY];
<                                 }
< 		
<                                 // x axis
<                                 if (isXAxis) {
<                                     if (pointX > dataMax) {
<                                         dataMax = pointX;
<                                     } else if (pointX < dataMin) {
<                                         dataMin = pointX;
<                                     }
<                                 }
< 							
<                                 // y axis
<                                 else if (defined(pointY)) {
<                                     if (stacking) {
<                                         pointStack[pointX] =
<                                         defined(pointStack[pointX]) ?
<                                         pointStack[pointX] + pointY : pointY;
<                                     }
<                                     totalPos = pointStack ? pointStack[pointX] : pointY;
<                                     pointLow = pick(point.low, totalPos);
<                                     if (!usePercentage) {
<                                         if (totalPos > dataMax) {
<                                             dataMax = totalPos;
<                                         } else if (pointLow < dataMin) {
<                                             dataMin = pointLow;
<                                         }
<                                     }
<                                     if (stacking) {
<                                         // add the series
<                                         if (!stacks[key]) {
<                                             stacks[key] = {};
<                                         }
< 									
<                                         // If the StackItem is there, just update the values,
<                                         // if not, create one first
<                                         if (!stacks[key][pointX]) {
<                                             stacks[key][pointX] = new StackItem(options.stackLabels, isNegative, pointX);
<                                         }
<                                         stacks[key][pointX].setTotal(totalPos);
<                                     }
<                                 }
<                             });
< 						
< 							
<                             // For column, areas and bars, set the minimum automatically to zero
<                             // and prevent that minPadding is added in setScale
<                             if (/(area|column|bar)/.test(serie.type) && !isXAxis) {
<                                 var threshold = 0; // use series.options.threshold?
<                                 if (dataMin >= threshold) {
<                                     dataMin = threshold;
<                                     ignoreMinPadding = true;
<                                 } else if (dataMax < threshold) {
<                                     dataMax = threshold;
<                                     ignoreMaxPadding = true;
<                                 }
<                             }
<                         }
<                     }
<                 });
< 			
<             }
< 	
<             /**
< 		 * Translate from axis value to pixel position on the chart, or back
< 		 * 
< 		 */
<             translate = function(val, backwards, cvsCoord, old, handleLog) {
<                 var sign = 1,
<                 cvsOffset = 0,
<                 localA = old ? oldTransA : transA,
<                 localMin = old ? oldMin : min,
<                 returnValue;
< 				
<                 if (!localA) {
<                     localA = transA;
<                 }
< 				
<                 if (cvsCoord) {
<                     sign *= -1; // canvas coordinates inverts the value
<                     cvsOffset = axisLength;
<                 }
<                 if (reversed) { // reversed axis
<                     sign *= -1;
<                     cvsOffset -= sign * axisLength;
<                 }
< 			
<                 if (backwards) { // reverse translation
<                     if (reversed) {
<                         val = axisLength - val;
<                     }
<                     returnValue = val / localA + localMin; // from chart pixel to value
<                     if (isLog && handleLog) {
<                         returnValue = lin2log(returnValue);
<                     }
< 			
<                 } else { // normal translation
<                     if (isLog && handleLog) {
<                         val = log2lin(val);
<                     }
<                     returnValue = sign * (val - localMin) * localA + cvsOffset; // from value to chart pixel
<                 }
< 			
<                 return returnValue;
<             };
< 		
<             /**
< 		 * Create the path for a plot line that goes from the given value on 
< 		 * this axis, across the plot to the opposite side
< 		 * @param {Number} value
< 		 * @param {Number} lineWidth Used for calculation crisp line
< 		 * @param {Number] old Use old coordinates (for resizing and rescaling)
< 		 */
<             getPlotLinePath = function(value, lineWidth, old) {
<                 var x1,
<                 y1,
<                 x2,
<                 y2,
<                 translatedValue = translate(value, null, null, old),
<                 cHeight = (old && oldChartHeight) || chartHeight,
<                 cWidth = (old && oldChartWidth) || chartWidth,
<                 skip;
< 				
<                 x1 = x2 = mathRound(translatedValue + transB);
<                 y1 = y2 = mathRound(cHeight - translatedValue - transB);
< 			
<                 if (isNaN(translatedValue)) { // no min or max
<                     skip = true;
< 			
<                 } else if (horiz) {
<                     y1 = plotTop;
<                     y2 = cHeight - marginBottom;
<                     if (x1 < plotLeft || x1 > plotLeft + plotWidth) {
<                         skip = true;
<                     }
<                 } else {
<                     x1 = plotLeft;
<                     x2 = cWidth - marginRight;
<                     if (y1 < plotTop || y1 > plotTop + plotHeight) {
<                         skip = true;
<                     }
<                 }
<                 return skip ?
<                 null :
<                 renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
<             };
< 		
< 		
<             /**
< 		 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
< 		 * @param {Number} interval
< 		 */
<             function normalizeTickInterval(interval, multiples) {
<                 var normalized, i;
< 				
<                 // round to a tenfold of 1, 2, 2.5 or 5
<                 magnitude = multiples ? 1 : math.pow(10, mathFloor(math.log(interval) / math.LN10));
<                 normalized = interval / magnitude;
< 			
<                 // multiples for a linear scale
<                 if (!multiples) {
<                     multiples = [1, 2, 2.5, 5, 10];
<                     //multiples = [1, 2, 2.5, 4, 5, 7.5, 10];
< 				
<                     // the allowDecimals option
<                     if (options.allowDecimals === false || isLog) {
<                         if (magnitude === 1) {
<                             multiples = [1, 2, 5, 10];
<                         } else if (magnitude <= 0.1) {
<                             multiples = [1 / magnitude];
<                         }
<                     }
<                 }
< 			
<                 // normalize the interval to the nearest multiple
<                 for (i = 0; i < multiples.length; i++) {
<                     interval = multiples[i];
<                     if (normalized <= (multiples[i] + (multiples[i+1] || multiples[i])) / 2) {
<                         break;
<                     }
<                 }
< 			
<                 // multiply back to the correct magnitude
<                 interval *= magnitude;
< 			
<                 return interval;
<             }
< 	
<             /**
< 		 * Set the tick positions to a time unit that makes sense, for example
< 		 * on the first of each month or on every Monday.
< 		 */
<             function setDateTimeTickPositions() {
<                 tickPositions = [];
<                 var i,
<                 useUTC = defaultOptions.global.useUTC,
<                 oneSecond = 1000 / timeFactor,
<                 oneMinute = 60000 / timeFactor,
<                 oneHour = 3600000 / timeFactor,
<                 oneDay = 24 * 3600000 / timeFactor,
<                 oneWeek = 7 * 24 * 3600000 / timeFactor,
<                 oneMonth = 30 * 24 * 3600000 / timeFactor,
<                 oneYear = 31556952000 / timeFactor,
< 			
<                 units = [[
<                 'second',						// unit name
<                 oneSecond,						// fixed incremental unit
<                 [1, 2, 5, 10, 15, 30]			// allowed multiples
<                 ], [
<                 'minute',						// unit name
<                 oneMinute,						// fixed incremental unit
<                 [1, 2, 5, 10, 15, 30]			// allowed multiples
<                 ], [
<                 'hour',							// unit name
<                 oneHour,						// fixed incremental unit
<                 [1, 2, 3, 4, 6, 8, 12]			// allowed multiples
<                 ], [
<                 'day',							// unit name
<                 oneDay,							// fixed incremental unit
<                 [1, 2]							// allowed multiples
<                 ], [
<                 'week',							// unit name
<                 oneWeek,						// fixed incremental unit
<                 [1, 2]							// allowed multiples
<                 ], [
<                 'month',
<                 oneMonth,
<                 [1, 2, 3, 4, 6]
<                 ], [
<                 'year',
<                 oneYear,
<                 null
<                 ]],
< 			
<                 unit = units[6], // default unit is years
<                 interval = unit[1],
<                 multiples = unit[2];
< 			
<                 // loop through the units to find the one that best fits the tickInterval
<                 for (i = 0; i < units.length; i++)  {
<                     unit = units[i];
<                     interval = unit[1];
<                     multiples = unit[2];
< 				
< 				
<                     if (units[i+1]) {
<                         // lessThan is in the middle between the highest multiple and the next unit.
<                         var lessThan = (interval * multiples[multiples.length - 1] +
<                             units[i + 1][1]) / 2;
< 							
<                         // break and keep the current unit
<                         if (tickInterval <= lessThan) {
<                             break;
<                         }
<                     }
<                 }
< 			
<                 // prevent 2.5 years intervals, though 25, 250 etc. are allowed
<                 if (interval === oneYear && tickInterval < 5 * interval) {
<                     multiples = [1, 2, 5];
<                 }
< 	
<                 // get the minimum value by flooring the date
<                 var multitude = normalizeTickInterval(tickInterval / interval, multiples),
<                 minYear, // used in months and years as a basis for Date.UTC()
<                 minDate = new Date(min * timeFactor);
< 				
<                 minDate.setMilliseconds(0);
< 			
<                 if (interval >= oneSecond) { // second
<                     minDate.setSeconds(interval >= oneMinute ? 0 :
<                         multitude * mathFloor(minDate.getSeconds() / multitude));
<                 }
< 	
<                 if (interval >= oneMinute) { // minute
<                     minDate[setMinutes](interval >= oneHour ? 0 :
<                         multitude * mathFloor(minDate[getMinutes]() / multitude));
<                 }
< 	
<                 if (interval >= oneHour) { // hour
<                     minDate[setHours](interval >= oneDay ? 0 :
<                         multitude * mathFloor(minDate[getHours]() / multitude));
<                 }
< 	
<                 if (interval >= oneDay) { // day
<                     minDate[setDate](interval >= oneMonth ? 1 :
<                         multitude * mathFloor(minDate[getDate]() / multitude));
<                 }
< 					
<                 if (interval >= oneMonth) { // month
<                     minDate[setMonth](interval >= oneYear ? 0 :
<                         multitude * mathFloor(minDate[getMonth]() / multitude));
<                     minYear = minDate[getFullYear]();
<                 }
< 			
<                 if (interval >= oneYear) { // year
<                     minYear -= minYear % multitude;
<                     minDate[setFullYear](minYear);
<                 }
< 			
<                 // week is a special case that runs outside the hierarchy
<                 if (interval === oneWeek) {
<                     // get start of current week, independent of multitude
<                     minDate[setDate](minDate[getDate]() - minDate[getDay]() +
<                         options.startOfWeek);
<                 }
< 			
< 			
<                 // get tick positions
<                 i = 1; // prevent crash just in case
<                 minYear = minDate[getFullYear]();
<                 var time = minDate.getTime() / timeFactor,
<                 minMonth = minDate[getMonth](),
<                 minDateDate = minDate[getDate]();
< 				
<                 // iterate and add tick positions at appropriate values
<                 while (time < max && i < plotWidth) {
<                     tickPositions.push(time);
< 				
<                     // if the interval is years, use Date.UTC to increase years
<                     if (interval === oneYear) {
<                         time = makeTime(minYear + i * multitude, 0) / timeFactor;
< 				
<                     // if the interval is months, use Date.UTC to increase months
<                     } else if (interval === oneMonth) {
<                         time = makeTime(minYear, minMonth + i * multitude) / timeFactor;
< 					
<                     // if we're using global time, the interval is not fixed as it jumps
<                     // one hour at the DST crossover
<                     } else if (!useUTC && (interval === oneDay || interval === oneWeek)) {
<                         time = makeTime(minYear, minMonth, minDateDate +
<                             i * multitude * (interval === oneDay ? 1 : 7));
< 					
<                     // else, the interval is fixed and we use simple addition
<                     } else {
<                         time += interval * multitude;
<                     }
< 				
<                     i++;
<                 }
<                 // push the last time
<                 tickPositions.push(time);
< 			
< 			
<                 // dynamic label formatter
<                 dateTimeLabelFormat = options.dateTimeLabelFormats[unit[0]];
<             }
< 			
<             /**
< 		 * Fix JS round off float errors
< 		 * @param {Number} num
< 		 */
<             function correctFloat(num) {
<                 var invMag, ret = num;
<                 magnitude = pick(magnitude, math.pow(10, mathFloor(math.log(tickInterval) / math.LN10)));
< 			
<                 if (magnitude < 1) {
<                     invMag = mathRound(1 / magnitude)  * 10;
<                     ret = mathRound(num * invMag) / invMag;
<                 }
<                 return ret;
<             }
< 				
<             /**
< 		 * Set the tick positions of a linear axis to round values like whole tens or every five.
< 		 */
<             function setLinearTickPositions() {
< 			
<                 var i,
<                 roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
<                 roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval);
< 				
<                 tickPositions = [];
< 			
<                 // populate the intermediate values
<                 i = correctFloat(roundedMin);
<                 while (i <= roundedMax) {
<                     tickPositions.push(i);
<                     i = correctFloat(i + tickInterval);
<                 }
< 			
<             }
< 		
<             /**
< 		 * Set the tick positions to round values and optionally extend the extremes
< 		 * to the nearest tick
< 		 */
<             function setTickPositions(secondPass) {
<                 var length,
<                 catPad,
<                 linkedParent,
<                 linkedParentExtremes,
<                 tickIntervalOption = options.tickInterval,
<                 tickPixelIntervalOption = options.tickPixelInterval,
<                 maxZoom = options.maxZoom || (
<                     isXAxis && !defined(options.min) && !defined(options.max) ?
<                     mathMin(chart.smallestInterval * 5, dataMax - dataMin) :
<                     null
<                     ),
<                 zoomOffset;
< 				
< 			
<                 axisLength = horiz ? plotWidth : plotHeight;
< 			
<                 // linked axis gets the extremes from the parent axis
<                 if (isLinked) {
<                     linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
<                     linkedParentExtremes = linkedParent.getExtremes();
<                     min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
<                     max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
<                 }
< 			
<                 // initial min and max from the extreme data values
<                 else {
<                     min = pick(userMin, options.min, dataMin);
<                     max = pick(userMax, options.max, dataMax);
<                 }
< 			
<                 if (isLog) {
<                     min = log2lin(min);
<                     max = log2lin(max);
<                 }
< 			
<                 // maxZoom exceeded, just center the selection
<                 if (max - min < maxZoom) {
<                     zoomOffset = (maxZoom - max + min) / 2;
<                     // if min and max options have been set, don't go beyond it
<                     min = mathMax(min - zoomOffset, pick(options.min, min - zoomOffset), dataMin);
<                     max = mathMin(min + maxZoom, pick(options.max, min + maxZoom), dataMax);
<                 }
< 				
<                 // pad the values to get clear of the chart's edges
<                 if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
<                     length = (max - min) || 1;
<                     if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) {
<                         min -= length * minPadding;
<                     }
<                     if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) {
<                         max += length * maxPadding;
<                     }
<                 }
< 
<                 // get tickInterval
<                 if (min === max) {
<                     tickInterval = 1;
<                 } else if (isLinked && !tickIntervalOption &&
<                     tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
<                     tickInterval = linkedParent.tickInterval;
<                 } else {
<                     tickInterval = pick(
<                         tickIntervalOption,
<                         categories ? // for categoried axis, 1 is default, for linear axis use tickPix
<                         1 :
<                         (max - min) * tickPixelIntervalOption / axisLength
<                         );
<                 }
< 			
<                 if (!isDatetimeAxis && !defined(options.tickInterval)) { // linear
<                     tickInterval = normalizeTickInterval(tickInterval);
<                 }
<                 axis.tickInterval = tickInterval; // record for linked axis
< 			
<                 // get minorTickInterval
<                 minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
<                 tickInterval / 5 : options.minorTickInterval;
< 			
<                 // find the tick positions
<                 if (isDatetimeAxis)	{
<                     setDateTimeTickPositions();
<                 } else {
<                     setLinearTickPositions();
<                 }
< 			
<                 if (!isLinked) {
<                     // pad categorised axis to nearest half unit
<                     if (categories || (isXAxis && chart.hasColumn)) {
<                         catPad = (categories ? 1 : tickInterval) * 0.5;
<                         if (categories || !defined(pick(options.min, userMin))) {
<                             min -= catPad;
<                         }
<                         if (categories || !defined(pick(options.max, userMax))) {
<                             max += catPad;
<                         }
<                     }
< 				
<                     // reset min/max or remove extremes based on start/end on tick
<                     var roundedMin = tickPositions[0],
<                     roundedMax = tickPositions[tickPositions.length - 1];
< 				
<                     if (options.startOnTick) {
<                         min = roundedMin;
<                     } else if (min > roundedMin) {
<                         tickPositions.shift();
<                     }
< 				
<                     if (options.endOnTick) {
<                         max = roundedMax;
<                     } else if (max < roundedMax) {
<                         tickPositions.pop();
<                     }
< 			
<                     // record the greatest number of ticks for multi axis
<                     if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
<                         maxTicks = {
<                             x: 0,
<                             y: 0
<                         };
<                     }
< 				
<                     if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY]) {
<                         maxTicks[xOrY] = tickPositions.length;
<                     }
<                 }
< 			
< 			
<             }
< 		
<             /**
< 		 * When using multiple axes, adjust the number of ticks to match the highest
< 		 * number of ticks in that group
< 		 */ 
<             function adjustTickAmount() {
< 					
<                 if (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale
<                     var oldTickAmount = tickAmount,
<                     calculatedTickAmount = tickPositions.length;
< 					
<                     // set the axis-level tickAmount to use below
<                     tickAmount = maxTicks[xOrY];
< 				
<                     if (calculatedTickAmount < tickAmount) {
<                         while (tickPositions.length < tickAmount) {
<                             tickPositions.push( correctFloat(
<                                 tickPositions[tickPositions.length - 1] + tickInterval
<                                 ));
<                         }
<                         transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
<                         max = tickPositions[tickPositions.length - 1];
< 				
<                     }
<                     if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
<                         axis.isDirty = true;
<                     }
<                 }
< 			
<             }
< 	
<             /**
< 		 * Set the scale based on data min and max, user set min and max or options
< 		 * 
< 		 */
<             function setScale() {
<                 var type,
<                 i;
< 				
<                 oldMin = min;
<                 oldMax = max;
< 				
<                 // get data extremes if needed
<                 getSeriesExtremes();
< 					
<                 // get fixed positions based on tickInterval
<                 setTickPositions();
< 			
<                 // the translation factor used in translate function
<                 oldTransA = transA;
<                 transA = axisLength / ((max - min) || 1);
< 							
<                 // reset stacks
<                 if (!isXAxis) {
<                     for (type in stacks) {
<                         for (i in stacks[type]) {
<                             stacks[type][i].cum = stacks[type][i].total;
<                         }
<                     }
<                 }
< 
<                 // mark as dirty if it is not already set to dirty and extremes have changed
<                 if (!axis.isDirty) {
<                     axis.isDirty = (min !== oldMin || max !== oldMax);
<                 }
< 			
<             }
< 		
<             /**
< 		 * Set the extremes and optionally redraw
< 		 * @param {Number} newMin
< 		 * @param {Number} newMax
< 		 * @param {Boolean} redraw
< 		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
< 		 *    configuration
< 		 * 
< 		 */
<             function setExtremes(newMin, newMax, redraw, animation) {
< 			
<                 redraw = pick(redraw, true); // defaults to true
< 				
<                 fireEvent(axis, 'setExtremes', { // fire an event to enable syncing of multiple charts
<                     min: newMin,
<                     max: newMax
<                 }, function() { // the default event handler
< 				
<                     userMin = newMin;
<                     userMax = newMax;
< 			
< 				
<                     // redraw
<                     if (redraw) {
<                         chart.redraw(animation);
<                     }
<                 });
< 			
<             }
< 		
<             /**
< 		 * Get the actual axis extremes
< 		 */
<             function getExtremes() {
<                 return {
<                     min: min,
<                     max: max,
<                     dataMin: dataMin,
<                     dataMax: dataMax,
<                     userMin: userMin,
<                     userMax: userMax
<                 };
<             }
< 		
<             /**
< 		 * Get the zero plane either based on zero or on the min or max value.
< 		 * Used in bar and area plots
< 		 */
<             function getThreshold(threshold) {
<                 if (min > threshold) {
<                     threshold = min;
<                 } else if (max < threshold) {
<                     threshold = max;
<                 }
< 			
<                 return translate(threshold, 0, 1);
<             }
< 		
<             /**
< 		 * Add a plot band or plot line after render time
< 		 * 
< 		 * @param options {Object} The plotBand or plotLine configuration object
< 		 */
<             function addPlotBandOrLine(options) {
<                 var obj = new PlotLineOrBand(options).render();
<                 plotLinesAndBands.push(obj);
<                 return obj;
<             }
< 		
<             /**
< 		 * Render the tick labels to a preliminary position to get their sizes
< 		 */
<             function getOffset() {
< 			
<                 var hasData = associatedSeries.length && defined(min) && defined(max),
<                 titleOffset = 0,
<                 titleMargin = 0,
<                 axisTitleOptions = options.title,
<                 labelOptions = options.labels,
<                 directionFactor = [-1, 1, 1, -1][side],
<                 n;
< 			
<                 if (!axisGroup) {
<                     axisGroup = renderer.g('axis')
<                     .attr({
<                         zIndex: 7
<                     })
<                     .add();
<                     gridGroup = renderer.g('grid')
<                     .attr({
<                         zIndex: 1
<                     })
<                     .add();
<                 }
< 			
<                 labelOffset = 0; // reset
< 			
<                 if (hasData || isLinked) {
<                     each(tickPositions, function(pos) {
<                         if (!ticks[pos]) {
<                             ticks[pos] = new Tick(pos);
<                         } else {
<                             ticks[pos].addLabel(); // update labels depending on tick interval
<                         }
< 					
<                         // left side must be align: right and right side must have align: left for labels
<                         if (side === 0 || side === 2 || {
<                             1: 'left',
<                             3: 'right'
<                         }
<                         [side] === labelOptions.align) {
< 					
<                             // get the highest offset
<                             labelOffset = mathMax(
<                                 ticks[pos].getLabelSize(),
<                                 labelOffset
<                                 );
<                         }
< 			
<                     });
< 				
<                     if (staggerLines) {
<                         labelOffset += (staggerLines - 1) * 16;
<                     }
< 			
<                 } else { // doesn't have data
<                     for (n in ticks) {
<                         ticks[n].destroy();
<                         delete ticks[n];
<                     }
<                 }
< 			
<                 if (axisTitleOptions && axisTitleOptions.text) {
<                     if (!axis.axisTitle) {
<                         axis.axisTitle = renderer.text(
<                             axisTitleOptions.text,
<                             0,
<                             0
<                             )
<                         .attr({
<                             zIndex: 7,
<                             rotation: axisTitleOptions.rotation || 0,
<                             align:
<                             axisTitleOptions.textAlign ||
<                             {
<                                 low: 'left',
<                                 middle: 'center',
<                                 high: 'right'
<                             }
<                             [axisTitleOptions.align]
<                         })
<                         .css(axisTitleOptions.style)
<                         .add();
<                     }
< 				
<                     titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
<                     titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
< 				
<                 }
< 			
<                 // handle automatic or user set offset
<                 offset = directionFactor * (options.offset || axisOffset[side]);
< 			
<                 axisTitleMargin =
<                 labelOffset +
<                 (side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x']) +
<                 titleMargin;
< 			
<                 axisOffset[side] = mathMax(
<                     axisOffset[side],
<                     axisTitleMargin + titleOffset + directionFactor * offset
<                     );
< 			
<             }
< 		
<             /**
< 		 * Render the axis
< 		 */
<             function render() {
<                 var axisTitleOptions = options.title,
<                 stackLabelOptions = options.stackLabels,
<                 alternateGridColor = options.alternateGridColor,
<                 lineWidth = options.lineWidth,
<                 lineLeft,
<                 lineTop,
<                 linePath,
<                 hasRendered = chart.hasRendered,
<                 slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
<                 hasData = associatedSeries.length && defined(min) && defined(max);
< 			
<                 // update metrics
<                 axisLength = horiz ? plotWidth : plotHeight;
<                 transA = axisLength / ((max - min) || 1);
<                 transB = horiz ? plotLeft : marginBottom; // translation addend
< 			
<                 // If the series has data draw the ticks. Else only the line and title
<                 if (hasData || isLinked) {
< 				
<                     // minor ticks
<                     if (minorTickInterval && !categories) {
<                         var pos = min + (tickPositions[0] - min) % minorTickInterval;
<                         for (pos; pos <= max; pos += minorTickInterval) {
<                             if (!minorTicks[pos]) {
<                                 minorTicks[pos] = new Tick(pos, true);
<                             }
< 						
<                             // render new ticks in old position
<                             if (slideInTicks && minorTicks[pos].isNew) {
<                                 minorTicks[pos].render(null, true);
<                             }
< 					
< 						
<                             minorTicks[pos].isActive = true;
<                             minorTicks[pos].render();
<                         }
<                     }
< 				
<                     // major ticks
<                     each(tickPositions, function(pos, i) {
<                         // linked axes need an extra check to find out if
<                         if (!isLinked || (pos >= min && pos <= max)) {
< 						
<                             // render new ticks in old position
<                             if (slideInTicks && ticks[pos].isNew) {
<                                 ticks[pos].render(i, true);
<                             }
< 						
<                             ticks[pos].isActive = true;
<                             ticks[pos].render(i);
<                         }
<                     });
< 				
<                     // alternate grid color
<                     if (alternateGridColor) {
<                         each(tickPositions, function(pos, i) {
<                             if (i % 2 === 0 && pos < max) {
<                                 /*plotLinesAndBands.push(new PlotLineOrBand({
< 								from: pos,
< 								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
< 								color: alternateGridColor 
< 							}));*/
< 							
<                                 if (!alternateBands[pos]) {
<                                     alternateBands[pos] = new PlotLineOrBand();
<                                 }
<                                 alternateBands[pos].options = {
<                                     from: pos,
<                                     to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
<                                     color: alternateGridColor
<                                 };
<                                 alternateBands[pos].render();
<                                 alternateBands[pos].isActive = true;
<                             }
<                         });
<                     }
< 				
<                     // custom plot bands (behind grid lines)
<                     /*if (!hasRendered) { // only first time
< 					each(options.plotBands || [], function(plotBandOptions) {
< 						plotLinesAndBands.push(new PlotLineOrBand(
< 							extend({ zIndex: 1 }, plotBandOptions)
< 						).render());
< 					});
< 				}*/
< 				
< 				
< 				
< 				
<                     // custom plot lines and bands
<                     if (!hasRendered) { // only first time
<                         each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
<                             plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
<                         });
<                     }
< 				
< 				
< 			
<                 } // end if hasData
< 			
<                 // remove inactive ticks
<                 each([ticks, minorTicks, alternateBands], function(coll) {
<                     var pos;
<                     for (pos in coll) {
<                         if (!coll[pos].isActive) {
<                             coll[pos].destroy();
<                             delete coll[pos];
<                         } else {
<                             coll[pos].isActive = false; // reset
<                         }
<                     }
<                 });
< 				
< 				
< 			
< 			
<                 // Static items. As the axis group is cleared on subsequent calls
<                 // to render, these items are added outside the group.
<                 // axis line
<                 if (lineWidth) {
<                     lineLeft = plotLeft + (opposite ? plotWidth : 0) + offset;
<                     lineTop = chartHeight - marginBottom - (opposite ? plotHeight : 0) + offset;
< 				
<                     linePath = renderer.crispLine([
<                         M,
<                         horiz ?
<                         plotLeft:
<                         lineLeft,
<                         horiz ?
<                         lineTop:
<                         plotTop,
<                         L,
<                         horiz ?
<                         chartWidth - marginRight :
<                         lineLeft,
<                         horiz ?
<                         lineTop:
<                         chartHeight - marginBottom
<                         ], lineWidth);
<                     if (!axisLine) {
<                         axisLine = renderer.path(linePath)
<                         .attr({
<                             stroke: options.lineColor,
<                             'stroke-width': lineWidth,
<                             zIndex: 7
<                         })
<                         .add();
<                     } else {
<                         axisLine.animate({
<                             d: linePath
<                         });
<                     }
< 					
<                 }
< 			
<                 if (axis.axisTitle) {
<                     // compute anchor points for each of the title align options
<                     var margin = horiz ? plotLeft : plotTop,
<                     fontSize = pInt(axisTitleOptions.style.fontSize || 12),
<                     // the position in the length direction of the axis
<                     alongAxis = {
<                         low: margin + (horiz ? 0 : axisLength),
<                         middle: margin + axisLength / 2,
<                         high: margin + (horiz ? axisLength : 0)
<                     }
<                     [axisTitleOptions.align],
< 				
<                     // the position in the perpendicular direction of the axis
<                     offAxis = (horiz ? plotTop + plotHeight : plotLeft) +
<                     (horiz ? 1 : -1) * // horizontal axis reverses the margin
<                     (opposite ? -1 : 1) * // so does opposite axes
<                     axisTitleMargin +
<                     //(isIE ? fontSize / 3 : 0)+ // preliminary fix for vml's centerline
<                     (side === 2 ? fontSize : 0);
< 				
<                     axis.axisTitle[hasRendered ? 'animate' : 'attr']({
<                         x: horiz ?
<                         alongAxis:
<                         offAxis + (opposite ? plotWidth : 0) + offset +
<                         (axisTitleOptions.x || 0), // x
<                         y: horiz ?
<                         offAxis - (opposite ? plotHeight : 0) + offset:
<                         alongAxis + (axisTitleOptions.y || 0) // y
<                     });
< 				
<                 }
< 			
<                 // Stacked totals:
<                 if (stackLabelOptions && stackLabelOptions.enabled) {
<                     var stackKey, oneStack, stackCategory,
<                     stackTotalGroup = axis.stackTotalGroup;
< 
<                     // Create a separate group for the stack total labels
<                     if (!stackTotalGroup) {
<                         axis.stackTotalGroup = stackTotalGroup =
<                         renderer.g('stack-labels')
<                         .attr({
<                             visibility: VISIBLE,
<                             zIndex: 6
<                         })
<                         .translate(plotLeft, plotTop)
<                         .add();
<                     }
< 
<                     // Render each stack total
<                     for (stackKey in stacks) {
<                         oneStack = stacks[stackKey];
<                         for (stackCategory in oneStack) {
<                             oneStack[stackCategory].render(stackTotalGroup);
<                         }
<                     }
<                 }
<                 // End stacked totals
< 			
<                 axis.isDirty = false;
<             }
< 		
<             /**
< 		 * Remove a plot band or plot line from the chart by id
< 		 * @param {Object} id
< 		 */
<             function removePlotBandOrLine(id) {
<                 var i = plotLinesAndBands.length;
<                 while (i--) {
<                     if (plotLinesAndBands[i].id === id) {
<                         plotLinesAndBands[i].destroy();
<                     }
<                 }
<             }
< 		
<             /**
< 		 * Redraw the axis to reflect changes in the data or axis extremes
< 		 */
<             function redraw() {
< 			
<                 // hide tooltip and hover states
<                 if (tracker.resetTracker) {
<                     tracker.resetTracker();
<                 }
< 		
<                 // render the axis
<                 render();
< 			
<                 // move plot lines and bands
<                 each(plotLinesAndBands, function(plotLine) {
<                     plotLine.render();
<                 });
< 			
<                 // mark associated series as dirty and ready for redraw
<                 each(associatedSeries, function(series) {
<                     series.isDirty = true;
<                 });
< 						
<             }
< 		
<             /**
< 		 * Set new axis categories and optionally redraw
< 		 * @param {Array} newCategories
< 		 * @param {Boolean} doRedraw
< 		 */
<             function setCategories(newCategories, doRedraw) {
<                 // set the categories
<                 axis.categories = categories = newCategories;
< 				
<                 // force reindexing tooltips
<                 each(associatedSeries, function(series) {
<                     series.translate();
<                     series.setTooltipPoints(true);
<                 });
< 				
< 				
<                 // optionally redraw
<                 axis.isDirty = true;
< 				
<                 if (pick(doRedraw, true)) {
<                     chart.redraw();
<                 }
<             }
< 		
< 		
< 		
<             // Run Axis
< 			
<             // inverted charts have reversed xAxes as default
<             if (inverted && isXAxis && reversed === UNDEFINED) {
<                 reversed = true;
<             }
< 		
< 			
<             // expose some variables
<             extend(axis, {
<                 addPlotBand: addPlotBandOrLine,
<                 addPlotLine: addPlotBandOrLine,
<                 adjustTickAmount: adjustTickAmount,
<                 categories: categories,
<                 getExtremes: getExtremes,
<                 getPlotLinePath: getPlotLinePath,
<                 getThreshold: getThreshold,
<                 isXAxis: isXAxis,
<                 options: options,
<                 plotLinesAndBands: plotLinesAndBands,
<                 getOffset: getOffset,
<                 render: render,
<                 setCategories: setCategories,
<                 setExtremes: setExtremes,
<                 setScale: setScale,
<                 setTickPositions: setTickPositions,
<                 translate: translate,
<                 redraw: redraw,
<                 removePlotBand: removePlotBandOrLine,
<                 removePlotLine: removePlotBandOrLine,
<                 reversed: reversed,
<                 stacks: stacks
<             });
< 		
<             // register event listeners
<             for (eventType in events) {
<                 addEvent(axis, eventType, events[eventType]);
<             }
< 		
<             // set min and max
<             setScale();
< 	
<         } // end Axis
< 	
< 	
<         /**
< 	 * The toolbar object
< 	 * 
< 	 * @param {Object} chart 
< 	 */
<         function Toolbar(chart) {
<             var buttons = {};
< 		
<             function add(id, text, title, fn) {
<                 if (!buttons[id]) {
<                     var button = renderer.text(
<                         text,
<                         0,
<                         0
<                         )
<                     .css(options.toolbar.itemStyle)
<                     .align({
<                         align: 'right',
<                         x: - marginRight - 20,
<                         y: plotTop + 30
<                     })
<                     .on('click', fn)
<                     /*.on('touchstart', function(e) {
< 					e.stopPropagation(); // don't fire the container event
< 					fn();
< 				})*/
<                     .attr({
<                         align: 'right',
<                         zIndex: 20
<                     })
<                     .add();
<                     buttons[id] = button;
<                 }
<             }
<             function remove(id) {
<                 discardElement(buttons[id].element);
<                 buttons[id] = null;
<             }
< 		
<             // public
<             return {
<                 add: add,
<                 remove: remove
<             };
<         }
< 	
<         /**
< 	 * The tooltip object
< 	 * @param {Object} options Tooltip options
< 	 */
<         function Tooltip (options) {
<             var currentSeries,
<             borderWidth = options.borderWidth,
<             crosshairsOptions = options.crosshairs,
<             crosshairs = [],
<             style = options.style,
<             shared = options.shared,
<             padding = pInt(style.padding),
<             boxOffLeft = borderWidth + padding, // off left/top position as IE can't
<             //properly handle negative positioned shapes
<             tooltipIsHidden = true,
<             boxWidth,
<             boxHeight,
<             currentX = 0,
<             currentY = 0;
< 			
<             // remove padding CSS and apply padding on box instead
<             style.padding = 0;
< 		
<             // create the elements
<             var group = renderer.g('tooltip')
<             .attr({
<                 zIndex: 8
<             })
<             .add(),
< 			
<             box = renderer.rect(boxOffLeft, boxOffLeft, 0, 0, options.borderRadius, borderWidth)
<             .attr({
<                 fill: options.backgroundColor,
<                 'stroke-width': borderWidth
<             })
<             .add(group)
<             .shadow(options.shadow),
<             label = renderer.text('', padding + boxOffLeft, pInt(style.fontSize) + padding + boxOffLeft)
<             .attr({
<                 zIndex: 1
<             })
<             .css(style)
<             .add(group);
< 				
<             group.hide();
< 				
<             /**
< 		 * In case no user defined formatter is given, this will be used
< 		 */
<             function defaultFormatter() {
<                 var pThis = this,
<                 items = pThis.points || splat(pThis),
<                 xAxis = items[0].series.xAxis,
<                 x = pThis.x,
<                 isDateTime = xAxis && xAxis.options.type === 'datetime',
<                 useHeader = isString(x) || isDateTime,
<                 series,
<                 s;
< 			
<                 // build the header
<                 s = useHeader ?
<                 ['<span style="font-size: 10px">' +
<                 (isDateTime ? dateFormat('%A, %b %e, %Y', x) :  x) +
<                 '</span>'] : [];
< 						
<                 // build the values
<                 each(items, function(item) {
<                     s.push(item.point.tooltipFormatter(useHeader));
<                 });
<                 return s.join('<br/>');
<             }
< 		
<             /**
< 		 * Provide a soft movement for the tooltip
< 		 * 
< 		 * @param {Number} finalX
< 		 * @param {Number} finalY 
< 		 */
<             function move(finalX, finalY) {
< 
<                 currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
<                 currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;
< 			
<                 group.translate(currentX, currentY);
< 			
< 			
<                 // run on next tick of the mouse tracker
<                 if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
<                     tooltipTick = function() {
<                         move(finalX, finalY);
<                     };
<                 } else {
<                     tooltipTick = null;
<                 }
<             }
< 		
<             /**
< 		 * Hide the tooltip
< 		 */
<             function hide() {
<                 if (!tooltipIsHidden) {
<                     var hoverPoints = chart.hoverPoints;
< 				
<                     group.hide();
< 			
<                     each(crosshairs, function(crosshair) {
<                         if (crosshair) {
<                             crosshair.hide();
<                         }
<                     });
< 			
<                     // hide previous hoverPoints and set new
<                     if (hoverPoints) {
<                         each(hoverPoints, function(point) {
<                             point.setState();
<                         });
<                     }
<                     chart.hoverPoints = null;
< 				
< 				
<                     tooltipIsHidden = true;
<                 }
< 					
<             }
< 		
<             /**
< 		 * Refresh the tooltip's text and position. 
< 		 * @param {Object} point
< 		 * 
< 		 */
<             function refresh(point) {
<                 var x,
<                 y,
<                 boxX,
<                 boxY,
<                 show,
<                 bBox,
<                 plotX,
<                 plotY = 0,
<                 textConfig = {},
<                 text,
<                 pointConfig = [],
<                 tooltipPos = point.tooltipPos,
<                 formatter = options.formatter || defaultFormatter,
<                 hoverPoints = chart.hoverPoints;
< 				
<                 // shared tooltip, array is sent over
<                 if (shared) {
< 				
<                     // hide previous hoverPoints and set new
<                     if (hoverPoints) {
<                         each(hoverPoints, function(point) {
<                             point.setState();
<                         });
<                     }
<                     chart.hoverPoints = point;
< 				 
<                     each(point, function(item, i) {
<                         /*var series = item.series,
< 						hoverPoint = series.hoverPoint;
< 					if (hoverPoint) {
< 						hoverPoint.setState();
< 					}
< 					series.hoverPoint = item;*/
<                         item.setState(HOVER_STATE);
<                         plotY += item.plotY; // for average
< 					
<                         pointConfig.push(item.getLabelConfig());
<                     });
< 				
<                     plotX = point[0].plotX;
<                     plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here
< 				
<                     textConfig = {
<                         x: point[0].category
<                     };
<                     textConfig.points = pointConfig;
<                     point = point[0];
< 				
<                 // single point tooltip
<                 } else {
<                     textConfig = point.getLabelConfig();
<                 }
<                 text = formatter.call(textConfig);
< 			
<                 // register the current series
<                 currentSeries = point.series;
< 			
<                 // get the reference point coordinates (pie charts use tooltipPos)
<                 plotX = shared ? plotX : point.plotX;
<                 plotY = shared ? plotY : point.plotY;
<                 x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
<                 y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));
< 				
< 				
<                 // hide tooltip if the point falls outside the plot
<                 show = shared || !point.series.isCartesian || isInsidePlot(x, y);
< 			
<                 // update the inner HTML
<                 if (text === false || !show) {
<                     hide();
<                 } else {
< 				
<                     // show it
<                     if (tooltipIsHidden) {
<                         group.show();
<                         tooltipIsHidden = false;
<                     }
< 				
<                     // update text
<                     label.attr({
<                         text: text
<                     });
< 				
<                     // get the bounding box
<                     bBox = label.getBBox();
<                     boxWidth = bBox.width + 2 * padding;
<                     boxHeight = bBox.height + 2 * padding;
< 
<                     // set the size of the box
<                     box.attr({
<                         width: boxWidth,
<                         height: boxHeight,
<                         stroke: options.borderColor || point.color || currentSeries.color || '#606060'
<                     });
< 				
<                     // keep the box within the chart area
<                     boxX = x - boxWidth + plotLeft - 25;
<                     boxY = y - boxHeight + plotTop + 10;
< 				
<                     // it is too far to the left, adjust it
<                     if (boxX < 7) {
<                         boxX = 7;
<                         boxY -= 30;
<                     }
< 				
< 				
<                     if (boxY < 5) {
<                         boxY = 5; // above
<                     } else if (boxY + boxHeight > chartHeight) {
<                         boxY = chartHeight - boxHeight - 5; // below
<                     }
< 				
<                     // do the move
<                     move(mathRound(boxX - boxOffLeft), mathRound(boxY - boxOffLeft));
< 				
< 				
<                 }
< 			
< 			
<                 // crosshairs
<                 if (crosshairsOptions) {
<                     crosshairsOptions = splat(crosshairsOptions); // [x, y]
< 				
<                     var path,
<                     i = crosshairsOptions.length,
<                     attribs,
<                     axis;
< 				
<                     while (i--) {
<                         axis = point.series[i ? 'yAxis' : 'xAxis'];
<                         if (crosshairsOptions[i] && axis) {
<                             path = axis
<                             .getPlotLinePath(point[i ? 'y' : 'x'], 1);
<                             if (crosshairs[i]) {
<                                 crosshairs[i].attr({
<                                     d: path,
<                                     visibility: VISIBLE
<                                 });
< 						
<                             } else {
<                                 attribs = {
<                                     'stroke-width': crosshairsOptions[i].width || 1,
<                                     stroke: crosshairsOptions[i].color || '#C0C0C0',
<                                     zIndex: 2
<                                 };
<                                 if (crosshairsOptions[i].dashStyle) {
<                                     attribs.dashstyle = crosshairsOptions[i].dashStyle;
<                                 }
<                                 crosshairs[i] = renderer.path(path)
<                                 .attr(attribs)
<                                 .add();
<                             }
<                         }
<                     }
<                 }
<             }
< 		
< 
< 		
<             // public members
<             return {
<                 shared: shared,
<                 refresh: refresh,
<                 hide: hide
<             };
<         }
< 	
<         /**
< 	 * The mouse tracker object
< 	 * @param {Object} chart
< 	 * @param {Object} options
< 	 */
<         function MouseTracker (chart, options) {
< 
< 		
<             var mouseDownX,
<             mouseDownY,
<             hasDragged,
<             selectionMarker,
<             zoomType = optionsChart.zoomType,
<             zoomX = /x/.test(zoomType),
<             zoomY = /y/.test(zoomType),
<             zoomHor = (zoomX && !inverted) || (zoomY && inverted),
<             zoomVert = (zoomY && !inverted) || (zoomX && inverted);
< 			
<             /**
< 		 * Add crossbrowser support for chartX and chartY
< 		 * @param {Object} e The event object in standard browsers
< 		 */
<             function normalizeMouseEvent(e) {
<                 var ePos,
<                 pageZoomFix = isWebKit && doc.width / doc.documentElement.clientWidth - 1,
<                 chartPosLeft,
<                 chartPosTop,
<                 chartX,
<                 chartY;
< 			
<                 // common IE normalizing
<                 e = e || win.event;
<                 if (!e.target) {
<                     e.target = e.srcElement;
<                 }
< 			
<                 // iOS
<                 ePos = e.touches ? e.touches.item(0) : e;
< 			
<                 // in certain cases, get mouse position
<                 if (e.type !== 'mousemove' || win.opera || pageZoomFix) { // only Opera needs position on mouse move, see below
<                     chartPosition = getPosition(container);
<                     chartPosLeft = chartPosition.left;
<                     chartPosTop = chartPosition.top;
<                 }
< 			
<                 // chartX and chartY
<                 if (isIE) { // IE including IE9 that has chartX but in a different meaning
<                     chartX = e.x;
<                     chartY = e.y;
<                 } else {
<                     if (ePos.layerX === UNDEFINED) { // Opera and iOS
<                         chartX = ePos.pageX - chartPosLeft;
<                         chartY = ePos.pageY - chartPosTop;
<                     } else {
<                         chartX = e.layerX;
<                         chartY = e.layerY;
<                     }
<                 }
< 			
<                 // correct for page zoom bug in WebKit
<                 if (pageZoomFix) {
<                     chartX += mathRound((pageZoomFix + 1) * chartPosLeft - chartPosLeft);
<                     chartY += mathRound((pageZoomFix + 1) * chartPosTop - chartPosTop);
<                 }
< 			
<                 return extend(e, {
<                     chartX: chartX,
<                     chartY: chartY
<                 });
<             }
< 		
<             /**
< 		 * Get the click position in terms of axis values.
< 		 * 
< 		 * @param {Object} e A mouse event
< 		 */
<             function getMouseCoordinates(e) {
<                 var coordinates = {
<                     xAxis: [],
<                     yAxis: []
<                 };
<                 each(axes, function(axis, i) {
<                     var translate = axis.translate,
<                     isXAxis = axis.isXAxis,
<                     isHorizontal = inverted ? !isXAxis : isXAxis;
< 					
<                     coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
<                         axis: axis,
<                         value: translate(
<                             isHorizontal ?
<                             e.chartX - plotLeft  :
<                             plotHeight - e.chartY + plotTop,
<                             true
<                             )
<                     });
<                 });
<                 return coordinates;
<             }
< 		
<             /**
< 		 * With line type charts with a single tracker, get the point closest to the mouse
< 		 */
<             function onmousemove (e) {
<                 var point,
<                 points,
<                 hoverPoint = chart.hoverPoint,
<                 hoverSeries = chart.hoverSeries,
<                 i,
<                 j,
<                 distance = chartWidth,
<                 index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?
< 				
<                 // shared tooltip
<                 if (tooltip && options.shared) {
<                     points = [];
< 				
<                     // loop over all series and find the ones with points closest to the mouse
<                     i = series.length;
<                     for (j = 0; j < i; j++) {
<                         if (series[j].visible && series[j].tooltipPoints.length) {
<                             point = series[j].tooltipPoints[index];
<                             point._dist = mathAbs(index - point.plotX);
<                             distance = mathMin(distance, point._dist);
<                             points.push(point);
<                         }
<                     }
<                     // remove furthest points
<                     i = points.length;
<                     while (i--) {
<                         if (points[i]._dist > distance) {
<                             points.splice(i, 1);
<                         }
<                     }
<                     // refresh the tooltip if necessary
<                     if (points.length && (points[0].plotX !== hoverX)) {
<                         tooltip.refresh(points);
<                         hoverX = points[0].plotX;
<                     }
<                 }
< 			
<                 // separate tooltip and general mouse events
<                 if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker
< 		
<                     // get the point
<                     point = hoverSeries.tooltipPoints[index];
< 				
<                     // a new point is hovered, refresh the tooltip
<                     if (point && point !== hoverPoint) {
< 					
<                         // trigger the events
<                         point.onMouseOver();
< 					
<                     }
<                 }
<             }
< 				
< 		
< 		
<             /**
< 		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
< 		 */
<             function resetTracker() {
<                 var hoverSeries = chart.hoverSeries,
<                 hoverPoint = chart.hoverPoint;
< 
<                 if (hoverPoint) {
<                     hoverPoint.onMouseOut();
<                 }
< 			
<                 if (hoverSeries) {
<                     hoverSeries.onMouseOut();
<                 }
< 			
<                 if (tooltip) {
<                     tooltip.hide();
<                 }
< 			
<                 hoverX = null;
<             }
< 		
<             /**
< 		 * Mouse up or outside the plot area
< 		 */
<             function drop() {
<                 if (selectionMarker) {
<                     var selectionData = {
<                         xAxis: [],
<                         yAxis: []
<                     },
<                     selectionBox = selectionMarker.getBBox(),
<                     selectionLeft = selectionBox.x - plotLeft,
<                     selectionTop = selectionBox.y - plotTop;
< 				
< 					
<                     // a selection has been made
<                     if (hasDragged) {
< 					
<                         // record each axis' min and max
<                         each(axes, function(axis, i) {
<                             var translate = axis.translate,
<                             isXAxis = axis.isXAxis,
<                             isHorizontal = inverted ? !isXAxis : isXAxis,
<                             selectionMin = translate(
<                                 isHorizontal ?
<                                 selectionLeft :
<                                 plotHeight - selectionTop - selectionBox.height,
<                                 true,
<                                 0,
<                                 0,
<                                 1
<                                 ),
<                             selectionMax = translate(
<                                 isHorizontal ?
<                                 selectionLeft + selectionBox.width :
<                                 plotHeight - selectionTop,
<                                 true,
<                                 0,
<                                 0,
<                                 1
<                                 );
< 								
<                             selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
<                                 axis: axis,
<                                 min: mathMin(selectionMin, selectionMax), // for reversed axes,
<                                 max: mathMax(selectionMin, selectionMax)
<                             });
< 							
<                         });
<                         fireEvent(chart, 'selection', selectionData, zoom);
< 
<                     }
<                     selectionMarker = selectionMarker.destroy();
<                 }
< 			
<                 chart.mouseIsDown = mouseIsDown = hasDragged = false;
<                 removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
< 
<             }
< 		
<             /**
< 		 * Set the JS events on the container element
< 		 */
<             function setDOMEvents () {
<                 var lastWasOutsidePlot = true;
< 			
<                 /*
< 			 * Record the starting position of a dragoperation
< 			 */
<                 container.onmousedown = function(e) {
<                     e = normalizeMouseEvent(e);
< 				
<                     // record the start position
<                     //e.preventDefault && e.preventDefault();
< 				
<                     chart.mouseIsDown = mouseIsDown = true;
<                     mouseDownX = e.chartX;
<                     mouseDownY = e.chartY;
< 				
<                     addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
<                 };
< 						
<                 // The mousemove, touchmove and touchstart event handler
<                 var mouseMove = function(e) {
< 
<                     // let the system handle multitouch operations like two finger scroll
<                     // and pinching
<                     if (e && e.touches && e.touches.length > 1) {
<                         return;
<                     }
< 				
<                     // normalize
<                     e = normalizeMouseEvent(e);
<                     if (!hasTouch) { // not for touch devices
<                         e.returnValue = false;
<                     }
< 				
<                     var chartX = e.chartX,
<                     chartY = e.chartY,
<                     isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);
< 					
<                     // on touch devices, only trigger click if a handler is defined
<                     if (hasTouch && e.type === 'touchstart') {
<                         if (attr(e.target, 'isTracker')) {
<                             if (!chart.runTrackerClick) {
<                                 e.preventDefault();
<                             }
<                         } else if (!runChartClick && !isOutsidePlot) {
<                             e.preventDefault();
<                         }
<                     }
< 				
<                     // cancel on mouse outside
<                     if (isOutsidePlot) {
< 				
<                         if (!lastWasOutsidePlot) {
<                             // reset the tracker
<                             resetTracker();
<                         }
< 					
<                         // drop the selection if any and reset mouseIsDown and hasDragged
<                         //drop();
<                         if (chartX < plotLeft) {
<                             chartX = plotLeft;
<                         } else if (chartX > plotLeft + plotWidth) {
<                             chartX = plotLeft + plotWidth;
<                         }
< 					
<                         if (chartY < plotTop) {
<                             chartY = plotTop;
<                         } else if (chartY > plotTop + plotHeight) {
<                             chartY = plotTop + plotHeight;
<                         }
< 					
<                     }
< 					
<                     if (mouseIsDown && e.type !== 'touchstart') { // make selection
< 					
<                         // determine if the mouse has moved more than 10px
<                         hasDragged = Math.sqrt(
<                             Math.pow(mouseDownX - chartX, 2) +
<                             Math.pow(mouseDownY - chartY, 2));
<                         if (hasDragged > 10) {
< 					
<                             // make a selection
<                             if (hasCartesianSeries && (zoomX || zoomY) &&
<                                 isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop)) {
<                                 if (!selectionMarker) {
<                                     selectionMarker = renderer.rect(
<                                         plotLeft,
<                                         plotTop,
<                                         zoomHor ? 1 : plotWidth,
<                                         zoomVert ? 1 : plotHeight,
<                                         0
<                                         )
<                                     .attr({
<                                         fill: 'rgba(69,114,167,0.25)',
<                                         zIndex: 7
<                                     })
<                                     .add();
<                                 }
<                             }
< 						
<                             // adjust the width of the selection marker
<                             if (selectionMarker && zoomHor) {
<                                 var xSize = chartX - mouseDownX;
<                                 selectionMarker.attr({
<                                     width: mathAbs(xSize),
<                                     x: (xSize > 0 ? 0 : xSize) + mouseDownX
<                                 });
<                             }
<                             // adjust the height of the selection marker
<                             if (selectionMarker && zoomVert) {
<                                 var ySize = chartY - mouseDownY;
<                                 selectionMarker.attr({
<                                     height: mathAbs(ySize),
<                                     y: (ySize > 0 ? 0 : ySize) + mouseDownY
<                                 });
<                             }
<                         }
< 					
<                     } else if (!isOutsidePlot) {
<                         // show the tooltip
<                         onmousemove(e);
<                     }
< 				
<                     lastWasOutsidePlot = isOutsidePlot;
< 				
<                     // when outside plot, allow touch-drag by returning true
<                     return isOutsidePlot || !hasCartesianSeries;
<                 };
< 			
<                 /*
< 			 * When the mouse enters the container, run mouseMove
< 			 */
<                 container.onmousemove = mouseMove;
< 			
<                 /*
< 			 * When the mouse leaves the container, hide the tracking (tooltip).
< 			 */
<                 addEvent(container, 'mouseleave', resetTracker);
< 			
< 			
<                 container.ontouchstart = function(e) {
<                     // For touch devices, use touchmove to zoom
<                     if (zoomX || zoomY) {
<                         container.onmousedown(e);
<                     }
<                     // Show tooltip and prevent the lower mouse pseudo event
<                     mouseMove(e);
<                 };
< 			
<                 /*
< 			 * Allow dragging the finger over the chart to read the values on touch 
< 			 * devices
< 			 */
<                 container.ontouchmove = mouseMove;
< 			
<                 /*
< 			 * Allow dragging the finger over the chart to read the values on touch 
< 			 * devices
< 			 */
<                 container.ontouchend = function() {
<                     if (hasDragged) {
<                         resetTracker();
<                     }
<                 };
< 			
< 			
<                 // MooTools 1.2.3 doesn't fire this in IE when using addEvent
<                 container.onclick = function(e) {
<                     var hoverPoint = chart.hoverPoint;
<                     e = normalizeMouseEvent(e);
< 				 
<                     e.cancelBubble = true; // IE specific
< 				
< 				
<                     if (!hasDragged) {
<                         if (hoverPoint && attr(e.target, 'isTracker')) {
<                             var plotX = hoverPoint.plotX,
<                             plotY = hoverPoint.plotY;
< 							
<                             // add page position info
<                             extend(hoverPoint, {
<                                 pageX: chartPosition.left + plotLeft +
<                                 (inverted ? plotWidth - plotY : plotX),
<                                 pageY: chartPosition.top + plotTop +
<                                 (inverted ? plotHeight - plotX : plotY)
<                             });
< 						
<                             // the series click event
<                             fireEvent(hoverPoint.series, 'click', extend(e, {
<                                 point: hoverPoint
<                             }));
< 						
<                             // the point click event
<                             hoverPoint.firePointEvent('click', e);
< 					
<                         } else {
<                             extend(e, getMouseCoordinates(e));
< 						
<                             // fire a click event in the chart
<                             if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
<                                 fireEvent(chart, 'click', e);
<                             }
<                         }
< 					
< 					
<                     }
<                     // reset mouseIsDown and hasDragged
<                     hasDragged = false;
<                 };
< 			
<             }
< 		
<             /**
< 		 * Create the image map that listens for mouseovers
< 		 */
<             placeTrackerGroup = function() {
< 			
<                 // first create - plot positions is not final at this stage
<                 if (!trackerGroup) {
<                     chart.trackerGroup = trackerGroup = renderer.g('tracker')
<                     .attr({
<                         zIndex: 9
<                     })
<                     .add();
< 			
<                 // then position - this happens on load and after resizing and changing
<                 // axis or box positions
<                 } else {
<                     trackerGroup.translate(plotLeft, plotTop);
<                     if (inverted) {
<                         trackerGroup.attr({
<                             width: chart.plotWidth,
<                             height: chart.plotHeight
<                         }).invert();
<                     }
<                 }
<             };
< 		
< 		
<             // Run MouseTracker
<             placeTrackerGroup();
<             if (options.enabled) {
<                 chart.tooltip = tooltip = Tooltip(options);
<             }
< 		
<             setDOMEvents();
< 		
<             // set the fixed interval ticking for the smooth tooltip
<             tooltipInterval = setInterval(function() {
<                 if (tooltipTick) {
<                     tooltipTick();
<                 }
<             }, 32);
< 		
<             // expose properties
<             extend(this, {
<                 zoomX: zoomX,
<                 zoomY: zoomY,
<                 resetTracker: resetTracker
<             });
<         }
< 	
< 	
< 	
<         /**
< 	 * The overview of the chart's series
< 	 * @param {Object} chart
< 	 */
<         var Legend = function(chart) {
< 
<             var options = chart.options.legend;
< 			
<             if (!options.enabled) {
<                 return;
<             }
< 		
<             var horizontal = options.layout === 'horizontal',
<             symbolWidth = options.symbolWidth,
<             symbolPadding = options.symbolPadding,
<             allItems,
<             style = options.style,
<             itemStyle = options.itemStyle,
<             itemHoverStyle = options.itemHoverStyle,
<             itemHiddenStyle = options.itemHiddenStyle,
<             padding = pInt(style.padding),
<             rightPadding = 20,
<             //lineHeight = options.lineHeight || 16,
<             y = 18,
<             initialItemX = 4 + padding + symbolWidth + symbolPadding,
<             itemX,
<             itemY,
<             lastItemY,
<             itemHeight = 0,
<             box,
<             legendBorderWidth = options.borderWidth,
<             legendBackgroundColor = options.backgroundColor,
<             legendGroup,
<             offsetWidth,
<             widthOption = options.width,
<             series = chart.series,
<             reversedLegend = options.reversed;
< 			
< 			
< 		
<             /**
< 		 * Set the colors for the legend item
< 		 * @param {Object} item A Series or Point instance
< 		 * @param {Object} visible Dimmed or colored
< 		 */
<             function colorizeItem(item, visible) {
<                 var legendItem = item.legendItem,
<                 legendLine = item.legendLine,
<                 legendSymbol = item.legendSymbol,
<                 hiddenColor = itemHiddenStyle.color,
<                 textColor = visible ? options.itemStyle.color : hiddenColor,
<                 lineColor = visible ? item.color : hiddenColor,
<                 symbolAttr = visible ? item.pointAttr[NORMAL_STATE] : {
<                     stroke: hiddenColor,
<                     fill: hiddenColor
<                 };
< 					
<                 if (legendItem) {
<                     legendItem.css({
<                         fill: textColor
<                     });
<                 }
<                 if (legendLine) {
<                     legendLine.attr({
<                         stroke: lineColor
<                     });
<                 }
<                 if (legendSymbol) {
<                     legendSymbol.attr(symbolAttr);
<                 }
< 			
<             }
< 		
<             /**
< 		 * Position the legend item
< 		 * @param {Object} item A Series or Point instance
< 		 * @param {Object} visible Dimmed or colored
< 		 */
<             function positionItem(item, itemX, itemY) {
<                 var legendItem = item.legendItem,
<                 legendLine = item.legendLine,
<                 legendSymbol = item.legendSymbol,
<                 checkbox = item.checkbox;
<                 if (legendItem) {
<                     legendItem.attr({
<                         x: itemX,
<                         y: itemY
<                     });
<                 }
<                 if (legendLine) {
<                     legendLine.translate(itemX, itemY - 4);
<                 }
<                 if (legendSymbol) {
<                     legendSymbol.attr({
<                         x: itemX + legendSymbol.xOff,
<                         y: itemY + legendSymbol.yOff
<                     });
<                 }
<                 if (checkbox) {
<                     checkbox.x = itemX;
<                     checkbox.y = itemY;
<                 }
<             }
< 		
<             /**
< 		 * Destroy a single legend item
< 		 * @param {Object} item The series or point
< 		 */
<             function destroyItem(item) {
<                 var checkbox = item.checkbox;
< 				
<                 // pull out from the array
<                 //erase(allItems, item);
< 				
<                 // destroy SVG elements
<                 each(['legendItem', 'legendLine', 'legendSymbol'], function(key) {
<                     if (item[key]) {
<                         item[key].destroy();
<                     }
<                 });
< 			
<                 if (checkbox) {
<                     discardElement(item.checkbox);
<                 }
< 			
< 			
<             }
< 		
< 		
<             /**
< 		 * Position the checkboxes after the width is determined
< 		 */ 
<             function positionCheckboxes() {
<                 each(allItems, function(item) {
<                     var checkbox = item.checkbox,
<                     alignAttr = legendGroup.alignAttr;
<                     if (checkbox) {
<                         css(checkbox, {
<                             left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) +PX,
<                             top: (alignAttr.translateY + checkbox.y - 11) + PX
<                         });
<                     }
<                 });
<             }
< 		
<             /**
< 		 * Render a single specific legend item
< 		 * @param {Object} item A series or point
< 		 */
<             function renderItem(item) {
<                 var bBox,
<                 itemWidth,
<                 legendSymbol,
<                 symbolX,
<                 symbolY,
<                 attribs,
<                 simpleSymbol,
<                 li = item.legendItem,
<                 series = item.series || item,
<                 i = allItems.length,
<                 itemOptions = series.options,
<                 strokeWidth = (itemOptions && itemOptions.borderWidth) || 0;
< 			
<                 if (!li) { // generate it once, later move it
< 			
<                     // let these series types use a simple symbol
<                     simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);
< 				
<                     // generate the list item text
<                     item.legendItem = li = renderer.text(
<                         options.labelFormatter.call(item),
<                         0,
<                         0
<                         )
<                     .css(item.visible ? itemStyle : itemHiddenStyle)
<                     .on('mouseover', function() {
<                         item.setState(HOVER_STATE);
<                         li.css(itemHoverStyle);
<                     })
<                     .on('mouseout', function() {
<                         li.css(item.visible ? itemStyle : itemHiddenStyle);
<                         item.setState();
<                     })
<                     .on('click', function(event) {
<                         var strLegendItemClick = 'legendItemClick',
<                         fnLegendItemClick = function() {
<                             item.setVisible();
<                         };
< 						
<                         // click the name or symbol
<                         if (item.firePointEvent) { // point
<                             item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
<                         } else {
<                             fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
<                         }
<                     })
<                     .attr({
<                         zIndex: 2
<                     })
<                     .add(legendGroup);
< 				
<                     // draw the line
<                     if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
<                         var attrs = {
<                             'stroke-width': itemOptions.lineWidth,
<                             zIndex: 2
<                         };
<                         if (itemOptions.dashStyle) {
<                             attrs.dashstyle = itemOptions.dashStyle;
<                         }
<                         item.legendLine = renderer.path([
<                             M,
<                             -symbolWidth - symbolPadding,
<                             0,
<                             L,
<                             -symbolPadding,
<                             0
<                             ])
<                         .attr(attrs)
<                         .add(legendGroup);
<                     }
< 					
<                     // draw a simple symbol
<                     if (simpleSymbol) { // bar|pie|area|column
< 					
<                         legendSymbol = renderer.rect(
<                             (symbolX = -symbolWidth - symbolPadding),
<                             (symbolY = -11),
<                             symbolWidth,
<                             12,
<                             2
<                             ).attr({
<                             //'stroke-width': 0,
<                             zIndex: 3
<                         }).add(legendGroup);
<                     }
< 					
<                     // draw the marker
<                     else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) {
<                         legendSymbol = renderer.symbol(
<                             item.symbol,
<                             (symbolX = -symbolWidth / 2 - symbolPadding),
<                             (symbolY = -4),
<                             itemOptions.marker.radius
<                             )
<                         //.attr(item.pointAttr[NORMAL_STATE])
<                         .attr({
<                             zIndex: 3
<                         })
<                         .add(legendGroup);
< 				
<                     }
<                     if (legendSymbol) {
<                         legendSymbol.xOff = symbolX + (strokeWidth % 2 / 2);
<                         legendSymbol.yOff = symbolY + (strokeWidth % 2 / 2);
<                     }
< 				
<                     item.legendSymbol = legendSymbol;
< 					
<                     // colorize the items
<                     colorizeItem(item, item.visible);
< 				
< 				
<                     // add the HTML checkbox on top
<                     if (itemOptions && itemOptions.showCheckbox) {
<                         item.checkbox = createElement('input', {
<                             type: 'checkbox',
<                             checked: item.selected,
<                             defaultChecked: item.selected // required by IE7
<                         }, options.itemCheckboxStyle, container);
< 					
<                         addEvent(item.checkbox, 'click', function(event) {
<                             var target = event.target;
<                             fireEvent(item, 'checkboxClick', {
<                                 checked: target.checked
<                             },
<                             function() {
<                                 item.select();
<                             }
<                             );
<                         });
<                     }
<                 }
< 			
< 			
<                 // calculate the positions for the next line
<                 bBox = li.getBBox();
< 			
<                 itemWidth = item.legendItemWidth =
<                 options.itemWidth || symbolWidth + symbolPadding + bBox.width + rightPadding;
<                 itemHeight = bBox.height;
< 			
<                 // if the item exceeds the width, start a new line
<                 if (horizontal && itemX - initialItemX + itemWidth >
<                     (widthOption || (chartWidth - 2 * padding - initialItemX))) {
<                     itemX = initialItemX;
<                     itemY += itemHeight;
<                 }
<                 lastItemY = itemY;
< 			
<                 // position the newly generated or reordered items
<                 positionItem(item, itemX, itemY);
< 			
<                 // advance
<                 if (horizontal)  {
<                     itemX += itemWidth;
<                 } else {
<                     itemY += itemHeight;
<                 }
< 			
<                 // the width of the widest item
<                 offsetWidth = widthOption || mathMax(
<                     horizontal ? itemX - initialItemX : itemWidth,
<                     offsetWidth
<                     );
< 			
< 					
< 			
<             // add it all to an array to use below
<             //allItems.push(item);
<             }
< 
<             /**
< 		 * Render the legend. This method can be called both before and after
< 		 * chart.render. If called after, it will only rearrange items instead
< 		 * of creating new ones.
< 		 */
<             function renderLegend() {
<                 itemX = initialItemX;
<                 itemY = y;
<                 offsetWidth = 0;
<                 lastItemY = 0;
< 			
<                 if (!legendGroup) {
<                     legendGroup = renderer.g('legend')
<                     .attr({
<                         zIndex: 7
<                     })
<                     .add();
<                 }
< 			
< 			
<                 // add each series or point
<                 allItems = [];
<                 each(series, function(serie) {
<                     var seriesOptions = serie.options;
< 				
<                     if (!seriesOptions.showInLegend) {
<                         return;
<                     }
< 				
<                     // use points or series for the legend item depending on legendType
<                     allItems = allItems.concat(seriesOptions.legendType === 'point' ?
<                         serie.data :
<                         serie
<                         );
< 				
<                 });
< 			
<                 // sort by legendIndex
<                 allItems.sort(function(a, b) {
<                     return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
<                 });
< 			
<                 // reversed legend
<                 if (reversedLegend) {
<                     allItems.reverse();
<                 }
< 			
<                 // render the items
<                 each(allItems, renderItem);
< 			
< 			
< 			
<                 // Draw the border
<                 legendWidth = widthOption || offsetWidth;
<                 legendHeight = lastItemY - y + itemHeight;
< 			
<                 if (legendBorderWidth || legendBackgroundColor) {
<                     legendWidth += 2 * padding;
<                     legendHeight += 2 * padding;
< 				
<                     if (!box) {
<                         box = renderer.rect(
<                             0,
<                             0,
<                             legendWidth,
<                             legendHeight,
<                             options.borderRadius,
<                             legendBorderWidth || 0
<                             ).attr({
<                             stroke: options.borderColor,
<                             'stroke-width': legendBorderWidth || 0,
<                             fill: legendBackgroundColor || NONE
<                         })
<                         .add(legendGroup)
<                         .shadow(options.shadow);
< 				
<                     } else if (legendWidth > 0 && legendHeight > 0) {
<                         box.animate(
<                             box.crisp(null, null, null, legendWidth, legendHeight)
<                             );
<                     }
< 				
<                     // hide the border if no items
<                     box[allItems.length ? 'show' : 'hide']();
<                 }
< 			
<                 // 1.x compatibility: positioning based on style
<                 var props = ['left', 'right', 'top', 'bottom'],
<                 prop,
<                 i = 4;
<                 while(i--) {
<                     prop = props[i];
<                     if (style[prop] && style[prop] !== 'auto') {
<                         options[i < 2 ? 'align' : 'verticalAlign'] = prop;
<                         options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
<                     }
<                 }
< 			
<                 legendGroup.align(extend(options, {
<                     width: legendWidth,
<                     height: legendHeight
<                 }), true, spacingBox);
< 			
<                 if (!isResizing) {
<                     positionCheckboxes();
<                 }
<             }
< 		
< 		
<             // run legend
<             renderLegend();
< 		
<             // move checkboxes
<             addEvent(chart, 'endResize', positionCheckboxes);
< 		
<             // expose
<             return {
<                 colorizeItem: colorizeItem,
<                 destroyItem: destroyItem,
<                 renderLegend: renderLegend
<             };
<         };
< 	
< 	
< 	
< 		
< 	
< 
<         /**
< 	 * Initialize an individual series, called internally before render time
< 	 */
<         function initSeries(options) {
<             var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
<             typeClass = seriesTypes[type],
<             serie,
<             hasRendered = chart.hasRendered;
< 			
<             // an inverted chart can't take a column series and vice versa
<             if (hasRendered) {
<                 if (inverted && type === 'column') {
<                     typeClass = seriesTypes.bar;
<                 } else if (!inverted && type === 'bar') {
<                     typeClass = seriesTypes.column;
<                 }
<             }
< 		
<             serie = new typeClass();
< 		
<             serie.init(chart, options);
< 		
<             // set internal chart properties
<             if (!hasRendered && serie.inverted) {
<                 inverted = true;
<             }
<             if (serie.isCartesian) {
<                 hasCartesianSeries = serie.isCartesian;
<             }
< 		
<             series.push(serie);
< 		
<             return serie;
<         }
< 
<         /**
< 	 * Add a series dynamically after  time
< 	 * 
< 	 * @param {Object} options The config options
< 	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
< 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
< 	 *    configuration
< 	 * 
< 	 * @return {Object} series The newly created series object
< 	 */
<         function addSeries(options, redraw, animation) {
<             var series;
< 		
<             if (options) {
<                 setAnimation(animation, chart);
<                 redraw = pick(redraw, true); // defaults to true
< 			
<                 fireEvent(chart, 'addSeries', {
<                     options: options
<                 }, function() {
<                     series = initSeries(options);
<                     series.isDirty = true;
< 				
<                     chart.isDirtyLegend = true; // the series array is out of sync with the display
<                     if (redraw) {
<                         chart.redraw();
<                     }
<                 });
<             }
< 		
<             return series;
<         }
< 	
<         /**
< 	 * Check whether a given point is within the plot area
< 	 * 
< 	 * @param {Number} x Pixel x relative to the coordinateSystem
< 	 * @param {Number} y Pixel y relative to the coordinateSystem
< 	 */
<         isInsidePlot = function(x, y) {
<             return x >= 0 &&
<             x <= plotWidth &&
<             y >= 0 &&
<             y <= plotHeight;
<         };
< 		
<         /**
< 	 * Adjust all axes tick amounts
< 	 */
<         function adjustTickAmounts() {
<             if (optionsChart.alignTicks !== false) {
<                 each(axes, function(axis) {
<                     axis.adjustTickAmount();
<                 });
<             }
<             maxTicks = null;
<         }
< 
<         /**
< 	 * Redraw legend, axes or series based on updated data
< 	 * 
< 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
< 	 *    configuration
< 	 */
<         function redraw(animation) {
<             var redrawLegend = chart.isDirtyLegend,
<             hasStackedSeries,
<             isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
<             seriesLength = series.length,
<             i = seriesLength,
<             clipRect = chart.clipRect,
<             serie;
< 			
<             setAnimation(animation, chart);
< 		
<             // link stacked series
<             while (i--) {
<                 serie = series[i];
<                 if (serie.isDirty && serie.options.stacking) {
<                     hasStackedSeries = true;
<                     break;
<                 }
<             }
<             if (hasStackedSeries) { // mark others as dirty
<                 i = seriesLength;
<                 while (i--) {
<                     serie = series[i];
<                     if (serie.options.stacking) {
<                         serie.isDirty = true;
<                     }
<                 }
<             }
< 		
<             // handle updated data in the series
<             each(series, function(serie) {
<                 if (serie.isDirty) { // prepare the data so axis can read it
<                     serie.cleanData();
<                     serie.getSegments();
< 				
<                     if (serie.options.legendType === 'point') {
<                         redrawLegend = true;
<                     }
<                 }
<             });
< 		
<             // handle added or removed series
<             if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
<                 // draw legend graphics
<                 legend.renderLegend();
< 			
<                 chart.isDirtyLegend = false;
<             }
< 				
<             if (hasCartesianSeries) {
<                 if (!isResizing) {
< 				
<                     // reset maxTicks
<                     maxTicks = null;
< 				
<                     // set axes scales
<                     each(axes, function(axis) {
<                         axis.setScale();
<                     });
<                 }
<                 adjustTickAmounts();
<                 getMargins();
< 	
<                 // redraw axes
<                 each(axes, function(axis) {
<                     if (axis.isDirty || isDirtyBox) {
<                         axis.redraw();
<                         isDirtyBox = true; // always redraw box to reflect changes in the axis labels
<                     }
<                 });
< 			
< 			
<             }
< 		
<             // the plot areas size has changed
<             if (isDirtyBox) {
<                 drawChartBox();
<                 placeTrackerGroup();
< 			
<                 // move clip rect
<                 if (clipRect) {
<                     stop(clipRect);
<                     clipRect.animate({ // for chart resize
<                         width: chart.plotSizeX,
<                         height: chart.plotSizeY
<                     });
<                 }
< 		
<             }
< 		
< 					
<             // redraw affected series
<             each(series, function(serie) {
<                 if (serie.isDirty && serie.visible &&
<                     (!serie.isCartesian || serie.xAxis)) { // issue #153
<                     serie.redraw();
<                 }
<             });
< 		
< 		
<             // hide tooltip and hover states
<             if (tracker && tracker.resetTracker) {
<                 tracker.resetTracker();
<             }
< 		
<             // fire the event
<             fireEvent(chart, 'redraw');
<         }
< 	
< 	
< 	
<         /**
< 	 * Dim the chart and show a loading text or symbol
< 	 * @param {String} str An optional text to show in the loading label instead of the default one
< 	 */
<         function showLoading(str) {
<             var loadingOptions = options.loading;
< 
<             // create the layer at the first call
<             if (!loadingDiv) {
<                 loadingDiv = createElement(DIV, {
<                     className: 'highcharts-loading'
<                 }, extend(loadingOptions.style, {
<                     left: plotLeft + PX,
<                     top: plotTop + PX,
<                     width: plotWidth + PX,
<                     height: plotHeight + PX,
<                     zIndex: 10,
<                     display: NONE
<                 }), container);
< 			
<                 loadingSpan = createElement(
<                     'span',
<                     null,
<                     loadingOptions.labelStyle,
<                     loadingDiv
<                     );
< 
<             }
< 		
<             // update text
<             loadingSpan.innerHTML = str || options.lang.loading;
< 		
<             // show it
<             if (!loadingShown) {
<                 css(loadingDiv, {
<                     opacity: 0,
<                     display: ''
<                 });
<                 animate(loadingDiv, {
<                     opacity: loadingOptions.style.opacity
<                 }, {
<                     duration: loadingOptions.showDuration
<                 });
<                 loadingShown = true;
<             }
<         }
<         /**
< 	 * Hide the loading layer
< 	 */
<         function hideLoading() {
<             animate(loadingDiv, {
<                 opacity: 0
<             }, {
<                 duration: options.loading.hideDuration,
<                 complete: function() {
<                     css(loadingDiv, {
<                         display: NONE
<                     });
<                 }
<             });
<             loadingShown = false;
<         }
< 	
<         /**
< 	 * Get an axis, series or point object by id.
< 	 * @param id {String} The id as given in the configuration options
< 	 */
<         function get(id) {
<             var i,
<             j,
<             data;
< 		
<             // search axes
<             for (i = 0; i < axes.length; i++) {
<                 if (axes[i].options.id === id) {
<                     return axes[i];
<                 }
<             }
< 		
<             // search series
<             for (i = 0; i < series.length; i++) {
<                 if (series[i].options.id === id) {
<                     return series[i];
<                 }
<             }
< 		
<             // search points
<             for (i = 0; i < series.length; i++) {
<                 data = series[i].data;
<                 for (j = 0; j < data.length; j++) {
<                     if (data[j].id === id) {
<                         return data[j];
<                     }
<                 }
<             }
<             return null;
<         }
< 	
<         /**
< 	 * Create the Axis instances based on the config options
< 	 */
<         function getAxes() {
<             var xAxisOptions = options.xAxis || {},
<             yAxisOptions = options.yAxis || {},
<             axis;
< 			
<             // make sure the options are arrays and add some members
<             xAxisOptions = splat(xAxisOptions);
<             each(xAxisOptions, function(axis, i) {
<                 axis.index = i;
<                 axis.isX = true;
<             });
< 		
<             yAxisOptions = splat(yAxisOptions);
<             each(yAxisOptions, function(axis, i) {
<                 axis.index = i;
<             });
< 		
<             // concatenate all axis options into one array
<             axes = xAxisOptions.concat(yAxisOptions);
< 		
<             // loop the options and construct axis objects
<             chart.xAxis = [];
<             chart.yAxis = [];
<             axes = map(axes, function(axisOptions) {
<                 axis = new Axis(chart, axisOptions);
<                 chart[axis.isXAxis ? 'xAxis' : 'yAxis'].push(axis);
< 			
<                 return axis;
<             });
< 		
<             adjustTickAmounts();
<         }
< 
< 	
<         /**
< 	 * Get the currently selected points from all series
< 	 */
<         function getSelectedPoints() {
<             var points = [];
<             each(series, function(serie) {
<                 points = points.concat( grep( serie.data, function(point) {
<                     return point.selected;
<                 }));
<             });
<             return points;
<         }
< 	
<         /**
< 	 * Get the currently selected series
< 	 */
<         function getSelectedSeries() {
<             return grep(series, function (serie) {
<                 return serie.selected;
<             });
<         }
< 	
<         /**
< 	 * Zoom out to 1:1
< 	 */
<         zoomOut = function () {
<             fireEvent(chart, 'selection', {
<                 resetSelection: true
<             }, zoom);
<             chart.toolbar.remove('zoom');
< 
<         };
<         /**
< 	 * Zoom into a given portion of the chart given by axis coordinates
< 	 * @param {Object} event
< 	 */
<         zoom = function (event) {
< 		
<             // add button to reset selection
<             var lang = defaultOptions.lang,
<             animate = chart.pointCount < 100;
<             chart.toolbar.add('zoom', lang.resetZoom, lang.resetZoomTitle, zoomOut);
< 		
<             // if zoom is called with no arguments, reset the axes
<             if (!event || event.resetSelection) {
<                 each(axes, function(axis) {
<                     axis.setExtremes(null, null, false, animate);
<                 });
<             }
< 			
<             // else, zoom in on all axes
<             else {
<                 each(event.xAxis.concat(event.yAxis), function(axisData) {
<                     var axis = axisData.axis;
< 				
<                     // don't zoom more than maxZoom
<                     if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
<                         axis.setExtremes(axisData.min, axisData.max, false, animate);
<                     }
<                 });
<             }
< 		
<             // redraw chart
<             redraw();
<         };
< 	
<         /**
< 	 * Show the title and subtitle of the chart
< 	 * 
< 	 * @param titleOptions {Object} New title options
< 	 * @param subtitleOptions {Object} New subtitle options
< 	 * 
< 	 */
<         function setTitle (titleOptions, subtitleOptions) {
< 		
<             chartTitleOptions = merge(options.title, titleOptions);
<             chartSubtitleOptions = merge(options.subtitle, subtitleOptions);
< 		
<             // add title and subtitle
<             each([
<                 ['title', titleOptions, chartTitleOptions],
<                 ['subtitle', subtitleOptions, chartSubtitleOptions]
<                 ], function(arr) {
<                     var name = arr[0],
<                     title = chart[name],
<                     titleOptions = arr[1],
<                     chartTitleOptions = arr[2];
< 				
<                     if (title && titleOptions) {
<                         title.destroy(); // remove old
<                         title = null;
<                     }
<                     if (chartTitleOptions && chartTitleOptions.text && !title) {
<                         chart[name] = renderer.text(
<                             chartTitleOptions.text,
<                             0,
<                             0
<                             )
<                         .attr({
<                             align: chartTitleOptions.align,
<                             'class': 'highcharts-'+ name,
<                             zIndex: 1
<                         })
<                         .css(chartTitleOptions.style)
<                         .add()
<                         .align(chartTitleOptions, false, spacingBox);
<                     }
<                 });
< 		
<         }
< 	
<         /**
< 	 * Get chart width and height according to options and container size
< 	 */
<         function getChartSize() {
< 
<             containerWidth = (renderToClone || renderTo).offsetWidth;
<             containerHeight = (renderToClone || renderTo).offsetHeight;
<             chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
<             chart.chartHeight = chartHeight = optionsChart.height ||
<             // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
<             (containerHeight > 19 ? containerHeight : 400);
<         }
< 
< 	
<         /**
< 	 * Get the containing element, determine the size and create the inner container
< 	 * div to hold the chart
< 	 */
<         function getContainer() {
<             renderTo = optionsChart.renderTo;
<             containerId = PREFIX + idCounter++;
< 	
<             if (isString(renderTo)) {
<                 renderTo = doc.getElementById(renderTo);
<             }
< 	
<             // remove previous chart
<             renderTo.innerHTML = '';
< 		
<             // If the container doesn't have an offsetWidth, it has or is a child of a node
<             // that has display:none. We need to temporarily move it out to a visible
<             // state to determine the size, else the legend and tooltips won't render
<             // properly
<             if (!renderTo.offsetWidth) {
<                 renderToClone = renderTo.cloneNode(0);
<                 css(renderToClone, {
<                     position: ABSOLUTE,
<                     top: '-9999px',
<                     display: ''
<                 });
<                 doc.body.appendChild(renderToClone);
<             }
< 		
<             // get the width and height
<             getChartSize();
< 		
<             // create the inner container
<             chart.container = container = createElement(DIV, {
<                 className: 'highcharts-container' +
<                 (optionsChart.className ? ' '+ optionsChart.className : ''),
<                 id: containerId
<             }, extend({
<                 position: RELATIVE,
<                 overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
<                 // content overflow in IE
<                 width: chartWidth + PX,
<                 height: chartHeight + PX,
<                 textAlign: 'left'
<             }, optionsChart.style),
<             renderToClone || renderTo
<             );
< 		
<             chart.renderer = renderer =
<             optionsChart.forExport ? // force SVG, used for SVG export
<             new SVGRenderer(container, chartWidth, chartHeight, true) :
<             new Renderer(container, chartWidth, chartHeight);
< 				
<             // Issue 110 workaround:
<             // In Firefox, if a div is positioned by percentage, its pixel position may land
<             // between pixels. The container itself doesn't display this, but an SVG element
<             // inside this container will be drawn at subpixel precision. In order to draw
<             // sharp lines, this must be compensated for. This doesn't seem to work inside
<             // iframes though (like in jsFiddle).
<             var subPixelFix, rect;
<             if (isFirefox && container.getBoundingClientRect) {
<                 subPixelFix = function() {
<                     css(container, {
<                         left: 0,
<                         top: 0
<                     });
<                     rect = container.getBoundingClientRect();
<                     css(container, {
<                         left: (-(rect.left - pInt(rect.left))) + PX,
<                         top: (-(rect.top - pInt(rect.top))) + PX
<                     });
<                 };
< 			
<                 // run the fix now
<                 subPixelFix();
< 			
<                 // run it on resize
<                 addEvent(win, 'resize', subPixelFix);
< 			
<                 // remove it on chart destroy
<                 addEvent(chart, 'destroy', function() {
<                     removeEvent(win, 'resize', subPixelFix);
<                 });
<             }
<         }
< 	
<         /**
< 	 * Calculate margins by rendering axis labels in a preliminary position. Title,
< 	 * subtitle and legend have already been rendered at this stage, but will be 
< 	 * moved into their final positions
< 	 */
<         getMargins = function() {
<             var legendOptions = options.legend,
<             legendMargin = pick(legendOptions.margin, 10),
<             legendX = legendOptions.x,
<             legendY = legendOptions.y,
<             align = legendOptions.align,
<             verticalAlign = legendOptions.verticalAlign,
<             titleOffset;
< 
<             resetMargins();
< 
<             // adjust for title and subtitle
<             if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
<                 titleOffset = mathMax(
<                     (chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0,
<                     (chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0
<                     );
<                 if (titleOffset) {
<                     plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
<                 }
<             }
<             // adjust for legend
<             if (legendOptions.enabled && !legendOptions.floating) {
<                 if (align === 'right') { // horizontal alignment handled first
<                     if (!defined(optionsMarginRight)) {
<                         marginRight = mathMax(
<                             marginRight,
<                             legendWidth - legendX + legendMargin + spacingRight
<                             );
<                     }
<                 } else if (align === 'left') {
<                     if (!defined(optionsMarginLeft)) {
<                         plotLeft = mathMax(
<                             plotLeft,
<                             legendWidth + legendX + legendMargin + spacingLeft
<                             );
<                     }
< 				
<                 } else if (verticalAlign === 'top') {
<                     if (!defined(optionsMarginTop)) {
<                         plotTop = mathMax(
<                             plotTop,
<                             legendHeight + legendY + legendMargin + spacingTop
<                             );
<                     }
< 			
<                 } else if (verticalAlign === 'bottom') {
<                     if (!defined(optionsMarginBottom)) {
<                         marginBottom = mathMax(
<                             marginBottom,
<                             legendHeight - legendY + legendMargin + spacingBottom
<                             );
<                     }
<                 }
<             }
< 		
<             // pre-render axes to get labels offset width
<             if (hasCartesianSeries) {
<                 each(axes, function(axis) {
<                     axis.getOffset();
<                 });
<             }
< 		
<             if (!defined(optionsMarginLeft)) {
<                 plotLeft += axisOffset[3];
<             }
<             if (!defined(optionsMarginTop)) {
<                 plotTop += axisOffset[0];
<             }
<             if (!defined(optionsMarginBottom)) {
<                 marginBottom += axisOffset[2];
<             }
<             if (!defined(optionsMarginRight)) {
<                 marginRight += axisOffset[1];
<             }
< 		
<             setChartSize();
< 		
<         };
< 	
<         /**
< 	 * Add the event handlers necessary for auto resizing
< 	 * 
< 	 */
<         function initReflow() {
<             var reflowTimeout;
<             function reflow() {
<                 var width = optionsChart.width || renderTo.offsetWidth,
<                 height = optionsChart.height || renderTo.offsetHeight;
< 			
<                 if (width && height) { // means container is display:none
<                     if (width !== containerWidth || height !== containerHeight) {
<                         clearTimeout(reflowTimeout);
<                         reflowTimeout = setTimeout(function() {
<                             resize(width, height, false);
<                         }, 100);
<                     }
<                     containerWidth = width;
<                     containerHeight = height;
<                 }
<             }
<             addEvent(win, 'resize', reflow);
<             addEvent(chart, 'destroy', function() {
<                 removeEvent(win, 'resize', reflow);
<             });
<         }
< 	
<         /**
< 	 * Resize the chart to a given width and height
< 	 * @param {Number} width
< 	 * @param {Number} height
< 	 * @param {Object|Boolean} animation
< 	 */
<         resize = function(width, height, animation) {
<             var chartTitle = chart.title,
<             chartSubtitle = chart.subtitle;
< 		
<             isResizing += 1;
< 		
<             // set the animation for the current process
<             setAnimation(animation, chart);
< 		
<             oldChartHeight = chartHeight;
<             oldChartWidth = chartWidth;
<             chart.chartWidth = chartWidth = mathRound(width);
<             chart.chartHeight = chartHeight = mathRound(height);
< 		
<             css(container, {
<                 width: chartWidth + PX,
<                 height: chartHeight + PX
<             });
<             renderer.setSize(chartWidth, chartHeight, animation);
< 		
<             // update axis lengths for more correct tick intervals:
<             plotWidth = chartWidth - plotLeft - marginRight;
<             plotHeight = chartHeight - plotTop - marginBottom;
< 		
<             // handle axes
<             maxTicks = null;
<             each(axes, function(axis) {
<                 axis.isDirty = true;
<                 axis.setScale();
<             });
< 		
<             // make sure non-cartesian series are also handled
<             each(series, function(serie) {
<                 serie.isDirty = true;
<             });
< 		
<             chart.isDirtyLegend = true; // force legend redraw
<             chart.isDirtyBox = true; // force redraw of plot and chart border
< 		
<             getMargins();
< 		 
<             // move titles
<             if (chartTitle) {
<                 chartTitle.align(null, null, spacingBox);
<             }
<             if (chartSubtitle) {
<                 chartSubtitle.align(null, null, spacingBox);
<             }
< 		
<             redraw(animation);
< 		
< 		
<             oldChartHeight = null;
<             fireEvent(chart, 'resize');
< 		
<             // fire endResize and set isResizing back
<             setTimeout(function() {
<                 fireEvent(chart, 'endResize', null, function() {
<                     isResizing -= 1;
<                 });
<             }, (globalAnimation && globalAnimation.duration) || 500);
<         };
< 	
<         /**
< 	 * Set the public chart properties. This is done before and after the pre-render
< 	 * to determine margin sizes
< 	 */
<         setChartSize = function() {
< 		
<             chart.plotLeft = plotLeft = mathRound(plotLeft);
<             chart.plotTop = plotTop = mathRound(plotTop);
<             chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
<             chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);
< 		
<             chart.plotSizeX = inverted ? plotHeight : plotWidth;
<             chart.plotSizeY = inverted ? plotWidth : plotHeight;
< 		
<             spacingBox = {
<                 x: spacingLeft,
<                 y: spacingTop,
<                 width: chartWidth - spacingLeft - spacingRight,
<                 height: chartHeight - spacingTop - spacingBottom
<             };
<         };
< 	
<         /**
< 	 * Initial margins before auto size margins are applied
< 	 */
<         resetMargins = function() {
<             plotTop = pick(optionsMarginTop, spacingTop);
<             marginRight = pick(optionsMarginRight, spacingRight);
<             marginBottom = pick(optionsMarginBottom, spacingBottom);
<             plotLeft = pick(optionsMarginLeft, spacingLeft);
<             axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
<         };
< 	
<         /**
< 	 * Draw the borders and backgrounds for chart and plot area
< 	 */
<         drawChartBox = function() {
<             var chartBorderWidth = optionsChart.borderWidth || 0,
<             chartBackgroundColor = optionsChart.backgroundColor,
<             plotBackgroundColor = optionsChart.plotBackgroundColor,
<             plotBackgroundImage = optionsChart.plotBackgroundImage,
<             mgn,
<             plotSize = {
<                 x: plotLeft,
<                 y: plotTop,
<                 width: plotWidth,
<                 height: plotHeight
<             };
< 
<             // Chart area
<             mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
< 			
<             if (chartBorderWidth || chartBackgroundColor) {
<                 if (!chartBackground) {
<                     chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
<                         optionsChart.borderRadius, chartBorderWidth)
<                     .attr({
<                         stroke: optionsChart.borderColor,
<                         'stroke-width': chartBorderWidth,
<                         fill: chartBackgroundColor || NONE
<                     })
<                     .add()
<                     .shadow(optionsChart.shadow);
<                 } else { // resize
<                     chartBackground.animate(
<                         chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
<                         );
<                 }
<             }
< 		
< 		
<             // Plot background
<             if (plotBackgroundColor) {
<                 if (!plotBackground) {
<                     plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
<                     .attr({
<                         fill: plotBackgroundColor
<                     })
<                     .add()
<                     .shadow(optionsChart.plotShadow);
<                 } else {
<                     plotBackground.animate(plotSize);
<                 }
<             }
<             if (plotBackgroundImage) {
<                 if (!plotBGImage) {
<                     plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
<                     .add();
<                 } else {
<                     plotBGImage.animate(plotSize);
<                 }
<             }
< 		
<             // Plot area border
<             if (optionsChart.plotBorderWidth) {
<                 if (!plotBorder) {
<                     plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
<                     .attr({
<                         stroke: optionsChart.plotBorderColor,
<                         'stroke-width': optionsChart.plotBorderWidth,
<                         zIndex: 4
<                     })
<                     .add();
<                 } else {
<                     plotBorder.animate(
<                         plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
<                         );
<                 }
<             }
< 		
<             // reset
<             chart.isDirtyBox = false;
<         };
< 	
<         /**
< 	 * Render all graphics for the chart
< 	 */
<         function render () {
<             var labels = options.labels,
<             credits = options.credits,
<             creditsHref;
< 		
<             // Title
<             setTitle();
< 		
< 		
<             // Legend
<             legend = chart.legend = new Legend(chart);
< 		
<             // Get margins by pre-rendering axes
<             getMargins();
<             each(axes, function(axis) {
<                 axis.setTickPositions(true); // update to reflect the new margins
<             });
<             adjustTickAmounts();
<             getMargins(); // second pass to check for new labels
< 		
< 		
<             // Draw the borders and backgrounds
<             drawChartBox();
< 						
<             // Axes
<             if (hasCartesianSeries) {
<                 each(axes, function(axis) {
<                     axis.render();
<                 });
<             }
< 		
< 		
<             // The series
<             if (!chart.seriesGroup) {
<                 chart.seriesGroup = renderer.g('series-group')
<                 .attr({
<                     zIndex: 3
<                 })
<                 .add();
<             }
<             each(series, function(serie) {
<                 serie.translate();
<                 serie.setTooltipPoints();
<                 serie.render();
<             });
< 		
< 		
<             // Labels
<             if (labels.items) {
<                 each(labels.items, function() {
<                     var style = extend(labels.style, this.style),
<                     x = pInt(style.left) + plotLeft,
<                     y = pInt(style.top) + plotTop + 12;
< 				
<                     // delete to prevent rewriting in IE
<                     delete style.left;
<                     delete style.top;
< 				
<                     renderer.text(
<                         this.html,
<                         x,
<                         y
<                         )
<                     .attr({
<                         zIndex: 2
<                     })
<                     .css(style)
<                     .add();
< 					
<                 });
<             }
< 		
<             // Toolbar (don't redraw)
<             if (!chart.toolbar) {
<                 chart.toolbar = Toolbar(chart);
<             }
< 		
<             // Credits
<             if (credits.enabled && !chart.credits) {
<                 creditsHref = credits.href;
<                 renderer.text(
<                     credits.text,
<                     0,
<                     0
<                     )
<                 .on('click', function() {
<                     if (creditsHref) {
<                         location.href = creditsHref;
<                     }
<                 })
<                 .attr({
<                     align: credits.position.align,
<                     zIndex: 8
<                 })
<                 .css(credits.style)
<                 .add()
<                 .align(credits.position);
<             }
< 		
<             placeTrackerGroup();
< 
<             // Set flag
<             chart.hasRendered = true;
< 		
<             // If the chart was rendered outside the top container, put it back in
<             if (renderToClone) {
<                 renderTo.appendChild(container);
<                 discardElement(renderToClone);
<             //updatePosition(container);
<             }
<         }
< 	
<         /**
< 	 * Clean up memory usage
< 	 */
<         function destroy() {
<             var i = series.length,
<             parentNode = container && container.parentNode;
< 		
<             // fire the chart.destoy event
<             fireEvent(chart, 'destroy');
< 
<             // remove events
<             removeEvent(win, 'unload', destroy);
<             removeEvent(chart);
< 		
<             each(axes, function(axis) {
<                 removeEvent(axis);
<             });
< 
<             // destroy each series
<             while (i--) {
<                 series[i].destroy();
<             }
< 		
<             // remove container and all SVG
<             if (container) { // can break in IE when destroyed before finished loading
<                 container.innerHTML = '';
<                 removeEvent(container);
<                 if (parentNode) {
<                     parentNode.removeChild(container);
<                 }
< 			
<                 // IE6 leak
<                 container =	null;
<             }
< 		
<             // IE7 leak
<             if (renderer) { // can break in IE when destroyed before finished loading
<                 renderer.alignedObjects = null;
<             }
< 			
<             // memory and CPU leak
<             clearInterval(tooltipInterval);
< 		
<             // clean it all up
<             for (i in chart) {
<                 delete chart[i];
<             }
< 		
<         }
<         /**
< 	 * Prepare for first rendering after all data are loaded
< 	 */
<         function firstRender() {
< 
<             // VML namespaces can't be added until after complete. Listening
<             // for Perini's doScroll hack is not enough.
<             var ONREADYSTATECHANGE = 'onreadystatechange',
<             COMPLETE = 'complete';
<             // Note: in spite of JSLint's complaints, win == win.top is required
<             if (!hasSVG && win == win.top && doc.readyState !== COMPLETE) {
<                 doc.attachEvent(ONREADYSTATECHANGE, function() {
<                     doc.detachEvent(ONREADYSTATECHANGE, firstRender);
<                     if (doc.readyState === COMPLETE) {
<                         firstRender();
<                     }
<                 });
<                 return;
<             }
< 
<             // Set to zero for each new chart
<             colorCounter = 0;
<             symbolCounter = 0;
< 
<             // create the container
<             getContainer();
< 		
<             resetMargins();
<             setChartSize();
< 		
<             // Initialize the series
<             each(options.series || [], function(serieOptions) {
<                 initSeries(serieOptions);
<             });
< 	
<             // Set the common inversion and transformation for inverted series after initSeries
<             chart.inverted = inverted = pick(inverted, options.chart.inverted);
< 			
< 		
<             getAxes();
< 		
< 		
<             chart.render = render;
< 		
<             // depends on inverted and on margins being set
<             chart.tracker = tracker = new MouseTracker(chart, options.tooltip);
< 		
<             //globalAnimation = false;
<             render();
< 		
<             fireEvent(chart, 'load');
< 		
<             //globalAnimation = true;
< 		
<             // run callbacks
<             if (callback) {
<                 callback.apply(chart, [chart]);
<             }
<             each(chart.callbacks, function(fn) {
<                 fn.apply(chart, [chart]);
<             });
<         }
< 	
<         // Run chart
< 		
< 	
<         // Destroy the chart and free up memory.
<         addEvent(win, 'unload', destroy);
< 	
<         // Set up auto resize
<         if (optionsChart.reflow !== false) {
<             addEvent(chart, 'load', initReflow);
<         }
< 	
<         // Chart event handlers
<         if (chartEvents) {
<             for (eventType in chartEvents) {
<                 addEvent(chart, eventType, chartEvents[eventType]);
<             }
<         }
< 	
< 	
<         chart.options = options;
<         chart.series = series;
< 
< 	
< 	
< 	
< 	
< 	
<         // Expose methods and variables
<         chart.addSeries = addSeries;
<         chart.animation = pick(optionsChart.animation, true);
<         chart.destroy = destroy;
<         chart.get = get;
<         chart.getSelectedPoints = getSelectedPoints;
<         chart.getSelectedSeries = getSelectedSeries;
<         chart.hideLoading = hideLoading;
<         chart.isInsidePlot = isInsidePlot;
<         chart.redraw = redraw;
<         chart.setSize = resize;
<         chart.setTitle = setTitle;
<         chart.showLoading = showLoading;
<         chart.pointCount = 0;
<         /*
< 	if ($) $(function() {
< 		$container = $('#container');
< 		var origChartWidth,
< 			origChartHeight;
< 		if ($container) {
< 			$('<button>+</button>')
< 				.insertBefore($container)
< 				.click(function() {
< 					if (origChartWidth === UNDEFINED) {
< 						origChartWidth = chartWidth;
< 						origChartHeight = chartHeight;
< 					}				
< 					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
< 				});
< 			$('<button>-</button>')
< 				.insertBefore($container)
< 				.click(function() {
< 					if (origChartWidth === UNDEFINED) {
< 						origChartWidth = chartWidth;
< 						origChartHeight = chartHeight;
< 					}							
< 					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
< 				});
< 			$('<button>1:1</button>')
< 				.insertBefore($container)
< 				.click(function() {				
< 					if (origChartWidth === UNDEFINED) {
< 						origChartWidth = chartWidth;
< 						origChartHeight = chartHeight;
< 					}							
< 					chart.resize(origChartWidth, origChartHeight);
< 				});
< 		}
< 	})
< 	*/
< 	
< 	
< 	
< 		
<         firstRender();
< 	
< 	
<     } // end Chart
< 
<     // Hook for exporting module
<     Chart.prototype.callbacks = [];
<     /**
<  * The Point object and prototype. Inheritable and used as base for PiePoint
<  */
<     var Point = function() {};
<     Point.prototype = {
< 
<         /**
< 	 * Initialize the point
< 	 * @param {Object} series The series object containing this point
< 	 * @param {Object} options The data in either number, array or object format
< 	 */
<         init: function(series, options) {
<             var point = this,
<             defaultColors;
<             point.series = series;
<             point.applyOptions(options);
<             point.pointAttr = {};
< 		
<             if (series.options.colorByPoint) {
<                 defaultColors = series.chart.options.colors;
<                 if (!point.options) {
<                     point.options = {};
<                 }
<                 point.color = point.options.color = point.color || defaultColors[colorCounter++];
< 			
<                 // loop back to zero
<                 if (colorCounter >= defaultColors.length) {
<                     colorCounter = 0;
<                 }
<             }
< 		
<             series.chart.pointCount++;
<             return point;
<         },
<         /**
< 	 * Apply the options containing the x and y data and possible some extra properties.
< 	 * This is called on point init or from point.update.
< 	 * 
< 	 * @param {Object} options
< 	 */
<         applyOptions: function(options) {
<             var point = this,
<             series = point.series;
< 	
<             point.config = options;
< 		
<             // onedimensional array input
<             if (isNumber(options) || options === null) {
<                 point.y = options;
<             }
< 		
<             // object input
<             else if (isObject(options) && !isNumber(options.length)) {
< 			
<                 // copy options directly to point
<                 extend(point, options);
<                 point.options = options;
<             }
< 		
<             // categorized data with name in first position
<             else if (isString(options[0])) {
<                 point.name = options[0];
<                 point.y = options[1];
<             }
< 		
<             // two-dimentional array
<             else if (isNumber(options[0])) {
<                 point.x = options[0];
<                 point.y = options[1];
<             }
< 		
<             /*
< 		 * If no x is set by now, get auto incremented value. All points must have an
< 		 * x value, however the y value can be null to create a gap in the series
< 		 */
<             if (point.x === UNDEFINED) {
<                 point.x = series.autoIncrement();
<             }
< 		
<         },
< 	
<         /**
< 	 * Destroy a point to clear memory. Its reference still stays in series.data.
< 	 */
<         destroy: function() {
<             var point = this,
<             series = point.series,
<             prop;
< 			
<             series.chart.pointCount--;
< 			
<             if (point === series.chart.hoverPoint) {
<                 point.onMouseOut();
<             }
<             series.chart.hoverPoints = null; // remove reference
< 		
<             // remove all events
<             removeEvent(point);
< 		
<             each(['graphic', 'tracker', 'group', 'dataLabel', 'connector'], function(prop) {
<                 if (point[prop]) {
<                     point[prop].destroy();
<                 }
<             });
< 		
<             if (point.legendItem) { // pies have legend items
<                 point.series.chart.legend.destroyItem(point);
<             }
< 		
<             for (prop in point) {
<                 point[prop] = null;
<             }
< 		
< 		
<         },
< 	
<         /**
< 	 * Return the configuration hash needed for the data label and tooltip formatters
< 	 */
<         getLabelConfig: function() {
<             var point = this;
<             return {
<                 x: point.category,
<                 y: point.y,
<                 series: point.series,
<                 point: point,
<                 percentage: point.percentage,
<                 total: point.total || point.stackTotal
<             };
<         },
< 		
<         /**
< 	 * Toggle the selection status of a point
< 	 * @param {Boolean} selected Whether to select or unselect the point.
< 	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
< 	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
< 	 */
<         select: function(selected, accumulate) {
<             var point = this,
<             series = point.series,
<             chart = series.chart;
< 			
<             point.selected = selected = pick(selected, !point.selected);
< 		
<             //series.isDirty = true;
<             point.firePointEvent(selected ? 'select' : 'unselect');
<             point.setState(selected && SELECT_STATE);
< 		
<             // unselect all other points unless Ctrl or Cmd + click
<             if (!accumulate) {
<                 each(chart.getSelectedPoints(), function (loopPoint) {
<                     if (loopPoint.selected && loopPoint !== point) {
<                         loopPoint.selected = false;
<                         loopPoint.setState(NORMAL_STATE);
<                         loopPoint.firePointEvent('unselect');
<                     }
<                 });
<             }
< 		
<         },
< 	
<         onMouseOver: function() {
<             var point = this,
<             chart = point.series.chart,
<             tooltip = chart.tooltip,
<             hoverPoint = chart.hoverPoint;
< 			
<             // set normal state to previous series
<             if (hoverPoint && hoverPoint !== point) {
<                 hoverPoint.onMouseOut();
<             }
< 		
<             // trigger the event
<             point.firePointEvent('mouseOver');
< 		
<             // update the tooltip
<             if (tooltip && !tooltip.shared) {
<                 tooltip.refresh(point);
<             }
< 		
<             // hover this
<             point.setState(HOVER_STATE);
<             chart.hoverPoint = point;
<         },
< 	
<         onMouseOut: function() {
<             var point = this;
<             point.firePointEvent('mouseOut');
< 		
<             point.setState();
<             point.series.chart.hoverPoint = null;
<         },
< 	
<         /**
< 	 * Extendable method for formatting each point's tooltip line 
< 	 * 
< 	 * @param {Boolean} useHeader Whether a common header is used for multiple series in the tooltip
< 	 * 
< 	 * @return {String} A string to be concatenated in to the common tooltip text
< 	 */
<         tooltipFormatter: function(useHeader) {
<             var point = this,
<             series = point.series;
< 				
<             return ['<span style="color:'+ series.color +'">', (point.name || series.name), '</span>: ',
<             (!useHeader ? ('<b>x = '+ (point.name || point.x) + ',</b> ') : ''),
<             '<b>', (!useHeader ? 'y = ' : '' ), point.y, '</b>'].join('');
< 		
<         },
< 	
<         /**
< 	 * Update the point with new options (typically x/y data) and optionally redraw the series.
< 	 * 
< 	 * @param {Object} options Point options as defined in the series.data array
< 	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
< 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
< 	 *    configuration
< 	 * 
< 	 */
<         update: function(options, redraw, animation) {
<             var point = this,
<             series = point.series,
<             dataLabel = point.dataLabel,
<             graphic = point.graphic,
<             chart = series.chart;
< 		
<             redraw = pick(redraw, true);
< 		
<             // fire the event with a default handler of doing the update
<             point.firePointEvent('update', {
<                 options: options
<             }, function() {
< 
<                 point.applyOptions(options);
< 			
<                 // update visuals
<                 if (isObject(options)) {
<                     series.getAttribs();
<                     if (graphic) {
<                         graphic.attr(point.pointAttr[series.state]);
<                     }
<                 }
< 			
<                 // redraw
<                 series.isDirty = true;
<                 if (redraw) {
<                     chart.redraw(animation);
<                 }
<             });
<         },
< 	
<         /**
< 	 * Remove a point and optionally redraw the series and if necessary the axes
< 	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
< 	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
< 	 *    configuration
< 	 */
<         remove: function(redraw, animation) {
<             var point = this,
<             series = point.series,
<             chart = series.chart,
<             data = series.data;
< 		
<             setAnimation(animation, chart);
<             redraw = pick(redraw, true);
< 		
<             // fire the event with a default handler of removing the point
<             point.firePointEvent('remove', null, function() {
< 
<                 erase(data, point);
< 			
<                 point.destroy();
---
> 			point.destroy();
8577,8582c8445,8450
<                 // redraw
<                 series.isDirty = true;
<                 if (redraw) {
<                     chart.redraw();
<                 }
<             });
---
> 			// redraw
> 			series.isDirty = true;
> 			if (redraw) {
> 				chart.redraw();
> 			}
> 		});
8585c8453
<         },
---
> 	},
8587c8455
<         /**
---
> 	/**
8594,8615c8462,8483
<         firePointEvent: function(eventType, eventArgs, defaultFunction) {
<             var point = this,
<             series = this.series,
<             seriesOptions = series.options;
< 		
<             // load event handlers on demand to save time on mouseover/out
<             if (seriesOptions.point.events[eventType] || (
<                 point.options && point.options.events && point.options.events[eventType])) {
<                 this.importEvents();
<             }
< 			
<             // add default handler if in selection mode
<             if (eventType === 'click' && seriesOptions.allowPointSelect) {
<                 defaultFunction = function (event) {
<                     // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
<                     point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
<                 };
<             }
< 			
<             fireEvent(this, eventType, eventArgs, defaultFunction);
<         },
<         /**
---
> 	firePointEvent: function(eventType, eventArgs, defaultFunction) {
> 		var point = this,
> 			series = this.series,
> 			seriesOptions = series.options;
> 		
> 		// load event handlers on demand to save time on mouseover/out
> 		if (seriesOptions.point.events[eventType] || (
> 				point.options && point.options.events && point.options.events[eventType])) {
> 			this.importEvents();
> 		}
> 			
> 		// add default handler if in selection mode
> 		if (eventType === 'click' && seriesOptions.allowPointSelect) {
> 			defaultFunction = function (event) {
> 				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
> 				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
> 			};
> 		}
> 			
> 		fireEvent(this, eventType, eventArgs, defaultFunction);
> 	},
> 	/**
8619,8624c8487,8492
<         importEvents: function() {
<             if (!this.hasImportedEvents) {
<                 var point = this,
<                 options = merge(point.series.options.point, point.options),
<                 events = options.events,
<                 eventType;
---
> 	importEvents: function() {
> 		if (!this.hasImportedEvents) {
> 			var point = this,
> 				options = merge(point.series.options.point, point.options),
> 				events = options.events,
> 				eventType;
8626c8494
<                 point.events = events;
---
> 			point.events = events;
8628,8631c8496,8499
<                 for (eventType in events) {
<                     addEvent(point, eventType, events[eventType]);
<                 }
<                 this.hasImportedEvents = true;
---
> 			for (eventType in events) {
> 				addEvent(point, eventType, events[eventType]);
> 			}
> 			this.hasImportedEvents = true;
8633,8634c8501,8502
<             }
<         },
---
> 		}
> 	},
8636c8504
<         /**
---
> 	/**
8640,8682c8508,8550
<         setState: function(state) {
<             var point = this,
<             series = point.series,
<             stateOptions = series.options.states,
<             markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
<             normalDisabled = markerOptions && !markerOptions.enabled,
<             markerStateOptions = markerOptions && markerOptions.states[state],
<             stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
<             stateMarkerGraphic = series.stateMarkerGraphic,
<             chart = series.chart,
<             pointAttr = point.pointAttr;
< 			
<             state = state || NORMAL_STATE; // empty string
< 		
<             if (
<                 // already has this state
<                 state === point.state ||
<                 // selected points don't respond to hover
<                 (point.selected && state !== SELECT_STATE) ||
<                 // series' state options is disabled
<                 (stateOptions[state] && stateOptions[state].enabled === false) ||
<                 // point marker's state options is disabled
<                 (state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))
< 
<                 ) {
<                 return;
<             }
< 		
<             // apply hover styles to the existing point
<             if (point.graphic) {
<                 point.graphic.attr(pointAttr[state]);
<             }
<             // if a graphic is not applied to each point in the normal state, create a shared
<             // graphic for the hover state
<             else {
<                 if (state) {
<                     if (!stateMarkerGraphic) {
<                         series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.circle(
<                             0, 0, pointAttr[state].r
<                             )
<                         .attr(pointAttr[state])
<                         .add(series.group);
<                     }
---
> 	setState: function(state) {
> 		var point = this,
> 			series = point.series,
> 			stateOptions = series.options.states,
> 			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
> 			normalDisabled = markerOptions && !markerOptions.enabled,
> 			markerStateOptions = markerOptions && markerOptions.states[state],
> 			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
> 			stateMarkerGraphic = series.stateMarkerGraphic,
> 			chart = series.chart,
> 			pointAttr = point.pointAttr;
> 			
> 		state = state || NORMAL_STATE; // empty string
> 		
> 		if (
> 				// already has this state
> 				state === point.state ||
> 				// selected points don't respond to hover
> 				(point.selected && state !== SELECT_STATE) ||
> 				// series' state options is disabled
> 				(stateOptions[state] && stateOptions[state].enabled === false) ||
> 				// point marker's state options is disabled
> 				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))
> 
> 			) {
> 			return;
> 		}
> 		
> 		// apply hover styles to the existing point
> 		if (point.graphic) {
> 			point.graphic.attr(pointAttr[state]);
> 		}
> 		// if a graphic is not applied to each point in the normal state, create a shared
> 		// graphic for the hover state
> 		else {
> 			if (state) {
> 				if (!stateMarkerGraphic) {
> 					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.circle(
> 						0, 0, pointAttr[state].r
> 					)
> 					.attr(pointAttr[state])
> 					.add(series.group);
> 				}
8684,8697c8552,8565
<                     stateMarkerGraphic.translate(
<                         point.plotX,
<                         point.plotY
<                         );
<                 }
< 			
<                 if (stateMarkerGraphic) {
<                     stateMarkerGraphic[state ? 'show' : 'hide']();
<                 }
<             }
< 		
<             point.state = state;
<         }
<     };
---
> 				stateMarkerGraphic.translate(
> 					point.plotX, 
> 					point.plotY
> 				);
> 			}
> 			
> 			if (stateMarkerGraphic) {
> 				stateMarkerGraphic[state ? 'show' : 'hide']();
> 			}
> 		}
> 		
> 		point.state = state;
> 	}
> };
8699c8567
<     /**
---
> /**
8704c8572
<     var Series = function() {};
---
> var Series = function() {};
8706c8574
<     Series.prototype = {
---
> Series.prototype = {
8708,8752c8576,8617
<         isCartesian: true,
<         type: 'line',
<         pointClass: Point,
<         pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
<             stroke: 'lineColor',
<             'stroke-width': 'lineWidth',
<             fill: 'fillColor',
<             r: 'radius'
<         },
<         init: function(chart, options) {
<             var series = this,
<             eventType,
<             events,
<             //pointEvent,
<             index = chart.series.length;
<             
<             series.chart = chart;
<             options = series.setOptions(options); // merge with plotOptions
< 		
<             // set some variables
<             extend(series, {
<                 index: index,
<                 options: options,
<                 name: options.name || 'Series '+ (index + 1),
<                 state: NORMAL_STATE,
<                 pointAttr: {},
<                 visible: options.visible !== false, // true by default
<                 selected: options.selected === true // false by default
<             });
< 		
<             // register event listeners
<             events = options.events;
<             for (eventType in events) {
<                 addEvent(series, eventType, events[eventType]);
<             }
<             if (
<                 (events && events.click) ||
<                 (options.point && options.point.events && options.point.events.click) ||
<                 options.allowPointSelect
<                 ) {
<                 chart.runTrackerClick = true;
<             }
< 		
<             series.getColor();
<             series.getSymbol();
---
> 	isCartesian: true,
> 	type: 'line',
> 	pointClass: Point,
> 	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
> 		stroke: 'lineColor',
> 		'stroke-width': 'lineWidth',
> 		fill: 'fillColor',
> 		r: 'radius'
> 	},
> 	init: function(chart, options) {
> 		var series = this,
> 			eventType,
> 			events,
> 			//pointEvent,
> 			index = chart.series.length;
> 			
> 		series.chart = chart;
> 		options = series.setOptions(options); // merge with plotOptions
> 		
> 		// set some variables
> 		extend(series, {
> 			index: index,
> 			options: options,
> 			name: options.name || 'Series '+ (index + 1),
> 			state: NORMAL_STATE,
> 			pointAttr: {},
> 			visible: options.visible !== false, // true by default
> 			selected: options.selected === true // false by default
> 		});
> 		
> 		// register event listeners
> 		events = options.events;
> 		for (eventType in events) {
> 			addEvent(series, eventType, events[eventType]);
> 		}
> 		if (
> 			(events && events.click) || 
> 			(options.point && options.point.events && options.point.events.click) ||
> 			options.allowPointSelect 
> 		) {
> 			chart.runTrackerClick = true;
> 		}
8753a8619,8620
> 		series.getColor();
> 		series.getSymbol();
8755,8756c8622,8624
<             // set the data
<             series.setData(options.data, false);
---
> 		
> 		// set the data
> 		series.setData(options.data, false);
8758c8626
<         },
---
> 	},
8761c8629
<         /**
---
> 	/**
8765,8768c8633,8636
<         autoIncrement: function() {
<             var series = this,
<             options = series.options,
<             xIncrement = series.xIncrement;
---
> 	autoIncrement: function() {
> 		var series = this,
> 			options = series.options,
> 			xIncrement = series.xIncrement;
8770c8638
<             xIncrement = pick(xIncrement, options.pointStart, 0);
---
> 		xIncrement = pick(xIncrement, options.pointStart, 0);
8772c8640
<             series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);
---
> 		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);
8774,8776c8642,8644
<             series.xIncrement = xIncrement + series.pointInterval;
<             return xIncrement;
<         },
---
> 		series.xIncrement = xIncrement + series.pointInterval;
> 		return xIncrement;
> 	},
8778c8646
<         /**
---
> 	/**
8781,8798c8649,8666
<         cleanData: function() {
<             var series = this,
<             chart = series.chart,
<             data = series.data,
<             closestPoints,
<             smallestInterval,
<             chartSmallestInterval = chart.smallestInterval,
<             interval,
<             i;
< 			
<             // sort the data points
<             data.sort(function(a, b){
<                 return (a.x - b.x);
<             });
< 		
<             // remove points with equal x values
<             // record the closest distance for calculation of column widths
<             /*for (i = data.length - 1; i >= 0; i--) {
---
> 	cleanData: function() {
> 		var series = this,
> 			chart = series.chart,
> 			data = series.data,
> 			closestPoints,
> 			smallestInterval,
> 			chartSmallestInterval = chart.smallestInterval,
> 			interval,
> 			i;
> 			
> 		// sort the data points
> 		data.sort(function(a, b){
> 			return (a.x - b.x);
> 		});
> 		
> 		// remove points with equal x values
> 		// record the closest distance for calculation of column widths
> 		/*for (i = data.length - 1; i >= 0; i--) {
8805c8673,8693
< 		}*/
---
> 		}*/
> 		
> 		// connect nulls
> 		if (series.options.connectNulls) {
> 			for (i = data.length - 1; i >= 0; i--) {
> 				if (data[i].y === null && data[i - 1] && data[i + 1]) {
> 					data.splice(i, 1);
> 				}
> 			}
> 		}
> 		
> 		// find the closes pair of points
> 		for (i = data.length - 1; i >= 0; i--) {
> 			if (data[i - 1]) {
> 				interval = data[i].x - data[i - 1].x;
> 				if (interval > 0 && (smallestInterval === UNDEFINED || interval < smallestInterval)) {
> 					smallestInterval = interval;
> 					closestPoints = i;	
> 				}
> 			}
> 		}
8807,8831c8695,8699
<             // connect nulls
<             if (series.options.connectNulls) {
<                 for (i = data.length - 1; i >= 0; i--) {
<                     if (data[i].y === null && data[i - 1] && data[i + 1]) {
<                         data.splice(i, 1);
<                     }
<                 }
<             }
< 		
<             // find the closes pair of points
<             for (i = data.length - 1; i >= 0; i--) {
<                 if (data[i - 1]) {
<                     interval = data[i].x - data[i - 1].x;
<                     if (interval > 0 && (smallestInterval === UNDEFINED || interval < smallestInterval)) {
<                         smallestInterval = interval;
<                         closestPoints = i;
<                     }
<                 }
<             }
< 		
<             if (chartSmallestInterval === UNDEFINED || smallestInterval < chartSmallestInterval) {
<                 chart.smallestInterval = smallestInterval;
<             }
<             series.closestPoints = closestPoints;
<         },
---
> 		if (chartSmallestInterval === UNDEFINED || smallestInterval < chartSmallestInterval) {
> 			chart.smallestInterval = smallestInterval;
> 		}
> 		series.closestPoints = closestPoints;
> 	},		
8833c8701
<         /**
---
> 	/**
8837,8853c8705,8721
<         getSegments: function() {
<             var lastNull = -1,
<             segments = [],
<             data = this.data;
< 		
<             // create the segments
<             each(data, function(point, i) {
<                 if (point.y === null) {
<                     if (i > lastNull + 1) {
<                         segments.push(data.slice(lastNull + 1, i));
<                     }
<                     lastNull = i;
<                 } else if (i === data.length - 1) { // last value
<                     segments.push(data.slice(lastNull + 1, i + 1));
<                 }
<             });
<             this.segments = segments;
---
> 	getSegments: function() {
> 		var lastNull = -1,
> 			segments = [],
> 			data = this.data;
> 		
> 		// create the segments
> 		each(data, function(point, i) {
> 			if (point.y === null) {
> 				if (i > lastNull + 1) {
> 					segments.push(data.slice(lastNull + 1, i));
> 				}
> 				lastNull = i;	
> 			} else if (i === data.length - 1) { // last value
> 				segments.push(data.slice(lastNull + 1, i + 1));
> 			}
> 		});
> 		this.segments = segments;
8856,8857c8724,8725
<         },
<         /**
---
> 	},
> 	/**
8861,8867c8729,8735
<         setOptions: function(itemOptions) {
<             var plotOptions = this.chart.options.plotOptions,
<             options = merge(
<                 plotOptions[this.type],
<                 plotOptions.series,
<                 itemOptions
<                 );
---
> 	setOptions: function(itemOptions) {
> 		var plotOptions = this.chart.options.plotOptions,
> 			options = merge(
> 				plotOptions[this.type],
> 				plotOptions.series,
> 				itemOptions
> 			);
8869c8737
<             return options;
---
> 		return options;
8871,8872c8739,8740
<         },
<         /**
---
> 	},
> 	/**
8875,8882c8743,8750
<         getColor: function(){
<             var defaultColors = this.chart.options.colors;
<             this.color = this.options.color || defaultColors[colorCounter++] || '#0000ff';
<             if (colorCounter >= defaultColors.length) {
<                 colorCounter = 0;
<             }
<         },
<         /**
---
> 	getColor: function(){
> 		var defaultColors = this.chart.options.colors;
> 		this.color = this.options.color || defaultColors[colorCounter++] || '#0000ff';
> 		if (colorCounter >= defaultColors.length) {
> 			colorCounter = 0;
> 		}
> 	},
> 	/**
8885,8892c8753,8760
<         getSymbol: function(){
<             var defaultSymbols = this.chart.options.symbols,
<             symbol = this.options.marker.symbol || defaultSymbols[symbolCounter++];
<             this.symbol = symbol;
<             if (symbolCounter >= defaultSymbols.length) {
<                 symbolCounter = 0;
<             }
<         },
---
> 	getSymbol: function(){
> 		var defaultSymbols = this.chart.options.symbols,
> 			symbol = this.options.marker.symbol || defaultSymbols[symbolCounter++];
> 		this.symbol = symbol;
> 		if (symbolCounter >= defaultSymbols.length) { 
> 			symbolCounter = 0;
> 		}
> 	},
8894c8762
<         /**
---
> 	/**
8903,8935c8771,8803
<         addPoint: function(options, redraw, shift, animation) {
<             var series = this,
<             data = series.data,
<             graph = series.graph,
<             area = series.area,
<             chart = series.chart,
<             point = (new series.pointClass()).init(series, options);
< 			
<             setAnimation(animation, chart);
< 		
<             if (graph && shift) { // make graph animate sideways
<                 graph.shift = shift;
<             }
<             if (area) {
<                 area.shift = shift;
<                 area.isArea = true;
<             }
< 			
<             redraw = pick(redraw, true);
< 			
<             data.push(point);
<             if (shift) {
<                 data[0].remove(false);
<             }
<             series.getAttribs();
< 		
< 		
<             // redraw
<             series.isDirty = true;
<             if (redraw) {
<                 chart.redraw();
<             }
<         },
---
> 	addPoint: function(options, redraw, shift, animation) {
> 		var series = this,
> 			data = series.data,
> 			graph = series.graph,
> 			area = series.area,
> 			chart = series.chart,
> 			point = (new series.pointClass()).init(series, options);
> 			
> 		setAnimation(animation, chart);
> 		
> 		if (graph && shift) { // make graph animate sideways
> 			graph.shift = shift;
> 		}
> 		if (area) {
> 			area.shift = shift;
> 			area.isArea = true;
> 		}
> 			
> 		redraw = pick(redraw, true);
> 			
> 		data.push(point);
> 		if (shift) {
> 			data[0].remove(false);
> 		}
> 		series.getAttribs();
> 		
> 		
> 		// redraw
> 		series.isDirty = true;
> 		if (redraw) {
> 			chart.redraw();
> 		}
> 	},
8937c8805
<         /**
---
> 	/**
8942,8979c8810,8847
<         setData: function(data, redraw) {
<             var series = this,
<             oldData = series.data,
<             initialColor = series.initialColor,
<             chart = series.chart,
<             i = (oldData && oldData.length) || 0;
< 		
<             series.xIncrement = null; // reset for new data
<             if (defined(initialColor)) { // reset colors for pie
<                 colorCounter = initialColor;
<             }
< 		
<             data = map(splat(data || []), function(pointOptions) {
<                 return (new series.pointClass()).init(series, pointOptions);
<             });
< 		
<             // destroy old points
<             while (i--) {
<                 oldData[i].destroy();
<             }
< 		
<             // set the data
<             series.data = data;
< 	
<             series.cleanData();
<             series.getSegments();
< 		
< 		
<             // cache attributes for shapes
<             series.getAttribs();
< 		
<             // redraw
<             series.isDirty = true;
<             chart.isDirtyBox = true;
<             if (pick(redraw, true)) {
<                 chart.redraw(false);
<             }
<         },
---
> 	setData: function(data, redraw) {
> 		var series = this,
> 			oldData = series.data,
> 			initialColor = series.initialColor,
> 			chart = series.chart,
> 			i = (oldData && oldData.length) || 0;
> 		
> 		series.xIncrement = null; // reset for new data
> 		if (defined(initialColor)) { // reset colors for pie
> 			colorCounter = initialColor;
> 		}
> 		
> 		data = map(splat(data || []), function(pointOptions) {
> 			return (new series.pointClass()).init(series, pointOptions);
> 		});
> 		
> 		// destroy old points
> 		while (i--) {
> 			oldData[i].destroy();
> 		}
> 		
> 		// set the data
> 		series.data = data;
> 	
> 		series.cleanData();	
> 		series.getSegments();
> 		
> 		
> 		// cache attributes for shapes
> 		series.getAttribs();
> 		
> 		// redraw
> 		series.isDirty = true;
> 		chart.isDirtyBox = true;
> 		if (pick(redraw, true)) {
> 			chart.redraw(false);
> 		}
> 	},
8981c8849
<         /**
---
> 	/**
8989,8992c8857,8860
<         remove: function(redraw, animation) {
<             var series = this,
<             chart = series.chart;
<             redraw = pick(redraw, true);
---
> 	remove: function(redraw, animation) {
> 		var series = this,
> 			chart = series.chart;
> 		redraw = pick(redraw, true);
8994c8862
<             if (!series.isRemoving) {  /* prevent triggering native event in jQuery
---
> 		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
8996c8864
<                 series.isRemoving = true;
---
> 			series.isRemoving = true;
8998,8999c8866,8867
<                 // fire the event with a default handler of removing the point
<                 fireEvent(series, 'remove', null, function() {
---
> 			// fire the event with a default handler of removing the point			
> 			fireEvent(series, 'remove', null, function() {
9002,9003c8870,8871
<                     // destroy elements
<                     series.destroy();
---
> 				// destroy elements
> 				series.destroy();
9006,9015c8874,8883
<                     // redraw
<                     chart.isDirtyLegend = chart.isDirtyBox = true;
<                     if (redraw) {
<                         chart.redraw(animation);
<                     }
<                 });
< 			
<             }
<             series.isRemoving = false;
<         },
---
> 				// redraw
> 				chart.isDirtyLegend = chart.isDirtyBox = true;
> 				if (redraw) {
> 					chart.redraw(animation);
> 				}
> 			});
> 			
> 		} 
> 		series.isRemoving = false;
> 	},
9017c8885
<         /**
---
> 	/**
9021,9073c8889,8941
<         translate: function() {
<             var series = this,
<             chart = series.chart,
<             stacking = series.options.stacking,
<             categories = series.xAxis.categories,
<             yAxis = series.yAxis,
<             data = series.data,
<             i = data.length;
< 			
<             // do the translation
<             while (i--) {
<                 var point = data[i],
<                 xValue = point.x,
<                 yValue = point.y,
<                 yBottom = point.low,
<                 stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
<                 pointStack,
<                 pointStackTotal;
<                 point.plotX = series.xAxis.translate(xValue);
< 			
<                 // calculate the bottom y value for stacked series
<                 if (stacking && series.visible && stack && stack[xValue]) {
<                     pointStack = stack[xValue];
<                     pointStackTotal = pointStack.total;
<                     pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
<                     yValue = yBottom + yValue;
< 				
<                     if (stacking === 'percent') {
<                         yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
<                         yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
<                     }
< 
<                     point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
<                     point.stackTotal = pointStackTotal;
<                 }
< 			
<                 if (defined(yBottom)) {
<                     point.yBottom = yAxis.translate(yBottom, 0, 1, 0, 1);
<                 }
< 			
<                 // set the y value
<                 if (yValue !== null) {
<                     point.plotY = yAxis.translate(yValue, 0, 1, 0, 1);
<                 }
< 			
<                 // set client related positions for mouse tracking
<                 point.clientX = chart.inverted ?
<                 chart.plotHeight - point.plotX :
<                 point.plotX; // for mouse tracking
< 				
<                 // some API data
<                 point.category = categories && categories[point.x] !== UNDEFINED ?
<                 categories[point.x] : point.x;
---
> 	translate: function() {
> 		var series = this, 
> 			chart = series.chart, 
> 			stacking = series.options.stacking,
> 			categories = series.xAxis.categories,
> 			yAxis = series.yAxis,
> 			data = series.data,			
> 			i = data.length;
> 			
> 		// do the translation
> 		while (i--) {
> 			var point = data[i],
> 				xValue = point.x, 
> 				yValue = point.y, 
> 				yBottom = point.low,
> 				stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
> 				pointStack,
> 				pointStackTotal;
> 			point.plotX = series.xAxis.translate(xValue);
> 			
> 			// calculate the bottom y value for stacked series
> 			if (stacking && series.visible && stack && stack[xValue]) {
> 				pointStack = stack[xValue];
> 				pointStackTotal = pointStack.total;
> 				pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
> 				yValue = yBottom + yValue;
> 				
> 				if (stacking === 'percent') {
> 					yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
> 					yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
> 				}
> 
> 				point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
> 				point.stackTotal = pointStackTotal;
> 			}
> 			
> 			if (defined(yBottom)) {
> 				point.yBottom = yAxis.translate(yBottom, 0, 1, 0, 1);
> 			}
> 			
> 			// set the y value
> 			if (yValue !== null) {
> 				point.plotY = yAxis.translate(yValue, 0, 1, 0, 1);
> 			}
> 			
> 			// set client related positions for mouse tracking
> 			point.clientX = chart.inverted ? 
> 				chart.plotHeight - point.plotX : 
> 				point.plotX; // for mouse tracking
> 				
> 			// some API data
> 			point.category = categories && categories[point.x] !== UNDEFINED ? 
> 				categories[point.x] : point.x;
9075,9077c8943,8945
<             }
<         },
<         /**
---
> 		}
> 	},
> 	/**
9080,9119c8948,8987
<         setTooltipPoints: function (renew) {
<             var series = this,
<             chart = series.chart,
<             inverted = chart.inverted,
<             data = [],
<             plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
<             low,
<             high,
<             tooltipPoints = []; // a lookup array for each pixel in the x dimension
< 			
<             // renew
<             if (renew) {
<                 series.tooltipPoints = null;
<             }
< 			
<             // concat segments to overcome null values
<             each(series.segments, function(segment){
<                 data = data.concat(segment);
<             });
< 		
<             // loop the concatenated data and apply each point to all the closest
<             // pixel positions
<             if (series.xAxis && series.xAxis.reversed) {
<                 data = data.reverse();//reverseArray(data);
<             }
< 		
<             each(data, function(point, i) {
< 			
<                 low = data[i - 1] ? data[i - 1]._high + 1 : 0;
<                 high = point._high = data[i + 1] ? (
<                     mathFloor((point.plotX + (data[i + 1] ?
<                         data[i + 1].plotX : plotSize)) / 2)) :
<                 plotSize;
< 			
<                 while (low <= high) {
<                     tooltipPoints[inverted ? plotSize - low++ : low++] = point;
<                 }
<             });
<             series.tooltipPoints = tooltipPoints;
<         },
---
> 	setTooltipPoints: function (renew) {
> 		var series = this,
> 			chart = series.chart,
> 			inverted = chart.inverted,
> 			data = [],
> 			plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
> 			low,
> 			high,
> 			tooltipPoints = []; // a lookup array for each pixel in the x dimension
> 			
> 		// renew
> 		if (renew) {
> 			series.tooltipPoints = null;
> 		}
> 			
> 		// concat segments to overcome null values
> 		each(series.segments, function(segment){
> 			data = data.concat(segment);
> 		});
> 		
> 		// loop the concatenated data and apply each point to all the closest
> 		// pixel positions
> 		if (series.xAxis && series.xAxis.reversed) {
> 			data = data.reverse();//reverseArray(data);
> 		}
> 		
> 		each(data, function(point, i) {
> 			
> 			low = data[i - 1] ? data[i - 1]._high + 1 : 0;
> 			high = point._high = data[i + 1] ? (
> 				mathFloor((point.plotX + (data[i + 1] ? 
> 					data[i + 1].plotX : plotSize)) / 2)) :
> 					plotSize;
> 			
> 			while (low <= high) {
> 				tooltipPoints[inverted ? plotSize - low++ : low++] = point;
> 			}
> 		});
> 		series.tooltipPoints = tooltipPoints;
> 	},
9124c8992
<         /**
---
> 	/**
9127,9158c8995,9026
<         onMouseOver: function() {
<             var series = this,
<             chart = series.chart,
<             hoverSeries = chart.hoverSeries;
< 			
<             if (!hasTouch && chart.mouseIsDown) {
<                 return;
<             }
< 		
<             // set normal state to previous series
<             if (hoverSeries && hoverSeries !== series) {
<                 hoverSeries.onMouseOut();
<             }
< 		
<             // trigger the event, but to save processing time,
<             // only if defined
<             if (series.options.events.mouseOver) {
<                 fireEvent(series, 'mouseOver');
<             }
< 		
< 		
<             // bring to front
<             // Todo: optimize. This is one of two operations slowing down the tooltip in Firefox.
<             // Can the tracking be done otherwise?
<             if (series.tracker) {
<                 series.tracker.toFront();
<             }
< 		
<             // hover this
<             series.setState(HOVER_STATE);
<             chart.hoverSeries = series;
<         },
---
> 	onMouseOver: function() {
> 		var series = this,
> 			chart = series.chart,
> 			hoverSeries = chart.hoverSeries;
> 			
> 		if (!hasTouch && chart.mouseIsDown) {
> 			return;
> 		}
> 		
> 		// set normal state to previous series
> 		if (hoverSeries && hoverSeries !== series) {
> 			hoverSeries.onMouseOut();
> 		}
> 		
> 		// trigger the event, but to save processing time, 
> 		// only if defined
> 		if (series.options.events.mouseOver) { 
> 			fireEvent(series, 'mouseOver');
> 		}
> 		
> 		
> 		// bring to front
> 		// Todo: optimize. This is one of two operations slowing down the tooltip in Firefox.
> 		// Can the tracking be done otherwise?
> 		if (series.tracker) {
> 			series.tracker.toFront();
> 		}
> 		
> 		// hover this
> 		series.setState(HOVER_STATE);
> 		chart.hoverSeries = series;
> 	},
9160c9028
<         /**
---
> 	/**
9163,9190c9031,9058
<         onMouseOut: function() {
<             // trigger the event only if listeners exist
<             var series = this,
<             options = series.options,
<             chart = series.chart,
<             tooltip = chart.tooltip,
<             hoverPoint = chart.hoverPoint;
< 		
<             // trigger mouse out on the point, which must be in this series
<             if (hoverPoint) {
<                 hoverPoint.onMouseOut();
<             }
< 		
<             // fire the mouse out event
<             if (series && options.events.mouseOut) {
<                 fireEvent(series, 'mouseOut');
<             }
< 		
< 		
<             // hide the tooltip
<             if (tooltip && !options.stickyTracking) {
<                 tooltip.hide();
<             }
< 		
<             // set normal state
<             series.setState();
<             chart.hoverSeries = null;
<         },
---
> 	onMouseOut: function() {
> 		// trigger the event only if listeners exist
> 		var series = this,
> 			options = series.options,
> 			chart = series.chart,
> 			tooltip = chart.tooltip,
> 			hoverPoint = chart.hoverPoint;
> 		
> 		// trigger mouse out on the point, which must be in this series
> 		if (hoverPoint) {
> 			hoverPoint.onMouseOut();
> 		}		
> 		
> 		// fire the mouse out event
> 		if (series && options.events.mouseOut) { 
> 			fireEvent(series, 'mouseOut');
> 		}
> 		
> 		
> 		// hide the tooltip
> 		if (tooltip && !options.stickyTracking) {
> 			tooltip.hide();
> 		}
> 		
> 		// set normal state
> 		series.setState();
> 		chart.hoverSeries = null;		
> 	},
9192c9060
<         /**
---
> 	/**
9195,9219c9063,9087
<         animate: function(init) {
<             var series = this,
<             chart = series.chart,
<             clipRect = series.clipRect,
<             animation = series.options.animation;
< 			
<             if (animation && !isObject(animation)) {
<                 animation = {};
<             }
< 			
<             if (init) { // initialize the animation
<                 if (!clipRect.isAnimating) { // apply it only for one of the series
<                     clipRect.attr( 'width', 0 );
<                     clipRect.isAnimating = true;
<                 }
< 			
<             } else { // run the animation
<                 clipRect.animate({
<                     width: chart.plotSizeX
<                 }, animation);
< 			
<                 // delete this function to allow it only once
<                 this.animate = null;
<             }
<         },
---
> 	animate: function(init) {
> 		var series = this,
> 			chart = series.chart,
> 			clipRect = series.clipRect,
> 			animation = series.options.animation;
> 			
> 		if (animation && !isObject(animation)) {
> 			animation = {};
> 		}
> 			
> 		if (init) { // initialize the animation
> 			if (!clipRect.isAnimating) { // apply it only for one of the series
> 				clipRect.attr( 'width', 0 );
> 				clipRect.isAnimating = true;
> 			}
> 			
> 		} else { // run the animation
> 			clipRect.animate({ 
> 				width: chart.plotSizeX 
> 			}, animation);
> 			
> 			// delete this function to allow it only once
> 			this.animate = null;
> 		}
> 	},
9222c9090
<         /**
---
> 	/**
9225,9243c9093,9111
<         drawPoints: function(){
<             var series = this,
<             pointAttr,
<             data = series.data,
<             chart = series.chart,
<             plotX,
<             plotY,
<             i,
<             point,
<             radius,
<             graphic;
< 		
<             if (series.options.marker.enabled) {
<                 i = data.length;
<                 while (i--) {
<                     point = data[i];
<                     plotX = point.plotX;
<                     plotY = point.plotY;
<                     graphic = point.graphic;
---
> 	drawPoints: function(){
> 		var series = this,
> 			pointAttr,
> 			data = series.data, 
> 			chart = series.chart,
> 			plotX,
> 			plotY,
> 			i,
> 			point,
> 			radius,
> 			graphic;
> 		
> 		if (series.options.marker.enabled) {
> 			i = data.length;
> 			while (i--) {
> 				point = data[i];
> 				plotX = point.plotX;
> 				plotY = point.plotY;
> 				graphic = point.graphic;
9245,9246c9113,9114
<                     // only draw the point if y is defined
<                     if (plotY !== UNDEFINED && !isNaN(plotY)) {
---
> 				// only draw the point if y is defined
> 				if (plotY !== UNDEFINED && !isNaN(plotY)) {
9248c9116
<                         /* && removed this code because points stayed after zoom
---
> 					/* && removed this code because points stayed after zoom
9252,9274c9120,9142
<                         // shortcuts
<                         pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
<                         radius = pointAttr.r;
< 					
<                         if (graphic) { // update
<                             graphic.animate({
<                                 x: plotX,
<                                 y: plotY,
<                                 r: radius
<                             });
<                         } else {
<                             point.graphic = chart.renderer.symbol(
<                                 pick(point.marker && point.marker.symbol, series.symbol),
<                                 plotX,
<                                 plotY,
<                                 radius
<                                 )
<                             .attr(pointAttr)
<                             .add(series.group);
<                         }
<                     }
<                 }
<             }
---
> 					// shortcuts
> 					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
> 					radius = pointAttr.r;
> 					
> 					if (graphic) { // update
> 						graphic.animate({
> 							x: plotX,
> 							y: plotY,
> 							r: radius
> 						});
> 					} else {
> 						point.graphic = chart.renderer.symbol(
> 							pick(point.marker && point.marker.symbol, series.symbol),
> 							plotX,
> 							plotY, 
> 							radius
> 						)
> 						.attr(pointAttr)
> 						.add(series.group);
> 					}
> 				}
> 			}
> 		}
9276c9144
<         },
---
> 	},
9278c9146
<         /**
---
> 	/**
9285,9301c9153,9169
<         convertAttribs: function(options, base1, base2, base3) {
<             var conversion = this.pointAttrToOptions,
<             attr,
<             option,
<             obj = {};
< 		
<             options = options || {};
<             base1 = base1 || {};
<             base2 = base2 || {};
<             base3 = base3 || {};
< 		
<             for (attr in conversion) {
<                 option = conversion[attr];
<                 obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
<             }
<             return obj;
<         },
---
> 	convertAttribs: function(options, base1, base2, base3) {
> 		var conversion = this.pointAttrToOptions,
> 			attr,
> 			option,
> 			obj = {};
> 		
> 		options = options || {};
> 		base1 = base1 || {};
> 		base2 = base2 || {};
> 		base3 = base3 || {};
> 		
> 		for (attr in conversion) {
> 			option = conversion[attr];
> 			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);		 
> 		}
> 		return obj;
> 	},
9303c9171
<         /**
---
> 	/**
9310,9355c9178,9211
<         getAttribs: function() {
<             var series = this,
<             normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
<             stateOptions = normalOptions.states,
<             stateOptionsHover = stateOptions[HOVER_STATE],
<             pointStateOptionsHover,
<             seriesColor = series.color,
<             normalDefaults = {
<                 stroke: seriesColor,
<                 fill: seriesColor
<             },
<             data = series.data,
<             i,
<             point,
<             seriesPointAttr = [],
<             pointAttr,
<             pointAttrToOptions = series.pointAttrToOptions,
<             hasPointSpecificOptions,
<             key;
< 			
<             // series type specific modifications
<             if (series.options.marker) { // line, spline, area, areaspline, scatter
< 			
<                 // if no hover radius is given, default to normal radius + 2
<                 stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
<                 stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
< 			
<             } else { // column, bar, pie
< 			
<                 // if no hover color is given, brighten the normal color
<                 stateOptionsHover.color = stateOptionsHover.color ||
<                 Color(stateOptionsHover.color || seriesColor)
<                 .brighten(stateOptionsHover.brightness).get();
<             }
< 		
<             // general point attributes for the series normal state
<             seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);
< 		
<             // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
<             each([HOVER_STATE, SELECT_STATE], function(state) {
<                 seriesPointAttr[state] =
<                 series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
<             });
< 				
<             // set it
<             series.pointAttr = seriesPointAttr;
---
> 	getAttribs: function() {
> 		var series = this, 
> 			normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
> 			stateOptions = normalOptions.states,
> 			stateOptionsHover = stateOptions[HOVER_STATE],
> 			pointStateOptionsHover,
> 			seriesColor = series.color,
> 			normalDefaults = {
> 				stroke: seriesColor,
> 				fill: seriesColor
> 			},
> 			data = series.data,
> 			i,
> 			point,
> 			seriesPointAttr = [],
> 			pointAttr,
> 			pointAttrToOptions = series.pointAttrToOptions,
> 			hasPointSpecificOptions,
> 			key;
> 			
> 		// series type specific modifications
> 		if (series.options.marker) { // line, spline, area, areaspline, scatter
> 			
> 			// if no hover radius is given, default to normal radius + 2  
> 			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
> 			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
> 			
> 		} else { // column, bar, pie
> 			
> 			// if no hover color is given, brighten the normal color
> 			stateOptionsHover.color = stateOptionsHover.color || 
> 				Color(stateOptionsHover.color || seriesColor)
> 					.brighten(stateOptionsHover.brightness).get();
> 		}
9356a9213,9214
> 		// general point attributes for the series normal state
> 		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);
9358,9377c9216,9236
<             // Generate the point-specific attribute collections if specific point
<             // options are given. If not, create a referance to the series wide point
<             // attributes
<             i = data.length;
<             while (i--) {
<                 point = data[i];
<                 normalOptions = (point.options && point.options.marker) || point.options;
<                 if (normalOptions && normalOptions.enabled === false) {
<                     normalOptions.radius = 0;
<                 }
<                 hasPointSpecificOptions = false;
< 			
<                 // check if the point has specific visual options
<                 if (point.options) {
<                     for (key in pointAttrToOptions) {
<                         if (defined(normalOptions[pointAttrToOptions[key]])) {
<                             hasPointSpecificOptions = true;
<                         }
<                     }
<                 }
---
> 		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
> 		each([HOVER_STATE, SELECT_STATE], function(state) {
> 			seriesPointAttr[state] = 
> 					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
> 		});
> 				
> 		// set it
> 		series.pointAttr = seriesPointAttr;
> 		
> 		
> 		// Generate the point-specific attribute collections if specific point
> 		// options are given. If not, create a referance to the series wide point 
> 		// attributes
> 		i = data.length;
> 		while (i--) {
> 			point = data[i];
> 			normalOptions = (point.options && point.options.marker) || point.options;
> 			if (normalOptions && normalOptions.enabled === false) {
> 				normalOptions.radius = 0;
> 			}
> 			hasPointSpecificOptions = false;
9378a9238,9245
> 			// check if the point has specific visual options
> 			if (point.options) {
> 				for (key in pointAttrToOptions) {
> 					if (defined(normalOptions[pointAttrToOptions[key]])) {
> 						hasPointSpecificOptions = true;
> 					}
> 				}
> 			}
9381,9394c9248,9262
<                 // a specific marker config object is defined for the individual point:
<                 // create it's own attribute collection
<                 if (hasPointSpecificOptions) {
< 
<                     pointAttr = [];
<                     stateOptions = normalOptions.states || {}; // reassign for individual point
<                     pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};
< 				
<                     // if no hover color is given, brighten the normal color
<                     if (!series.options.marker) { // column, bar, point
<                         pointStateOptionsHover.color =
<                         Color(pointStateOptionsHover.color || point.options.color)
<                         .brighten(pointStateOptionsHover.brightness ||
<                             stateOptionsHover.brightness).get();
---
> 			
> 			// a specific marker config object is defined for the individual point:
> 			// create it's own attribute collection
> 			if (hasPointSpecificOptions) {
> 
> 				pointAttr = [];
> 				stateOptions = normalOptions.states || {}; // reassign for individual point
> 				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};
> 				
> 				// if no hover color is given, brighten the normal color
> 				if (!series.options.marker) { // column, bar, point
> 					pointStateOptionsHover.color = 
> 						Color(pointStateOptionsHover.color || point.options.color)
> 							.brighten(pointStateOptionsHover.brightness || 
> 								stateOptionsHover.brightness).get();
9396c9264
<                     }
---
> 				}
9398,9399c9266,9267
<                     // normal point state inherits series wide normal state
<                     pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);
---
> 				// normal point state inherits series wide normal state
> 				pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);
9401,9412c9269,9280
<                     // inherit from point normal and series hover
<                     pointAttr[HOVER_STATE] = series.convertAttribs(
<                         stateOptions[HOVER_STATE],
<                         seriesPointAttr[HOVER_STATE],
<                         pointAttr[NORMAL_STATE]
<                         );
<                     // inherit from point normal and series hover
<                     pointAttr[SELECT_STATE] = series.convertAttribs(
<                         stateOptions[SELECT_STATE],
<                         seriesPointAttr[SELECT_STATE],
<                         pointAttr[NORMAL_STATE]
<                         );
---
> 				// inherit from point normal and series hover
> 				pointAttr[HOVER_STATE] = series.convertAttribs(
> 					stateOptions[HOVER_STATE],
> 					seriesPointAttr[HOVER_STATE],
> 					pointAttr[NORMAL_STATE]
> 				);
> 				// inherit from point normal and series hover
> 				pointAttr[SELECT_STATE] = series.convertAttribs(
> 					stateOptions[SELECT_STATE],
> 					seriesPointAttr[SELECT_STATE],
> 					pointAttr[NORMAL_STATE]
> 				);
9416,9420c9284,9288
<                 // no marker config object is created: copy a reference to the series-wide
<                 // attribute collection
<                 } else {
<                     pointAttr = seriesPointAttr;
<                 }
---
> 			// no marker config object is created: copy a reference to the series-wide
> 			// attribute collection
> 			} else {
> 				pointAttr = seriesPointAttr;
> 			}
9422c9290
<                 point.pointAttr = pointAttr;
---
> 			point.pointAttr = pointAttr;
9424c9292
<             }
---
> 		}
9426c9294
<         },
---
> 	},
9429c9297
<         /**
---
> 	/**
9432,9460c9300,9328
<         destroy: function() {
<             var series = this,
<             chart = series.chart,
<             //chartSeries = series.chart.series,
<             clipRect = series.clipRect,
<             issue134 = /\/5[0-9\.]+ (Safari|Mobile)\//.test(userAgent), // todo: update when Safari bug is fixed
<             destroy,
<             prop;
< 		
<             // remove all events
<             removeEvent(series);
< 			
<             // remove legend items
<             if (series.legendItem) {
<                 series.chart.legend.destroyItem(series);
<             }
< 		
<             // destroy all points with their elements
<             each(series.data, function(point) {
<                 point.destroy();
<             });
<             // destroy all SVGElements associated to the series
<             each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function(prop) {
<                 if (series[prop]) {
< 				
<                     // issue 134 workaround
<                     destroy = issue134 && prop === 'group' ?
<                     'hide' :
<                     'destroy';
---
> 	destroy: function() {
> 		var series = this,
> 			chart = series.chart,
> 			//chartSeries = series.chart.series,
> 			clipRect = series.clipRect,
> 			issue134 = /\/5[0-9\.]+ (Safari|Mobile)\//.test(userAgent), // todo: update when Safari bug is fixed
> 			destroy,
> 			prop;
> 		
> 		// remove all events
> 		removeEvent(series);
> 			
> 		// remove legend items
> 		if (series.legendItem) {
> 			series.chart.legend.destroyItem(series);
> 		}
> 		
> 		// destroy all points with their elements
> 		each(series.data, function(point) {
> 			point.destroy();
> 		});
> 		// destroy all SVGElements associated to the series
> 		each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function(prop) {
> 			if (series[prop]) {
> 				
> 				// issue 134 workaround
> 				destroy = issue134 && prop === 'group' ?
> 					'hide' :
> 					'destroy';
9462,9470c9330,9338
<                     series[prop][destroy]();
<                 }
<             });
< 		
<             // remove from hoverSeries
<             if (chart.hoverSeries === series) {
<                 chart.hoverSeries = null;
<             }
<             erase(chart.series, series);
---
> 				series[prop][destroy]();
> 			}
> 		});
> 		
> 		// remove from hoverSeries
> 		if (chart.hoverSeries === series) {
> 			chart.hoverSeries = null;
> 		}
> 		erase(chart.series, series);
9472,9476c9340,9344
<             // clear all members
<             for (prop in series) {
<                 delete series[prop];
<             }
<         },
---
> 		// clear all members
> 		for (prop in series) {
> 			delete series[prop];
> 		} 
> 	},
9478c9346
<         /**
---
> 	/**
9481,9575c9349,9426
<         drawDataLabels: function() {
<             if (this.options.dataLabels.enabled) {
<                 var series = this,
<                 x,
<                 y,
<                 data = series.data,
<                 options = series.options.dataLabels,
<                 str,
<                 dataLabelsGroup = series.dataLabelsGroup,
<                 chart = series.chart,
<                 inverted = chart.inverted,
<                 seriesType = series.type,
<                 color,
<                 stacking = series.options.stacking,
<                 isBarLike = seriesType === 'column' || seriesType === 'bar',
<                 vAlignIsNull = options.verticalAlign === null,
<                 yIsNull = options.y === null;
< 
<                 if (isBarLike) {
<                     if (stacking) {
<                         // In stacked series the default label placement is inside the bars
<                         if (vAlignIsNull) {
<                             options = merge(options, {
<                                 verticalAlign: 'middle'
<                             });
<                         }
< 
<                         // If no y delta is specified, try to create a good default
<                         if (yIsNull) {
<                             options = merge(options, {
<                                 y: {
<                                     top: 14,
<                                     middle: 4,
<                                     bottom: -6
<                                 }
<                                 [options.verticalAlign]
<                             });
<                         }
<                     } else {
<                         // In non stacked series the default label placement is on top of the bars
<                         if (vAlignIsNull) {
<                             options = merge(options, {
<                                 verticalAlign: 'top'
<                             });
<                         }
< 
<                         // If no y delta is specified, set the default
<                         if (yIsNull) {
<                             options = merge(options, {
<                                 y: -6
<                             });
<                         }
<                     }
<                 }
< 
<                 // create a separate group for the data labels to avoid rotation
<                 if (!dataLabelsGroup) {
<                     dataLabelsGroup = series.dataLabelsGroup =
<                     chart.renderer.g('data-labels')
<                     .attr({
<                         visibility: series.visible ? VISIBLE : HIDDEN,
<                         zIndex: 6
<                     })
<                     .translate(chart.plotLeft, chart.plotTop)
<                     .add();
<                 }
< 		
<                 // determine the color
<                 color = options.color;
<                 if (color === 'auto') { // 1.0 backwards compatibility
<                     color = null;
<                 }
<                 options.style.color = pick(color, series.color);
< 		
<                 // make the labels for each point
<                 each(data, function(point, i){
<                     var barX = point.barX,
<                     plotX = (barX && barX + point.barW / 2) || point.plotX || -999,
<                     plotY = pick(point.plotY, -999),
<                     dataLabel = point.dataLabel,
<                     align = options.align;
< 					
<                     // get the string
<                     str = options.formatter.call(point.getLabelConfig());
<                     x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
<                     y = (inverted ? chart.plotHeight - plotX : plotY) + options.y;
< 				
<                     // in columns, align the string to the column
<                     if (seriesType === 'column') {
<                         x += {
<                             left: -1,
<                             right: 1
<                         }
<                         [align] * point.barW / 2 || 0;
<                     }
---
> 	drawDataLabels: function() {
> 		if (this.options.dataLabels.enabled) {
> 			var series = this,
> 				x, 
> 				y, 
> 				data = series.data, 
> 				options = series.options.dataLabels,
> 				str, 
> 				dataLabelsGroup = series.dataLabelsGroup, 
> 				chart = series.chart, 
> 				inverted = chart.inverted,
> 				seriesType = series.type,
> 				color,
> 				stacking = series.options.stacking,
> 				isBarLike = seriesType === 'column' || seriesType === 'bar',
> 				vAlignIsNull = options.verticalAlign === null,
> 				yIsNull = options.y === null;
> 
> 			if (isBarLike) {
> 				if (stacking) {
> 					// In stacked series the default label placement is inside the bars
> 					if (vAlignIsNull) {
> 						options = merge(options, {verticalAlign: 'middle'});
> 					}
> 
> 					// If no y delta is specified, try to create a good default
> 					if (yIsNull) {
> 						options = merge(options, {y: {top: 14, middle: 4, bottom: -6}[options.verticalAlign]}); 
> 					}
> 				} else {
> 					// In non stacked series the default label placement is on top of the bars
> 					if (vAlignIsNull) {
> 						options = merge(options, {verticalAlign: 'top'});
> 					}
> 
> 					// If no y delta is specified, set the default
> 					if (yIsNull) {
> 						options = merge(options, {y: -6}); 
> 					}
> 				}
> 			}
> 
> 			// create a separate group for the data labels to avoid rotation
> 			if (!dataLabelsGroup) {
> 				dataLabelsGroup = series.dataLabelsGroup = 
> 					chart.renderer.g('data-labels')
> 						.attr({ 
> 							visibility: series.visible ? VISIBLE : HIDDEN,
> 							zIndex: 6							
> 						})
> 						.translate(chart.plotLeft, chart.plotTop)
> 						.add();
> 			}
> 		
> 			// determine the color
> 			color = options.color;
> 			if (color === 'auto') { // 1.0 backwards compatibility
> 				color = null;	
> 			}
> 			options.style.color = pick(color, series.color);
> 		
> 			// make the labels for each point
> 			each(data, function(point, i){
> 				var barX = point.barX,
> 					plotX = (barX && barX + point.barW / 2) || point.plotX || -999,
> 					plotY = pick(point.plotY, -999),
> 					dataLabel = point.dataLabel,
> 					align = options.align;
> 					
> 				// get the string
> 				str = options.formatter.call(point.getLabelConfig());
> 				x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
> 				y = (inverted ? chart.plotHeight - plotX : plotY) + options.y;
> 				
> 				// in columns, align the string to the column
> 				if (seriesType === 'column') {
> 					x += { left: -1, right: 1 }[align] * point.barW / 2 || 0;
> 				}
9577,9610c9428,9461
<                     // update existing label
<                     if (dataLabel) {
<                         // vertically centered
<                         if (inverted && !options.y) {
<                             y = y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2;
<                         }
<                         dataLabel
<                         .attr({
<                             text: str
<                         }).animate({
<                             x: x,
<                             y: y
<                         });
<                     // create new label
<                     } else if (defined(str)) {
<                         dataLabel = point.dataLabel = chart.renderer.text(
<                             str,
<                             x,
<                             y
<                             )
<                         .attr({
<                             align: align,
<                             rotation: options.rotation,
<                             zIndex: 1
<                         })
<                         .css(options.style)
<                         .add(dataLabelsGroup);
<                         // vertically centered
<                         if (inverted && !options.y) {
<                             dataLabel.attr({
<                                 y: y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2
<                             });
<                         }
<                     }
---
> 				// update existing label
> 				if (dataLabel) {
> 					// vertically centered
> 					if (inverted && !options.y) {
> 						y = y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2;
> 					}
> 					dataLabel
> 						.attr({
> 							text: str
> 						}).animate({
> 							x: x,
> 							y: y
> 						});
> 				// create new label
> 				} else if (defined(str)) {
> 					dataLabel = point.dataLabel = chart.renderer.text(
> 						str, 
> 						x, 
> 						y
> 					)
> 					.attr({
> 						align: align,
> 						rotation: options.rotation,
> 						zIndex: 1
> 					})
> 					.css(options.style)
> 					.add(dataLabelsGroup);
> 					// vertically centered
> 					if (inverted && !options.y) {
> 						dataLabel.attr({
> 							y: y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2
> 						});
> 					}
> 				}
9613c9464
<                     /*if (series.isCartesian) {
---
> 				/*if (series.isCartesian) {
9617,9632c9468,9483
<                     if (isBarLike && series.options.stacking) {
<                         var barY = point.barY,
<                         barW = point.barW,
<                         barH = point.barH;
< 
<                         dataLabel.align(options, null,
<                         {
<                             x: inverted ? chart.plotWidth - barY - barH : barX,
<                             y: inverted ? chart.plotHeight - barX - barW : barY,
<                             width: inverted ? barH : barW,
<                             height: inverted ? barW : barH
<                         });
<                     }
<                 });
<             }
<         },
---
> 				if (isBarLike && series.options.stacking) {
> 					var barY = point.barY,
> 						barW = point.barW,
> 						barH = point.barH;
> 
> 					dataLabel.align(options, null, 
> 						{
> 							x: inverted ? chart.plotWidth - barY - barH : barX,
> 							y: inverted ? chart.plotHeight - barX - barW : barY,
> 							width: inverted ? barH : barW,
> 							height: inverted ? barW : barH
> 						});
> 				}
> 			});
> 		}
> 	},
9634c9485
<         /**
---
> 	/**
9637,9680c9488,9531
<         drawGraph: function(state) {
<             var series = this,
<             options = series.options,
<             chart = series.chart,
<             graph = series.graph,
<             graphPath = [],
<             fillColor,
<             area = series.area,
<             group = series.group,
<             color = options.lineColor || series.color,
<             lineWidth = options.lineWidth,
<             dashStyle =  options.dashStyle,
<             segmentPath,
<             renderer = chart.renderer,
<             translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
<             useArea = /^area/.test(series.type),
<             singlePoints = [], // used in drawTracker
<             areaPath = [],
<             attribs;
< 			
< 		
<             // divide into segments and build graph and area paths
<             each(series.segments, function(segment) {
<                 segmentPath = [];
< 			
<                 // build the segment line
<                 each(segment, function(point, i) {
< 
<                     if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
<                         segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
< 				
<                     } else {
< 				
<                         // moveTo or lineTo
<                         segmentPath.push(i ? L : M);
< 					
<                         // step line?
<                         if (i && options.step) {
<                             var lastPoint = segment[i - 1];
<                             segmentPath.push(
<                                 point.plotX,
<                                 lastPoint.plotY
<                                 );
<                         }
---
> 	drawGraph: function(state) {
> 		var series = this, 
> 			options = series.options, 
> 			chart = series.chart,
> 			graph = series.graph,
> 			graphPath = [],
> 			fillColor,
> 			area = series.area,
> 			group = series.group,
> 			color = options.lineColor || series.color, 
> 			lineWidth = options.lineWidth,
> 			dashStyle =  options.dashStyle,
> 			segmentPath,
> 			renderer = chart.renderer,
> 			translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
> 			useArea = /^area/.test(series.type),
> 			singlePoints = [], // used in drawTracker
> 			areaPath = [],
> 			attribs;
> 			
> 		
> 		// divide into segments and build graph and area paths
> 		each(series.segments, function(segment) {
> 			segmentPath = [];
> 			
> 			// build the segment line
> 			each(segment, function(point, i) {
> 
> 				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
> 					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
> 				
> 				} else {
> 				
> 					// moveTo or lineTo
> 					segmentPath.push(i ? L : M);
> 					
> 					// step line?
> 					if (i && options.step) {
> 						var lastPoint = segment[i - 1];
> 						segmentPath.push(
> 							point.plotX, 
> 							lastPoint.plotY						
> 						);
> 					}
9682,9712c9533,9563
<                         // normal line to next point
<                         segmentPath.push(
<                             point.plotX,
<                             point.plotY
<                             );
<                     }
<                 });
< 			
<                 // add the segment to the graph, or a single point for tracking
<                 if (segment.length > 1) {
<                     graphPath = graphPath.concat(segmentPath);
<                 } else {
<                     singlePoints.push(segment[0]);
<                 }
< 			
<                 // build the area
<                 if (useArea) {
<                     var areaSegmentPath = [],
<                     i,
<                     segLength = segmentPath.length;
<                     for (i = 0; i < segLength; i++) {
<                         areaSegmentPath.push(segmentPath[i]);
<                     }
<                     if (segLength === 3) { // for animation from 1 to two points
<                         areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
<                     }
<                     if (options.stacking && series.type !== 'areaspline') {
<                         // follow stack back. Todo: implement areaspline
<                         for (i = segment.length - 1; i >= 0; i--) {
<                             areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
<                         }
---
> 					// normal line to next point
> 					segmentPath.push(
> 						point.plotX, 
> 						point.plotY
> 					);
> 				}
> 			});
> 			
> 			// add the segment to the graph, or a single point for tracking
> 			if (segment.length > 1) {
> 				graphPath = graphPath.concat(segmentPath);
> 			} else {
> 				singlePoints.push(segment[0]);
> 			}
> 			
> 			// build the area
> 			if (useArea) {
> 				var areaSegmentPath = [],
> 					i,
> 					segLength = segmentPath.length;
> 				for (i = 0; i < segLength; i++) {
> 					areaSegmentPath.push(segmentPath[i]);
> 				}
> 				if (segLength === 3) { // for animation from 1 to two points
> 					areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
> 				}
> 				if (options.stacking && series.type !== 'areaspline') {
> 					// follow stack back. Todo: implement areaspline
> 					for (i = segment.length - 1; i >= 0; i--) {
> 						areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
> 					}
9714,9767c9565,9614
<                     } else { // follow zero line back
<                         areaSegmentPath.push(
<                             L,
<                             segment[segment.length - 1].plotX,
<                             translatedThreshold,
<                             L,
<                             segment[0].plotX,
<                             translatedThreshold
<                             );
<                     }
<                     areaPath = areaPath.concat(areaSegmentPath);
<                 }
<             });
< 
<             // used in drawTracker:
<             series.graphPath = graphPath;
<             series.singlePoints = singlePoints;
< 
<             // draw the area if area series or areaspline
<             if (useArea) {
<                 fillColor = pick(
<                     options.fillColor,
<                     Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
<                     );
<                 if (area) {
<                     area.animate({
<                         d: areaPath
<                     });
< 			
<                 } else {
<                     // draw the area
<                     series.area = series.chart.renderer.path(areaPath)
<                     .attr({
<                         fill: fillColor
<                     }).add(group);
<                 }
<             }
< 		
<             // draw the graph
<             if (graph) {
<                 //graph.animate({ d: graphPath.join(' ') });
<                 graph.animate({
<                     d: graphPath
<                 });
< 			
<             } else {
<                 if (lineWidth) {
<                     attribs = {
<                         'stroke': color,
<                         'stroke-width': lineWidth
<                     };
<                     if (dashStyle) {
<                         attribs.dashstyle = dashStyle;
<                     }
---
> 				} else { // follow zero line back
> 					areaSegmentPath.push(
> 						L,
> 						segment[segment.length - 1].plotX, 
> 						translatedThreshold,
> 						L,
> 						segment[0].plotX, 
> 						translatedThreshold
> 					);
> 				}
> 				areaPath = areaPath.concat(areaSegmentPath);
> 			}
> 		});
> 
> 		// used in drawTracker:
> 		series.graphPath = graphPath;
> 		series.singlePoints = singlePoints;
> 
> 		// draw the area if area series or areaspline
> 		if (useArea) {
> 			fillColor = pick(
> 				options.fillColor,
> 				Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
> 			);
> 			if (area) {
> 				area.animate({ d: areaPath });
> 			
> 			} else {
> 				// draw the area
> 				series.area = series.chart.renderer.path(areaPath)
> 					.attr({
> 						fill: fillColor
> 					}).add(group);
> 			}
> 		}
> 		
> 		// draw the graph
> 		if (graph) {
> 			//graph.animate({ d: graphPath.join(' ') });
> 			graph.animate({ d: graphPath });
> 			
> 		} else {
> 			if (lineWidth) {
> 				attribs = {
> 					'stroke': color,
> 					'stroke-width': lineWidth
> 				};
> 				if (dashStyle) {
> 					attribs.dashstyle = dashStyle;
> 				}
9769,9773c9616,9620
<                     series.graph = renderer.path(graphPath)
<                     .attr(attribs).add(group).shadow(options.shadow);
<                 }
<             }
<         },
---
> 				series.graph = renderer.path(graphPath)
> 					.attr(attribs).add(group).shadow(options.shadow);
> 			}
> 		}
> 	},
9776c9623
<         /**
---
> 	/**
9779,9864c9626,9688
<         render: function() {
<             var series = this,
<             chart = series.chart,
<             group,
<             setInvert,
<             options = series.options,
<             animation = options.animation,
<             doAnimation = animation && series.animate,
<             duration = doAnimation ? (animation && animation.duration) || 500 : 0,
<             clipRect = series.clipRect,
<             renderer = chart.renderer;
< 			
< 		
<             // Add plot area clipping rectangle. If this is before chart.hasRendered,
<             // create one shared clipRect.
<             if (!clipRect) {
<                 clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
<                 chart.clipRect :
<                 renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY);
<                 if (!chart.clipRect) {
<                     chart.clipRect = clipRect;
<                 }
<             }
< 		
< 			
<             // the group
<             if (!series.group) {
<                 group = series.group = renderer.g('series');
< 				
<                 if (chart.inverted) {
<                     setInvert = function() {
<                         group.attr({
<                             width: chart.plotWidth,
<                             height: chart.plotHeight
<                         }).invert();
<                     };
< 				
<                     setInvert(); // do it now
<                     addEvent(chart, 'resize', setInvert); // do it on resize
<                 }
<                 group.clip(series.clipRect)
<                 .attr({
<                     visibility: series.visible ? VISIBLE : HIDDEN,
<                     zIndex: options.zIndex
<                 })
<                 .translate(chart.plotLeft, chart.plotTop)
<                 .add(chart.seriesGroup);
<             }
< 			
<             series.drawDataLabels();
< 
<             // initiate the animation
<             if (doAnimation) {
<                 series.animate(true);
<             }
< 		
<             // cache attributes for shapes
<             //series.getAttribs();
< 		
<             // draw the graph if any
<             if (series.drawGraph) {
<                 series.drawGraph();
<             }
< 		
<             // draw the points
<             series.drawPoints();
< 		
<             // draw the mouse tracking area
<             if (series.options.enableMouseTracking !== false) {
<                 series.drawTracker();
<             }
< 		
<             // run the animation
<             if (doAnimation) {
<                 series.animate();
<             }
< 		
<             // finish the individual clipRect
<             setTimeout(function() {
<                 clipRect.isAnimating = false;
<                 group = series.group; // can be destroyed during the timeout
<                 if (group && clipRect !== chart.clipRect && clipRect.renderer) {
<                     group.clip((series.clipRect = chart.clipRect));
<                     clipRect.destroy();
<                 }
<             }, duration);
---
> 	render: function() {
> 		var series = this,
> 			chart = series.chart,
> 			group,
> 			setInvert,
> 			options = series.options,
> 			animation = options.animation,
> 			doAnimation = animation && series.animate,
> 			duration = doAnimation ? (animation && animation.duration) || 500 : 0,
> 			clipRect = series.clipRect,
> 			renderer = chart.renderer;
> 			
> 		
> 		// Add plot area clipping rectangle. If this is before chart.hasRendered,
> 		// create one shared clipRect. 
> 		if (!clipRect) {
> 			clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
> 				chart.clipRect : 
> 				renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY);
> 			if (!chart.clipRect) {
> 				chart.clipRect = clipRect;
> 			}
> 		}
> 		
> 			
> 		// the group
> 		if (!series.group) {
> 			group = series.group = renderer.g('series');
> 				
> 			if (chart.inverted) {
> 				setInvert = function() {
> 					group.attr({
> 						width: chart.plotWidth,
> 						height: chart.plotHeight
> 					}).invert();
> 				};
> 				
> 				setInvert(); // do it now
> 				addEvent(chart, 'resize', setInvert); // do it on resize
> 			} 
> 			group.clip(series.clipRect)
> 				.attr({ 
> 					visibility: series.visible ? VISIBLE : HIDDEN,
> 					zIndex: options.zIndex
> 				})
> 				.translate(chart.plotLeft, chart.plotTop)
> 				.add(chart.seriesGroup);
> 		}
> 			
> 		series.drawDataLabels();
> 
> 		// initiate the animation
> 		if (doAnimation) {
> 			series.animate(true);
> 		}
> 		
> 		// cache attributes for shapes
> 		//series.getAttribs();
> 		
> 		// draw the graph if any
> 		if (series.drawGraph) {
> 			series.drawGraph();
> 		}
9865a9690,9711
> 		// draw the points
> 		series.drawPoints();
> 		
> 		// draw the mouse tracking area
> 		if (series.options.enableMouseTracking !== false) {
> 			series.drawTracker();
> 		}
> 		
> 		// run the animation
> 		if (doAnimation) {
> 			series.animate();
> 		}
> 		
> 		// finish the individual clipRect
> 		setTimeout(function() {
> 			clipRect.isAnimating = false;
> 			group = series.group; // can be destroyed during the timeout
> 			if (group && clipRect !== chart.clipRect && clipRect.renderer) {
> 				group.clip((series.clipRect = chart.clipRect));
> 				clipRect.destroy();
> 			}
> 		}, duration);
9867d9712
<             series.isDirty = false; // means data is in accordance with what you see
9869c9714,9716
<         },
---
> 		series.isDirty = false; // means data is in accordance with what you see
> 		
> 	},
9871c9718
<         /**
---
> 	/**
9874,9878c9721,9725
<         redraw: function() {
<             var series = this,
<             chart = series.chart,
<             clipRect = series.clipRect,
<             group = series.group;
---
> 	redraw: function() {
> 		var series = this,
> 			chart = series.chart,
> 			clipRect = series.clipRect,
> 			group = series.group;
9880c9727
<             /*if (clipRect) {
---
> 		/*if (clipRect) {
9888,9906c9735,9753
<             // reposition on resize
<             if (group) {
<                 if (chart.inverted) {
<                     group.attr({
<                         width: chart.plotWidth,
<                         height: chart.plotHeight
<                     });
<                 }
< 			
<                 group.animate({
<                     translateX: chart.plotLeft,
<                     translateY: chart.plotTop
<                 });
<             }
< 		
<             series.translate();
<             series.setTooltipPoints(true);
<             series.render();
<         },
---
> 		// reposition on resize
> 		if (group) {
> 			if (chart.inverted) {
> 				group.attr({
> 					width: chart.plotWidth,
> 					height: chart.plotHeight
> 				});
> 			}
> 			
> 			group.animate({
> 				translateX: chart.plotLeft, 
> 				translateY: chart.plotTop
> 			});
> 		}
> 		
> 		series.translate();
> 		series.setTooltipPoints(true);
> 		series.render();
> 	},
9908c9755
<         /**
---
> 	/**
9911,9916c9758,9763
<         setState: function(state) {
<             var series = this,
<             options = series.options,
<             graph = series.graph,
<             stateOptions = options.states,
<             lineWidth = options.lineWidth;
---
> 	setState: function(state) {
> 		var series = this,
> 			options = series.options,
> 			graph = series.graph,
> 			stateOptions = options.states,
> 			lineWidth = options.lineWidth;
9918c9765
<             state = state || NORMAL_STATE;
---
> 		state = state || NORMAL_STATE;
9920,9921c9767,9776
<             if (series.state !== state) {
<                 series.state = state;
---
> 		if (series.state !== state) {
> 			series.state = state;
> 			
> 			if (stateOptions[state] && stateOptions[state].enabled === false) {
> 				return;
> 			}
> 		
> 			if (state) {
> 				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
> 			}
9923,9937c9778,9784
<                 if (stateOptions[state] && stateOptions[state].enabled === false) {
<                     return;
<                 }
< 		
<                 if (state) {
<                     lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
<                 }
< 			
<                 if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
<                     graph.attr({ // use attr because animate will cause any other animation on the graph to stop
<                         'stroke-width': lineWidth
<                     }, state ? 0 : 500);
<                 }
<             }
<         },
---
> 			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
> 				graph.attr({ // use attr because animate will cause any other animation on the graph to stop
> 					'stroke-width': lineWidth
> 				}, state ? 0 : 500);
> 			}
> 		}
> 	},
9939c9786
<         /**
---
> 	/**
9945,10007c9792,9826
<         setVisible: function(vis, redraw) {
<             var series = this,
<             chart = series.chart,
<             legendItem = series.legendItem,
<             seriesGroup = series.group,
<             seriesTracker = series.tracker,
<             dataLabelsGroup = series.dataLabelsGroup,
<             showOrHide,
<             i,
<             data = series.data,
<             point,
<             ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
<             oldVisibility = series.visible;
< 		
<             // if called without an argument, toggle visibility
<             series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
<             showOrHide = vis ? 'show' : 'hide';
< 		
<             // show or hide series
<             if (seriesGroup) { // pies don't have one
<                 seriesGroup[showOrHide]();
<             }
< 		
<             // show or hide trackers
<             if (seriesTracker) {
<                 seriesTracker[showOrHide]();
<             } else {
<                 i = data.length;
<                 while (i--) {
<                     point = data[i];
<                     if (point.tracker) {
<                         point.tracker[showOrHide]();
<                     }
<                 }
<             }
< 		
< 		
<             if (dataLabelsGroup) {
<                 dataLabelsGroup[showOrHide]();
<             }
< 		
<             if (legendItem) {
<                 chart.legend.colorizeItem(series, vis);
<             }
< 			
< 		
<             // rescale or adapt to resized chart
<             series.isDirty = true;
<             // in a stack, all other series are affected
<             if (series.options.stacking) {
<                 each(chart.series, function(otherSeries) {
<                     if (otherSeries.options.stacking && otherSeries.visible) {
<                         otherSeries.isDirty = true;
<                     }
<                 });
<             }
< 		
<             if (ignoreHiddenSeries) {
<                 chart.isDirtyBox = true;
<             }
<             if (redraw !== false) {
<                 chart.redraw();
<             }
---
> 	setVisible: function(vis, redraw) {
> 		var series = this,
> 			chart = series.chart,
> 			legendItem = series.legendItem,
> 			seriesGroup = series.group,
> 			seriesTracker = series.tracker,
> 			dataLabelsGroup = series.dataLabelsGroup,
> 			showOrHide,
> 			i,
> 			data = series.data,
> 			point,
> 			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
> 			oldVisibility = series.visible;
> 		
> 		// if called without an argument, toggle visibility
> 		series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
> 		showOrHide = vis ? 'show' : 'hide';
> 		
> 		// show or hide series
> 		if (seriesGroup) { // pies don't have one
> 			seriesGroup[showOrHide]();
> 		}
> 		
> 		// show or hide trackers
> 		if (seriesTracker) {
> 			seriesTracker[showOrHide]();
> 		} else {
> 			i = data.length;
> 			while (i--) {
> 				point = data[i];
> 				if (point.tracker) {
> 					point.tracker[showOrHide]();
> 				}
> 			}
> 		}
10009,10010c9828,9857
<             fireEvent(series, showOrHide);
<         },
---
> 		
> 		if (dataLabelsGroup) {
> 			dataLabelsGroup[showOrHide]();
> 		}
> 		
> 		if (legendItem) {
> 			chart.legend.colorizeItem(series, vis);
> 		}
> 			
> 		
> 		// rescale or adapt to resized chart
> 		series.isDirty = true;
> 		// in a stack, all other series are affected
> 		if (series.options.stacking) {
> 			each(chart.series, function(otherSeries) {
> 				if (otherSeries.options.stacking && otherSeries.visible) { 
> 					otherSeries.isDirty = true;
> 				}
> 			});
> 		}
> 		
> 		if (ignoreHiddenSeries) {
> 			chart.isDirtyBox = true;
> 		}
> 		if (redraw !== false) {
> 			chart.redraw();
> 		}
> 		
> 		fireEvent(series, showOrHide);
> 	},
10012c9859
<         /**
---
> 	/**
10015,10017c9862,9864
<         show: function() {
<             this.setVisible(true);
<         },
---
> 	show: function() {
> 		this.setVisible(true);
> 	},
10019c9866
<         /**
---
> 	/**
10022,10024c9869,9871
<         hide: function() {
<             this.setVisible(false);
<         },
---
> 	hide: function() {
> 		this.setVisible(false);
> 	},
10027c9874
<         /**
---
> 	/**
10033,10036c9880,9883
<         select: function(selected) {
<             var series = this;
<             // if called without an argument, toggle
<             series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;
---
> 	select: function(selected) {
> 		var series = this;
> 		// if called without an argument, toggle
> 		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;
10038,10040c9885,9887
<             if (series.checkbox) {
<                 series.checkbox.checked = selected;
<             }
---
> 		if (series.checkbox) {
> 			series.checkbox.checked = selected;
> 		}
10042,10043c9889,9890
<             fireEvent(series, selected ? 'select' : 'unselect');
<         },
---
> 		fireEvent(series, selected ? 'select' : 'unselect');
> 	},
10046c9893
<         /**
---
> 	/**
10052,10117c9899,9960
<         drawTracker: function() {
<             var series = this,
<             options = series.options,
<             trackerPath = [].concat(series.graphPath),
<             trackerPathLength = trackerPath.length,
<             chart = series.chart,
<             snap = chart.options.tooltip.snap,
<             tracker = series.tracker,
<             cursor = options.cursor,
<             css = cursor && {
<                 cursor: cursor
<             },
<             singlePoints = series.singlePoints,
<             singlePoint,
<             i;
< 	
<             // Extend end points. A better way would be to use round linecaps,
<             // but those are not clickable in VML.
<             if (trackerPathLength) {
<                 i = trackerPathLength + 1;
<                 while (i--) {
<                     if (trackerPath[i] === M) { // extend left side
<                         trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
<                     }
<                     if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
<                         trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
<                     }
<                 }
<             }
< 		
<             // handle single points
<             for (i = 0; i < singlePoints.length; i++) {
<                 singlePoint = singlePoints[i];
<                 trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
<                     L, singlePoint.plotX + snap, singlePoint.plotY);
<             }
< 		
<             // draw the tracker
<             if (tracker) {
<                 tracker.attr({
<                     d: trackerPath
<                 });
< 			
<             } else { // create
<                 series.tracker = chart.renderer.path(trackerPath)
<                 .attr({
<                     isTracker: true,
<                     stroke: TRACKER_FILL,
<                     fill: NONE,
<                     'stroke-width' : options.lineWidth + 2 * snap,
<                     visibility: series.visible ? VISIBLE : HIDDEN,
<                     zIndex: 1
<                 })
<                 .on(hasTouch ? 'touchstart' : 'mouseover', function() {
<                     if (chart.hoverSeries !== series) {
<                         series.onMouseOver();
<                     }
<                 })
<                 .on('mouseout', function() {
<                     if (!options.stickyTracking) {
<                         series.onMouseOut();
<                     }
<                 })
<                 .css(css)
<                 .add(chart.trackerGroup);
<             }
---
> 	drawTracker: function() {
> 		var series = this,
> 			options = series.options,
> 			trackerPath = [].concat(series.graphPath),
> 			trackerPathLength = trackerPath.length,
> 			chart = series.chart,
> 			snap = chart.options.tooltip.snap,
> 			tracker = series.tracker,
> 			cursor = options.cursor,
> 			css = cursor && { cursor: cursor },
> 			singlePoints = series.singlePoints,
> 			singlePoint,
> 			i;
> 	
> 		// Extend end points. A better way would be to use round linecaps,
> 		// but those are not clickable in VML.
> 		if (trackerPathLength) {
> 			i = trackerPathLength + 1;
> 			while (i--) {
> 				if (trackerPath[i] === M) { // extend left side
> 					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
> 				}
> 				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
> 					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
> 				}
> 			}
> 		}
> 		
> 		// handle single points
> 		for (i = 0; i < singlePoints.length; i++) {
> 			singlePoint = singlePoints[i];
> 			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
> 				L, singlePoint.plotX + snap, singlePoint.plotY);
> 		}
> 		
> 		// draw the tracker
> 		if (tracker) {
> 			tracker.attr({ d: trackerPath });
> 			
> 		} else { // create
> 			series.tracker = chart.renderer.path(trackerPath)
> 				.attr({
> 					isTracker: true,
> 					stroke: TRACKER_FILL,
> 					fill: NONE,
> 					'stroke-width' : options.lineWidth + 2 * snap,
> 					visibility: series.visible ? VISIBLE : HIDDEN,
> 					zIndex: 1
> 				})
> 				.on(hasTouch ? 'touchstart' : 'mouseover', function() {
> 					if (chart.hoverSeries !== series) {
> 						series.onMouseOver();
> 					}
> 				})
> 				.on('mouseout', function() {
> 					if (!options.stickyTracking) {
> 						series.onMouseOut();
> 					}
> 				})
> 				.css(css)
> 				.add(chart.trackerGroup);
> 		}
10119c9962
<         }
---
> 	}
10121c9964
<     }; // end Series prototype
---
> }; // end Series prototype
10124c9967
<     /**
---
> /**
10127,10128c9970,9971
<     var LineSeries = extendClass(Series);
<     seriesTypes.line = LineSeries;
---
> var LineSeries = extendClass(Series);
> seriesTypes.line = LineSeries;
10130c9973
<     /**
---
> /**
10133,10136c9976,9979
<     var AreaSeries = extendClass(Series, {
<         type: 'area'
<     });
<     seriesTypes.area = AreaSeries;
---
> var AreaSeries = extendClass(Series, {
> 	type: 'area'
> });
> seriesTypes.area = AreaSeries;
10141c9984
<     /**
---
> /**
10144,10145c9987,9988
<     var SplineSeries = extendClass( Series, {
<         type: 'spline',
---
> var SplineSeries = extendClass( Series, {
> 	type: 'spline',
10147c9990
<         /**
---
> 	/**
10150,10181c9993,10045
<         getPointSpline: function(segment, point, i) {
<             var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
<             denom = smoothing + 1,
<             plotX = point.plotX,
<             plotY = point.plotY,
<             lastPoint = segment[i - 1],
<             nextPoint = segment[i + 1],
<             leftContX,
<             leftContY,
<             rightContX,
<             rightContY,
<             ret;
< 			
<             // find control points
<             if (i && i < segment.length - 1) {
<                 var lastX = lastPoint.plotX,
<                 lastY = lastPoint.plotY,
<                 nextX = nextPoint.plotX,
<                 nextY = nextPoint.plotY,
<                 correction;
< 			
<                 leftContX = (smoothing * plotX + lastX) / denom;
<                 leftContY = (smoothing * plotY + lastY) / denom;
<                 rightContX = (smoothing * plotX + nextX) / denom;
<                 rightContY = (smoothing * plotY + nextY) / denom;
< 		
<                 // have the two control points make a straight line through main point
<                 correction = ((rightContY - leftContY) * (rightContX - plotX)) /
<                 (rightContX - leftContX) + plotY - rightContY;
< 				
<                 leftContY += correction;
<                 rightContY += correction;
---
> 	getPointSpline: function(segment, point, i) {
> 		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
> 			denom = smoothing + 1,
> 			plotX = point.plotX,
> 			plotY = point.plotY,
> 			lastPoint = segment[i - 1],
> 			nextPoint = segment[i + 1],
> 			leftContX,
> 			leftContY,
> 			rightContX,
> 			rightContY,
> 			ret;
> 			
> 		// find control points
> 		if (i && i < segment.length - 1) {
> 			var lastX = lastPoint.plotX,
> 				lastY = lastPoint.plotY,
> 				nextX = nextPoint.plotX,
> 				nextY = nextPoint.plotY,
> 				correction;
> 			
> 			leftContX = (smoothing * plotX + lastX) / denom;
> 			leftContY = (smoothing * plotY + lastY) / denom;
> 			rightContX = (smoothing * plotX + nextX) / denom;
> 			rightContY = (smoothing * plotY + nextY) / denom;
> 		
> 			// have the two control points make a straight line through main point
> 			correction = ((rightContY - leftContY) * (rightContX - plotX)) / 
> 				(rightContX - leftContX) + plotY - rightContY;
> 				
> 			leftContY += correction;
> 			rightContY += correction;
> 			
> 			// to prevent false extremes, check that control points are between
> 			// neighbouring points' y values
> 			if (leftContY > lastY && leftContY > plotY) {
> 				leftContY = mathMax(lastY, plotY);
> 				rightContY = 2 * plotY - leftContY; // mirror of left control point
> 			} else if (leftContY < lastY && leftContY < plotY) {
> 				leftContY = mathMin(lastY, plotY);
> 				rightContY = 2 * plotY - leftContY;
> 			} 
> 			if (rightContY > nextY && rightContY > plotY) {
> 				rightContY = mathMax(nextY, plotY);
> 				leftContY = 2 * plotY - rightContY;
> 			} else if (rightContY < nextY && rightContY < plotY) {
> 				rightContY = mathMin(nextY, plotY);
> 				leftContY = 2 * plotY - rightContY;
> 			}
> 			
> 			// record for drawing in next point
> 			point.rightContX = rightContX;
> 			point.rightContY = rightContY;
10183,10227c10047,10070
<                 // to prevent false extremes, check that control points are between
<                 // neighbouring points' y values
<                 if (leftContY > lastY && leftContY > plotY) {
<                     leftContY = mathMax(lastY, plotY);
<                     rightContY = 2 * plotY - leftContY; // mirror of left control point
<                 } else if (leftContY < lastY && leftContY < plotY) {
<                     leftContY = mathMin(lastY, plotY);
<                     rightContY = 2 * plotY - leftContY;
<                 }
<                 if (rightContY > nextY && rightContY > plotY) {
<                     rightContY = mathMax(nextY, plotY);
<                     leftContY = 2 * plotY - rightContY;
<                 } else if (rightContY < nextY && rightContY < plotY) {
<                     rightContY = mathMin(nextY, plotY);
<                     leftContY = 2 * plotY - rightContY;
<                 }
< 			
<                 // record for drawing in next point
<                 point.rightContX = rightContX;
<                 point.rightContY = rightContY;
< 			
<             }
< 		
<             // moveTo or lineTo
<             if (!i) {
<                 ret = [M, plotX, plotY];
<             }
< 		
<             // curve from last point to this
<             else {
<                 ret = [
<                 'C',
<                 lastPoint.rightContX || lastPoint.plotX,
<                 lastPoint.rightContY || lastPoint.plotY,
<                 leftContX || plotX,
<                 leftContY || plotY,
<                 plotX,
<                 plotY
<                 ];
<                 lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
<             }
<             return ret;
<         }
<     });
<     seriesTypes.spline = SplineSeries;
---
> 		}
> 		
> 		// moveTo or lineTo
> 		if (!i) {
> 			ret = [M, plotX, plotY];
> 		}
> 		
> 		// curve from last point to this
> 		else {
> 			ret = [
> 				'C',
> 				lastPoint.rightContX || lastPoint.plotX, 
> 				lastPoint.rightContY || lastPoint.plotY,
> 				leftContX || plotX, 
> 				leftContY || plotY,
> 				plotX, 
> 				plotY
> 			];
> 			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
> 		}
> 		return ret;
> 	}
> });
> seriesTypes.spline = SplineSeries;
10231c10074
<     /**
---
> /**
10234,10562c10077,10403
<     var AreaSplineSeries = extendClass(SplineSeries, {
<         type: 'areaspline'
<     });
<     seriesTypes.areaspline = AreaSplineSeries;
< 
<     /**
<  * ColumnSeries object
<  */
<     var ColumnSeries = extendClass(Series, {
<         type: 'column',
<         pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
<             stroke: 'borderColor',
<             'stroke-width': 'borderWidth',
<             fill: 'color',
<             r: 'borderRadius'
<         },
<         init: function() {
<             Series.prototype.init.apply(this, arguments);
< 		
<             var series = this,
<             chart = series.chart;
< 		
<             // flag the chart in order to pad the x axis
<             chart.hasColumn = true;
< 		
<             // if the series is added dynamically, force redraw of other
<             // series affected by a new column
<             if (chart.hasRendered) {
<                 each(chart.series, function(otherSeries) {
<                     if (otherSeries.type === series.type) {
<                         otherSeries.isDirty = true;
<                     }
<                 });
<             }
<         },
< 	
<         /**
< 	 * Translate each point to the plot area coordinate system and find shape positions
< 	 */
<         translate: function() {
<             var series = this,
<             chart = series.chart,
<             options = series.options,
<             stacking = options.stacking,
<             borderWidth = options.borderWidth,
<             columnCount = 0,
<             reversedXAxis = series.xAxis.reversed,
<             categories = series.xAxis.categories,
<             stackGroups = {},
<             stackKey,
<             columnIndex;
< 		
<             Series.prototype.translate.apply(series);
< 		
<             // Get the total number of column type series.
<             // This is called on every series. Consider moving this logic to a
<             // chart.orderStacks() function and call it on init, addSeries and removeSeries
<             each(chart.series, function(otherSeries) {
<                 if (otherSeries.type === series.type && otherSeries.visible) {
<                     if (otherSeries.options.stacking) {
<                         stackKey = otherSeries.stackKey;
<                         if (stackGroups[stackKey] === UNDEFINED) {
<                             stackGroups[stackKey] = columnCount++;
<                         }
<                         columnIndex = stackGroups[stackKey];
<                     } else {
<                         columnIndex = columnCount++;
<                     }
<                     otherSeries.columnIndex = columnIndex;
<                 }
<             });
< 		
<             // calculate the width and position of each column based on
<             // the number of column series in the plot, the groupPadding
<             // and the pointPadding options
<             var data = series.data,
<             closestPoints = series.closestPoints,
<             categoryWidth = mathAbs(
<                 data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX :
<                 chart.plotSizeX / ((categories && categories.length) || 1)
<                 ),
<             groupPadding = categoryWidth * options.groupPadding,
<             groupWidth = categoryWidth - 2 * groupPadding,
<             pointOffsetWidth = groupWidth / columnCount,
<             optionPointWidth = options.pointWidth,
<             pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
<             pointOffsetWidth * options.pointPadding,
<             pointWidth = mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1),
<             colIndex = (reversedXAxis ? columnCount -
<                 series.columnIndex : series.columnIndex) || 0,
<             pointXOffset = pointPadding + (groupPadding + colIndex *
<                 pointOffsetWidth -(categoryWidth / 2)) *
<             (reversedXAxis ? -1 : 1),
<             threshold = options.threshold || 0,
<             translatedThreshold = series.yAxis.getThreshold(threshold),
<             minPointLength = pick(options.minPointLength, 5);
< 		
<             // record the new values
<             each(data, function(point) {
<                 var plotY = point.plotY,
<                 yBottom = point.yBottom || translatedThreshold,
<                 barX = point.plotX + pointXOffset,
<                 barY = mathCeil(mathMin(plotY, yBottom)),
<                 barH = mathCeil(mathMax(plotY, yBottom) - barY),
<                 stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
<                 trackerY,
<                 shapeArgs;
< 			
<                 // Record the offset'ed position and width of the bar to be able to align the stacking total correctly
<                 if (stacking && series.visible && stack && stack[point.x]) {
<                     stack[point.x].setOffset(pointXOffset, pointWidth);
<                 }
< 			
<                 // handle options.minPointLength and tracker for small points
<                 if (mathAbs(barH) < minPointLength) {
<                     if (minPointLength) {
<                         barH = minPointLength;
<                         barY =
<                         mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
<                         yBottom - minPointLength : // keep position
<                         translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
<                     }
<                     trackerY = barY - 3;
<                 }
< 			
<                 extend(point, {
<                     barX: barX,
<                     barY: barY,
<                     barW: pointWidth,
<                     barH: barH
<                 });
< 			
<                 // create shape type and shape args that are reused in drawPoints and drawTracker
<                 point.shapeType = 'rect';
<                 shapeArgs = extend(chart.renderer.Element.prototype.crisp.apply({}, [
<                     borderWidth,
<                     barX,
<                     barY,
<                     pointWidth,
<                     barH
<                     ]), {
<                     r: options.borderRadius
<                 });
<                 if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
<                     shapeArgs.y -= 1;
<                     shapeArgs.height += 1;
<                 }
<                 point.shapeArgs = shapeArgs;
< 			
<                 // make small columns responsive to mouse
<                 point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
<                     height: mathMax(6, barH + 3),
<                     y: trackerY
<                 });
<             });
< 		
<         },
< 	
<         getSymbol: function(){
<         },
< 	
<         /**
< 	 * Columns have no graph
< 	 */
<         drawGraph: function() {},
< 	
<         /**
< 	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
< 	 * apply for columns and bars. This method is inherited by scatter series.
< 	 * 
< 	 */
<         drawPoints: function() {
<             var series = this,
<             options = series.options,
<             renderer = series.chart.renderer,
<             graphic,
<             shapeArgs;
< 		
< 		
<             // draw the columns
<             each(series.data, function(point) {
<                 var plotY = point.plotY;
<                 if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
<                     graphic = point.graphic;
<                     shapeArgs = point.shapeArgs;
<                     if (graphic) { // update
<                         stop(graphic);
<                         graphic.animate(shapeArgs);
< 				
<                     } else {
<                         point.graphic = renderer[point.shapeType](shapeArgs)
<                         .attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
<                         .add(series.group)
<                         .shadow(options.shadow);
<                     }
< 			
<                 }
<             });
<         },
<         /**
< 	 * Draw the individual tracker elements.
< 	 * This method is inherited by scatter and pie charts too.
< 	 */
<         drawTracker: function() {
<             var series = this,
<             chart = series.chart,
<             renderer = chart.renderer,
<             shapeArgs,
<             tracker,
<             trackerLabel = +new Date(),
<             cursor = series.options.cursor,
<             css = cursor && {
<                 cursor: cursor
<             },
<             rel;
< 			
<             each(series.data, function(point) {
<                 tracker = point.tracker;
<                 shapeArgs = point.trackerArgs || point.shapeArgs;
<                 delete shapeArgs.strokeWidth;
<                 if (point.y !== null) {
<                     if (tracker) {// update
<                         tracker.attr(shapeArgs);
< 					
<                     } else {
<                         point.tracker =
<                         renderer[point.shapeType](shapeArgs)
<                         .attr({
<                             isTracker: trackerLabel,
<                             fill: TRACKER_FILL,
<                             visibility: series.visible ? VISIBLE : HIDDEN,
<                             zIndex: 1
<                         })
<                         .on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
<                             rel = event.relatedTarget || event.fromElement;
<                             if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
<                                 series.onMouseOver();
<                             }
<                             point.onMouseOver();
< 							
<                         })
<                         .on('mouseout', function(event) {
<                             if (!series.options.stickyTracking) {
<                                 rel = event.relatedTarget || event.toElement;
<                                 if (attr(rel, 'isTracker') !== trackerLabel) {
<                                     series.onMouseOut();
<                                 }
<                             }
<                         })
<                         .css(css)
<                         .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
<                     }
<                 }
<             });
<         },
< 	
< 	
<         /**
< 	 * Animate the column heights one by one from zero
< 	 * @param {Boolean} init Whether to initialize the animation or run it 
< 	 */
<         animate: function(init) {
<             var series = this,
<             data = series.data;
< 			
<             if (!init) { // run the animation
<                 /*
< 			 * Note: Ideally the animation should be initialized by calling
< 			 * series.group.hide(), and then calling series.group.show()
< 			 * after the animation was started. But this rendered the shadows
< 			 * invisible in IE8 standards mode. If the columns flicker on large
< 			 * datasets, this is the cause.
< 			 */
< 			
<                 each(data, function(point) {
<                     var graphic = point.graphic,
<                     shapeArgs = point.shapeArgs;
< 				
<                     if (graphic) {
<                         // start values
<                         graphic.attr({
<                             height: 0,
<                             y: series.yAxis.translate(0, 0, 1)
<                         });
< 					
<                         // animate
<                         graphic.animate({
<                             height: shapeArgs.height,
<                             y: shapeArgs.y
<                         }, series.options.animation);
<                     }
<                 });
< 			
< 			
<                 // delete this function to allow it only once
<                 series.animate = null;
<             }
< 		
<         },
<         /**
< 	 * Remove this series from the chart
< 	 */
<         remove: function() {
<             var series = this,
<             chart = series.chart;
< 			
<             // column and bar series affects other series of the same type
<             // as they are either stacked or grouped
<             if (chart.hasRendered) {
<                 each(chart.series, function(otherSeries) {
<                     if (otherSeries.type === series.type) {
<                         otherSeries.isDirty = true;
<                     }
<                 });
<             }
< 		
<             Series.prototype.remove.apply(series, arguments);
<         }
<     });
<     seriesTypes.column = ColumnSeries;
< 
<     var BarSeries = extendClass(ColumnSeries, {
<         type: 'bar',
<         init: function(chart) {
<             chart.inverted = this.inverted = true;
<             ColumnSeries.prototype.init.apply(this, arguments);
<         }
<     });
<     seriesTypes.bar = BarSeries;
---
> var AreaSplineSeries = extendClass(SplineSeries, {
> 	type: 'areaspline'
> });
> seriesTypes.areaspline = AreaSplineSeries;
> 
> /**
>  * ColumnSeries object
>  */
> var ColumnSeries = extendClass(Series, {
> 	type: 'column',
> 	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
> 		stroke: 'borderColor',
> 		'stroke-width': 'borderWidth',
> 		fill: 'color',
> 		r: 'borderRadius'
> 	},
> 	init: function() {
> 		Series.prototype.init.apply(this, arguments);
> 		
> 		var series = this,
> 			chart = series.chart;
> 		
> 		// flag the chart in order to pad the x axis
> 		chart.hasColumn = true;
> 		
> 		// if the series is added dynamically, force redraw of other
> 		// series affected by a new column
> 		if (chart.hasRendered) {
> 			each(chart.series, function(otherSeries) {
> 				if (otherSeries.type === series.type) {
> 					otherSeries.isDirty = true;
> 				}
> 			});
> 		}
> 	},
> 	
> 	/**
> 	 * Translate each point to the plot area coordinate system and find shape positions
> 	 */
> 	translate: function() {
> 		var series = this,
> 			chart = series.chart,
> 			options = series.options,
> 			stacking = options.stacking,
> 			borderWidth = options.borderWidth,
> 			columnCount = 0,
> 			reversedXAxis = series.xAxis.reversed,
> 			categories = series.xAxis.categories,
> 			stackGroups = {},
> 			stackKey,
> 			columnIndex;
> 		
> 		Series.prototype.translate.apply(series);
> 		
> 		// Get the total number of column type series.
> 		// This is called on every series. Consider moving this logic to a 
> 		// chart.orderStacks() function and call it on init, addSeries and removeSeries
> 		each(chart.series, function(otherSeries) {
> 			if (otherSeries.type === series.type && otherSeries.visible) {
> 				if (otherSeries.options.stacking) {
> 					stackKey = otherSeries.stackKey;
> 					if (stackGroups[stackKey] === UNDEFINED) {
> 						stackGroups[stackKey] = columnCount++;	
> 					}					
> 					columnIndex = stackGroups[stackKey];
> 				} else {
> 					columnIndex = columnCount++;
> 				}
> 				otherSeries.columnIndex = columnIndex;
> 			}
> 		});
> 		
> 		// calculate the width and position of each column based on 
> 		// the number of column series in the plot, the groupPadding
> 		// and the pointPadding options
> 		var data = series.data,
> 			closestPoints = series.closestPoints,
> 			categoryWidth = mathAbs(
> 				data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX : 
> 				chart.plotSizeX / ((categories && categories.length) || 1)
> 			),
> 			groupPadding = categoryWidth * options.groupPadding,
> 			groupWidth = categoryWidth - 2 * groupPadding,
> 			pointOffsetWidth = groupWidth / columnCount,
> 			optionPointWidth = options.pointWidth,
> 			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 : 
> 				pointOffsetWidth * options.pointPadding,
> 			pointWidth = mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1),
> 			colIndex = (reversedXAxis ? columnCount - 
> 				series.columnIndex : series.columnIndex) || 0,
> 			pointXOffset = pointPadding + (groupPadding + colIndex *
> 				pointOffsetWidth -(categoryWidth / 2)) *
> 				(reversedXAxis ? -1 : 1),
> 			threshold = options.threshold || 0,
> 			translatedThreshold = series.yAxis.getThreshold(threshold),
> 			minPointLength = pick(options.minPointLength, 5);
> 		
> 		// record the new values
> 		each(data, function(point) {
> 			var plotY = point.plotY,
> 				yBottom = point.yBottom || translatedThreshold,
> 				barX = point.plotX + pointXOffset,
> 				barY = mathCeil(mathMin(plotY, yBottom)), 
> 				barH = mathCeil(mathMax(plotY, yBottom) - barY),
> 				stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
> 				trackerY,
> 				shapeArgs;
> 			
> 			// Record the offset'ed position and width of the bar to be able to align the stacking total correctly
> 			if (stacking && series.visible && stack && stack[point.x]) {
> 				stack[point.x].setOffset(pointXOffset, pointWidth);
> 			}
> 			
> 			// handle options.minPointLength and tracker for small points
> 			if (mathAbs(barH) < minPointLength) { 
> 				if (minPointLength) {
> 					barH = minPointLength;
> 					barY = 
> 						mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
> 							yBottom - minPointLength : // keep position
> 							translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
> 				}
> 				trackerY = barY - 3;
> 			}
> 			
> 			extend(point, {
> 				barX: barX,
> 				barY: barY, 
> 				barW: pointWidth,
> 				barH: barH
> 			});
> 			
> 			// create shape type and shape args that are reused in drawPoints and drawTracker
> 			point.shapeType = 'rect';
> 			shapeArgs = extend(chart.renderer.Element.prototype.crisp.apply({}, [
> 				borderWidth,
> 				barX,
> 				barY,
> 				pointWidth,
> 				barH
> 			]), {
> 				r: options.borderRadius
> 			});
> 			if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
> 				shapeArgs.y -= 1;
> 				shapeArgs.height += 1;
> 			}
> 			point.shapeArgs = shapeArgs;
> 			
> 			// make small columns responsive to mouse
> 			point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
> 				height: mathMax(6, barH + 3),
> 				y: trackerY
> 			});
> 		});
> 		
> 	},
> 	
> 	getSymbol: function(){
> 	},
> 	
> 	/** 
> 	 * Columns have no graph
> 	 */
> 	drawGraph: function() {},
> 	
> 	/**
> 	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
> 	 * apply for columns and bars. This method is inherited by scatter series.
> 	 * 
> 	 */
> 	drawPoints: function() {
> 		var series = this,
> 			options = series.options,
> 			renderer = series.chart.renderer,
> 			graphic,
> 			shapeArgs;		
> 		
> 		
> 		// draw the columns
> 		each(series.data, function(point) {			
> 			var plotY = point.plotY;
> 			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
> 				graphic = point.graphic;
> 				shapeArgs = point.shapeArgs;
> 				if (graphic) { // update
> 					stop(graphic);
> 					graphic.animate(shapeArgs);
> 				
> 				} else {
> 					point.graphic = renderer[point.shapeType](shapeArgs)
> 						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
> 						.add(series.group)
> 						.shadow(options.shadow);
> 				}
> 			
> 			}
> 		});
> 	},
> 	/**
> 	 * Draw the individual tracker elements.
> 	 * This method is inherited by scatter and pie charts too.
> 	 */
> 	drawTracker: function() {
> 		var series = this,
> 			chart = series.chart,
> 			renderer = chart.renderer,
> 			shapeArgs,
> 			tracker,
> 			trackerLabel = +new Date(),
> 			cursor = series.options.cursor,
> 			css = cursor && { cursor: cursor },
> 			rel;
> 			
> 		each(series.data, function(point) {
> 			tracker = point.tracker;
> 			shapeArgs = point.trackerArgs || point.shapeArgs;
> 			delete shapeArgs.strokeWidth;
> 			if (point.y !== null) {
> 				if (tracker) {// update
> 					tracker.attr(shapeArgs);
> 					
> 				} else {
> 					point.tracker = 
> 						renderer[point.shapeType](shapeArgs)
> 						.attr({
> 							isTracker: trackerLabel,
> 							fill: TRACKER_FILL,
> 							visibility: series.visible ? VISIBLE : HIDDEN,
> 							zIndex: 1
> 						})
> 						.on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
> 							rel = event.relatedTarget || event.fromElement;
> 							if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
> 								series.onMouseOver();
> 							}
> 							point.onMouseOver();
> 							
> 						})
> 						.on('mouseout', function(event) {
> 							if (!series.options.stickyTracking) {
> 								rel = event.relatedTarget || event.toElement;
> 								if (attr(rel, 'isTracker') !== trackerLabel) {
> 									series.onMouseOut();
> 								}
> 							}
> 						})
> 						.css(css)
> 						.add(point.group || chart.trackerGroup); // pies have point group - see issue #118
> 				}
> 			}
> 		});
> 	},
> 	
> 	
> 	/**
> 	 * Animate the column heights one by one from zero
> 	 * @param {Boolean} init Whether to initialize the animation or run it 
> 	 */
> 	animate: function(init) {
> 		var series = this,
> 			data = series.data;
> 			
> 		if (!init) { // run the animation
> 			/*
> 			 * Note: Ideally the animation should be initialized by calling
> 			 * series.group.hide(), and then calling series.group.show()
> 			 * after the animation was started. But this rendered the shadows
> 			 * invisible in IE8 standards mode. If the columns flicker on large
> 			 * datasets, this is the cause.
> 			 */
> 			
> 			each(data, function(point) {
> 				var graphic = point.graphic,
> 					shapeArgs = point.shapeArgs;
> 				
> 				if (graphic) {
> 					// start values
> 					graphic.attr({ 
> 						height: 0,
> 						y: series.yAxis.translate(0, 0, 1)
> 					});
> 					
> 					// animate
> 					graphic.animate({ 
> 						height: shapeArgs.height,
> 						y: shapeArgs.y
> 					}, series.options.animation);
> 				}
> 			});
> 			
> 			
> 			// delete this function to allow it only once
> 			series.animate = null;
> 		}
> 		
> 	},
> 	/**
> 	 * Remove this series from the chart
> 	 */
> 	remove: function() {
> 		var series = this,
> 			chart = series.chart;
> 			
> 		// column and bar series affects other series of the same type
> 		// as they are either stacked or grouped
> 		if (chart.hasRendered) {
> 			each(chart.series, function(otherSeries) {
> 				if (otherSeries.type === series.type) {
> 					otherSeries.isDirty = true;
> 				}
> 			});
> 		}
> 		
> 		Series.prototype.remove.apply(series, arguments);
> 	}
> });
> seriesTypes.column = ColumnSeries;
> 
> var BarSeries = extendClass(ColumnSeries, {
> 	type: 'bar',
> 	init: function(chart) {
> 		chart.inverted = this.inverted = true;
> 		ColumnSeries.prototype.init.apply(this, arguments);
> 	}
> });
> seriesTypes.bar = BarSeries;
10564c10405
<     /**
---
> /**
10567,10568c10408,10409
<     var ScatterSeries = extendClass(Series, {
<         type: 'scatter',
---
> var ScatterSeries = extendClass(Series, {
> 	type: 'scatter',
10570c10411
<         /**
---
> 	/**
10574,10575c10415,10416
<         translate: function() {
<             var series = this;
---
> 	translate: function() {
> 		var series = this;
10577c10418
<             Series.prototype.translate.apply(series);
---
> 		Series.prototype.translate.apply(series);
10579,10587c10420,10428
<             each(series.data, function(point) {
<                 point.shapeType = 'circle';
<                 point.shapeArgs = {
<                     x: point.plotX,
<                     y: point.plotY,
<                     r: series.chart.options.tooltip.snap
<                 };
<             });
<         },
---
> 		each(series.data, function(point) {
> 			point.shapeType = 'circle';
> 			point.shapeArgs = {
> 				x: point.plotX,
> 				y: point.plotY,
> 				r: series.chart.options.tooltip.snap
> 			};
> 		});
> 	},
10590c10431
<         /**
---
> 	/**
10593,10620c10434,10457
<         //drawTracker: ColumnSeries.prototype.drawTracker,
<         drawTracker: function() {
<             var series = this,
<             cursor = series.options.cursor,
<             css = cursor && {
<                 cursor: cursor
<             },
<             graphic;
< 			
<             each(series.data, function(point) {
<                 graphic = point.graphic;
<                 if (graphic) { // doesn't exist for null points
<                     graphic
<                     .attr({
<                         isTracker: true
<                     })
<                     .on('mouseover', function(event) {
<                         series.onMouseOver();
<                         point.onMouseOver();
<                     })
<                     .on('mouseout', function(event) {
<                         if (!series.options.stickyTracking) {
<                             series.onMouseOut();
<                         }
<                     })
<                     .css(css);
<                 }
<             });
---
> 	//drawTracker: ColumnSeries.prototype.drawTracker,
> 	drawTracker: function() {
> 		var series = this,
> 			cursor = series.options.cursor,
> 			css = cursor && { cursor: cursor },
> 			graphic;
> 			
> 		each(series.data, function(point) {
> 			graphic = point.graphic;
> 			if (graphic) { // doesn't exist for null points
> 				graphic
> 					.attr({ isTracker: true })
> 					.on('mouseover', function(event) {
> 						series.onMouseOver();
> 						point.onMouseOver();					
> 					})
> 					.on('mouseout', function(event) {
> 						if (!series.options.stickyTracking) {
> 							series.onMouseOut();
> 						}
> 					})
> 					.css(css);
> 			}
> 		});
10622c10459
<         },
---
> 	},
10624c10461
<         /**
---
> 	/**
10627,10629c10464,10466
<         cleanData: function() {}
<     });
<     seriesTypes.scatter = ScatterSeries;
---
> 	cleanData: function() {}
> });
> seriesTypes.scatter = ScatterSeries;
10631c10468
<     /**
---
> /**
10634,10635c10471,10472
<     var PiePoint = extendClass(Point, {
<         /**
---
> var PiePoint = extendClass(Point, {
> 	/**
10638c10475
<         init: function () {
---
> 	init: function () {
10640c10477
<             Point.prototype.init.apply(this, arguments);
---
> 		Point.prototype.init.apply(this, arguments);
10642,10643c10479,10480
<             var point = this,
<             toggleSlice;
---
> 		var point = this,
> 			toggleSlice;
10645,10656c10482,10493
<             //visible: options.visible !== false,
<             extend(point, {
<                 visible: point.visible !== false,
<                 name: pick(point.name, 'Slice')
<             });
< 		
<             // add event listener for select
<             toggleSlice = function() {
<                 point.slice();
<             };
<             addEvent(point, 'select', toggleSlice);
<             addEvent(point, 'unselect', toggleSlice);
---
> 		//visible: options.visible !== false,
> 		extend(point, {
> 			visible: point.visible !== false,
> 			name: pick(point.name, 'Slice')
> 		});
> 		
> 		// add event listener for select
> 		toggleSlice = function() {
> 			point.slice();
> 		};
> 		addEvent(point, 'select', toggleSlice);
> 		addEvent(point, 'unselect', toggleSlice);
10658,10659c10495,10496
<             return point;
<         },
---
> 		return point;
> 	},
10661c10498
<         /**
---
> 	/**
10666,10692c10503,10529
<         setVisible: function(vis) {
<             var point = this,
<             chart = point.series.chart,
<             tracker = point.tracker,
<             dataLabel = point.dataLabel,
<             connector = point.connector,
<             method;
< 		
<             // if called without an argument, toggle visibility
<             point.visible = vis = vis === UNDEFINED ? !point.visible : vis;
< 		
<             method = vis ? 'show' : 'hide';
< 		
<             point.group[method]();
<             if (tracker) {
<                 tracker[method]();
<             }
<             if (dataLabel) {
<                 dataLabel[method]();
<             }
<             if (connector) {
<                 connector[method]();
<             }
<             if (point.legendItem) {
<                 chart.legend.colorizeItem(point, vis);
<             }
<         },
---
> 	setVisible: function(vis) {	
> 		var point = this, 
> 			chart = point.series.chart,
> 			tracker = point.tracker,
> 			dataLabel = point.dataLabel,
> 			connector = point.connector,
> 			method;
> 		
> 		// if called without an argument, toggle visibility
> 		point.visible = vis = vis === UNDEFINED ? !point.visible : vis;
> 		
> 		method = vis ? 'show' : 'hide';
> 		
> 		point.group[method]();
> 		if (tracker) {
> 			tracker[method]();
> 		}
> 		if (dataLabel) {
> 			dataLabel[method]();
> 		}
> 		if (connector) {
> 			connector[method]();
> 		}
> 		if (point.legendItem) {
> 			chart.legend.colorizeItem(point, vis);
> 		}
> 	},
10694c10531
<         /**
---
> 	/**
10699,10721c10536,10558
<         slice: function(sliced, redraw, animation) {
<             var point = this,
<             series = point.series,
<             chart = series.chart,
<             slicedTranslation = point.slicedTranslation,
<             translation;
< 			
<             setAnimation(animation, chart);
< 		
<             // redraw is true by default
<             redraw = pick(redraw, true);
< 			
<             // if called without an argument, toggle
<             sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;
< 		
<             translation = {
<                 translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
<                 translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
<             };
<             point.group.animate(translation);
<             if (point.shadowGroup) {
<                 point.shadowGroup.animate(translation);
<             }
---
> 	slice: function(sliced, redraw, animation) {
> 		var point = this,
> 			series = point.series,
> 			chart = series.chart,
> 			slicedTranslation = point.slicedTranslation,
> 			translation;
> 			
> 		setAnimation(animation, chart);
> 		
> 		// redraw is true by default
> 		redraw = pick(redraw, true);
> 			
> 		// if called without an argument, toggle
> 		sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;
> 		
> 		translation = {
> 			translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
> 			translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
> 		};
> 		point.group.animate(translation);
> 		if (point.shadowGroup) {
> 			point.shadowGroup.animate(translation);
> 		}
10723,10724c10560,10561
<         }
<     });
---
> 	}
> });
10726c10563
<     /**
---
> /**
10729,10737c10566,10574
<     var PieSeries = extendClass(Series, {
<         type: 'pie',
<         isCartesian: false,
<         pointClass: PiePoint,
<         pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
<             stroke: 'borderColor',
<             'stroke-width': 'borderWidth',
<             fill: 'color'
<         },
---
> var PieSeries = extendClass(Series, {
> 	type: 'pie',
> 	isCartesian: false,
> 	pointClass: PiePoint,
> 	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
> 		stroke: 'borderColor',
> 		'stroke-width': 'borderWidth',
> 		fill: 'color'
> 	},
10739c10576
<         /**
---
> 	/**
10742,10745c10579,10582
<         getColor: function() {
<             // record first color for use in setData
<             this.initialColor = colorCounter;
<         },
---
> 	getColor: function() {
> 		// record first color for use in setData
> 		this.initialColor = colorCounter;
> 	},
10747c10584
<         /**
---
> 	/**
10751,10766c10588,10603
<         animate: function(init) {
<             var series = this,
<             data = series.data;
< 			
<             each(data, function(point) {
<                 var graphic = point.graphic,
<                 args = point.shapeArgs,
<                 up = -mathPI / 2;
< 			
<                 if (graphic) {
<                     // start values
<                     graphic.attr({
<                         r: 0,
<                         start: up,
<                         end: up
<                     });
---
> 	animate: function(init) {
> 		var series = this,
> 			data = series.data;
> 			
> 		each(data, function(point) {
> 			var graphic = point.graphic,
> 				args = point.shapeArgs,
> 				up = -mathPI / 2;
> 			
> 			if (graphic) {
> 				// start values
> 				graphic.attr({ 
> 					r: 0,
> 					start: up,
> 					end: up
> 				});
10768,10775c10605,10612
<                     // animate
<                     graphic.animate({
<                         r: args.r,
<                         start: args.start,
<                         end: args.end
<                     }, series.options.animation);
<                 }
<             });
---
> 				// animate
> 				graphic.animate({ 
> 					r: args.r,
> 					start: args.start,
> 					end: args.end
> 				}, series.options.animation);
> 			}
> 		});
10777,10778c10614,10615
<             // delete this function to allow it only once
<             series.animate = null;
---
> 		// delete this function to allow it only once
> 		series.animate = null;
10780,10781c10617,10618
<         },
<         /**
---
> 	},
> 	/**
10784,10890c10621,10727
<         translate: function() {
<             var total = 0,
<             series = this,
<             cumulative = -0.25, // start at top
<             precision = 1000, // issue #172
<             options = series.options,
<             slicedOffset = options.slicedOffset,
<             connectorOffset = slicedOffset + options.borderWidth,
<             positions = options.center.concat([options.size, options.innerSize || 0]),
<             chart = series.chart,
<             plotWidth = chart.plotWidth,
<             plotHeight = chart.plotHeight,
<             start,
<             end,
<             angle,
<             data = series.data,
<             circ = 2 * mathPI,
<             fraction,
<             smallestSize = mathMin(plotWidth, plotHeight),
<             isPercent,
<             radiusX, // the x component of the radius vector for a given point
<             radiusY,
<             labelDistance = options.dataLabels.distance;
< 			
<             // get positions - either an integer or a percentage string must be given
<             positions = map(positions, function(length, i) {
< 			
<                 isPercent = /%$/.test(length);
<                 return isPercent ?
<                 // i == 0: centerX, relative to width
<                 // i == 1: centerY, relative to height
<                 // i == 2: size, relative to smallestSize
<                 // i == 4: innerSize, relative to smallestSize
<                 [plotWidth, plotHeight, smallestSize, smallestSize][i] *
<                 pInt(length) / 100:
<                 length;
<             });
< 		
<             // utility for getting the x value from a given y, used for anticollision logic in data labels
<             series.getX = function(y, left) {
< 			
<                 angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));
< 			
<                 return positions[0] +
<                 (left ? -1 : 1) *
<                 (mathCos(angle) * (positions[2] / 2 + labelDistance));
<             };
< 		
<             // set center for later use
<             series.center = positions;
< 					
<             // get the total sum
<             each(data, function(point) {
<                 total += point.y;
<             });
< 		
<             each(data, function(point) {
<                 // set start and end angle
<                 fraction = total ? point.y / total : 0;
<                 start = mathRound(cumulative * circ * precision) / precision;
<                 cumulative += fraction;
<                 end = mathRound(cumulative * circ * precision) / precision;
< 			
<                 // set the shape
<                 point.shapeType = 'arc';
<                 point.shapeArgs = {
<                     x: positions[0],
<                     y: positions[1],
<                     r: positions[2] / 2,
<                     innerR: positions[3] / 2,
<                     start: start,
<                     end: end
<                 };
< 			
<                 // center for the sliced out slice
<                 angle = (end + start) / 2;
<                 point.slicedTranslation = map([
<                     mathCos(angle) * slicedOffset + chart.plotLeft,
<                     mathSin(angle) * slicedOffset + chart.plotTop
<                     ], mathRound);
< 			
<                 // set the anchor point for tooltips
<                 radiusX = mathCos(angle) * positions[2] / 2;
<                 radiusY = mathSin(angle) * positions[2] / 2;
<                 point.tooltipPos = [
<                 positions[0] + radiusX * 0.7,
<                 positions[1] + radiusY * 0.7
<                 ];
< 			
<                 // set the anchor point for data labels
<                 point.labelPos = [
<                 positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
<                 positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
<                 positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
<                 positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
<                 positions[0] + radiusX, // landing point for connector
<                 positions[1] + radiusY, // a/a
<                 labelDistance < 0 ? // alignment
<                 'center' :
<                 angle < circ / 4 ? 'left' : 'right', // alignment
<                 angle // center angle
<                 ];
< 			
< 			
<                 // API properties
<                 point.percentage = fraction * 100;
<                 point.total = total;
---
> 	translate: function() {
> 		var total = 0,
> 			series = this,
> 			cumulative = -0.25, // start at top
> 			precision = 1000, // issue #172
> 			options = series.options,
> 			slicedOffset = options.slicedOffset,
> 			connectorOffset = slicedOffset + options.borderWidth,
> 			positions = options.center.concat([options.size, options.innerSize || 0]),
> 			chart = series.chart,
> 			plotWidth = chart.plotWidth,
> 			plotHeight = chart.plotHeight,
> 			start,
> 			end,
> 			angle,
> 			data = series.data,
> 			circ = 2 * mathPI,
> 			fraction,
> 			smallestSize = mathMin(plotWidth, plotHeight),
> 			isPercent,
> 			radiusX, // the x component of the radius vector for a given point
> 			radiusY,
> 			labelDistance = options.dataLabels.distance;
> 			
> 		// get positions - either an integer or a percentage string must be given
> 		positions = map(positions, function(length, i) {
> 			
> 			isPercent = /%$/.test(length);			
> 			return isPercent ? 
> 				// i == 0: centerX, relative to width
> 				// i == 1: centerY, relative to height
> 				// i == 2: size, relative to smallestSize
> 				// i == 4: innerSize, relative to smallestSize
> 				[plotWidth, plotHeight, smallestSize, smallestSize][i] *
> 					pInt(length) / 100:
> 				length;
> 		});
> 		
> 		// utility for getting the x value from a given y, used for anticollision logic in data labels
> 		series.getX = function(y, left) {
> 			
> 			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));
> 			
> 			return positions[0] + 
> 				(left ? -1 : 1) *
> 				(mathCos(angle) * (positions[2] / 2 + labelDistance));
> 		};
> 		
> 		// set center for later use
> 		series.center = positions;
> 					
> 		// get the total sum
> 		each(data, function(point) {
> 			total += point.y;
> 		});
> 		
> 		each(data, function(point) {
> 			// set start and end angle
> 			fraction = total ? point.y / total : 0;
> 			start = mathRound(cumulative * circ * precision) / precision;
> 			cumulative += fraction;
> 			end = mathRound(cumulative * circ * precision) / precision;
> 			
> 			// set the shape
> 			point.shapeType = 'arc';
> 			point.shapeArgs = {
> 				x: positions[0],
> 				y: positions[1],
> 				r: positions[2] / 2,
> 				innerR: positions[3] / 2,
> 				start: start,
> 				end: end
> 			};
> 			
> 			// center for the sliced out slice
> 			angle = (end + start) / 2;
> 			point.slicedTranslation = map([
> 				mathCos(angle) * slicedOffset + chart.plotLeft, 
> 				mathSin(angle) * slicedOffset + chart.plotTop
> 			], mathRound);
> 			
> 			// set the anchor point for tooltips
> 			radiusX = mathCos(angle) * positions[2] / 2;
> 			radiusY = mathSin(angle) * positions[2] / 2;
> 			point.tooltipPos = [
> 				positions[0] + radiusX * 0.7,
> 				positions[1] + radiusY * 0.7
> 			];
> 			
> 			// set the anchor point for data labels			
> 			point.labelPos = [
> 				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
> 				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
> 				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
> 				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
> 				positions[0] + radiusX, // landing point for connector
> 				positions[1] + radiusY, // a/a
> 				labelDistance < 0 ? // alignment
> 					'center' :
> 					angle < circ / 4 ? 'left' : 'right', // alignment
> 				angle // center angle
> 			];
> 			
> 			
> 			// API properties
> 			point.percentage = fraction * 100;
> 			point.total = total;
10892c10729
<             });
---
> 		});
10894,10895c10731,10732
<             this.setTooltipPoints();
<         },
---
> 		this.setTooltipPoints();
> 	},
10897c10734
<         /**
---
> 	/**
10900,10901c10737,10738
<         render: function() {
<             var series = this;
---
> 	render: function() {
> 		var series = this;
10903,10904c10740,10741
<             // cache attributes for shapes
<             //series.getAttribs();
---
> 		// cache attributes for shapes
> 		//series.getAttribs();
10906c10743
<             this.drawPoints();
---
> 		this.drawPoints();
10908,10911c10745,10748
<             // draw the mouse tracking area
<             if (series.options.enableMouseTracking !== false) {
<                 series.drawTracker();
<             }
---
> 		// draw the mouse tracking area
> 		if (series.options.enableMouseTracking !== false) {
> 			series.drawTracker();
> 		}
10913c10750
<             this.drawDataLabels();
---
> 		this.drawDataLabels();
10915,10917c10752,10754
<             if (series.options.animation && series.animate) {
<                 series.animate();
<             }
---
> 		if (series.options.animation && series.animate) {
> 			series.animate();
> 		}
10919,10920c10756,10757
<             series.isDirty = false; // means data is in accordance with what you see
<         },
---
> 		series.isDirty = false; // means data is in accordance with what you see
> 	},
10922c10759
<         /**
---
> 	/**
10925,10968c10762,10801
<         drawPoints: function() {
<             var series = this,
<             chart = series.chart,
<             renderer = chart.renderer,
<             groupTranslation,
<             //center,
<             graphic,
<             group,
<             shadow = series.options.shadow,
<             shadowGroup,
<             shapeArgs;
< 			
< 		
<             // draw the slices
<             each(series.data, function(point) {
<                 graphic = point.graphic;
<                 shapeArgs = point.shapeArgs;
<                 group = point.group;
<                 shadowGroup = point.shadowGroup;
< 
<                 // put the shadow behind all points
<                 if (shadow && !shadowGroup) {
<                     shadowGroup = point.shadowGroup = renderer.g('shadow')
<                     .attr({
<                         zIndex: 4
<                     })
<                     .add();
<                 }
< 		
<                 // create the group the first time
<                 if (!group) {
<                     group = point.group = renderer.g('point')
<                     .attr({
<                         zIndex: 5
<                     })
<                     .add();
<                 }
< 			
<                 // if the point is sliced, use special translation, else use plot area traslation
<                 groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
<                 group.translate(groupTranslation[0], groupTranslation[1]);
<                 if (shadowGroup) {
<                     shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
<                 }
---
> 	drawPoints: function() {
> 		var series = this,
> 			chart = series.chart,
> 			renderer = chart.renderer,
> 			groupTranslation,
> 			//center,
> 			graphic,
> 			group,
> 			shadow = series.options.shadow,
> 			shadowGroup,
> 			shapeArgs;
> 			
> 		
> 		// draw the slices
> 		each(series.data, function(point) {
> 			graphic = point.graphic;
> 			shapeArgs = point.shapeArgs;
> 			group = point.group;
> 			shadowGroup = point.shadowGroup;
> 
> 			// put the shadow behind all points
> 			if (shadow && !shadowGroup) {
> 				shadowGroup = point.shadowGroup = renderer.g('shadow')
> 					.attr({ zIndex: 4 })
> 					.add();
> 			}
> 		
> 			// create the group the first time
> 			if (!group) {
> 				group = point.group = renderer.g('point')
> 					.attr({ zIndex: 5 })
> 					.add();
> 			}
> 			
> 			// if the point is sliced, use special translation, else use plot area traslation
> 			groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
> 			group.translate(groupTranslation[0], groupTranslation[1]);
> 			if (shadowGroup) {
> 				shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
> 			}
10971,10990c10804,10821
<                 // draw the slice
<                 if (graphic) {
<                     graphic.animate(shapeArgs);
<                 } else {
<                     point.graphic =
<                     renderer.arc(shapeArgs)
<                     .attr(extend(
<                         point.pointAttr[NORMAL_STATE],
<                         {
<                             'stroke-linejoin': 'round'
<                         }
<                         ))
<                     .add(point.group)
<                     .shadow(shadow, shadowGroup);
<                 }
< 			
<                 // detect point specific visibility
<                 if (point.visible === false) {
<                     point.setVisible(false);
<                 }
---
> 			// draw the slice
> 			if (graphic) {
> 				graphic.animate(shapeArgs);
> 			} else {
> 				point.graphic = 
> 					renderer.arc(shapeArgs)
> 					.attr(extend(
> 						point.pointAttr[NORMAL_STATE],
> 						{ 'stroke-linejoin': 'round' }
> 					))
> 					.add(point.group)
> 					.shadow(shadow, shadowGroup);
> 			}
> 			
> 			// detect point specific visibility
> 			if (point.visible === false) {
> 				point.setVisible(false);
> 			}
10992c10823
<             });
---
> 		});
10994c10825
<         },
---
> 	},
10996c10827
<         /**
---
> 	/**
10999,11058c10830,10889
<         drawDataLabels: function() {
<             var series = this,
<             data = series.data,
<             point,
<             chart = series.chart,
<             options = series.options.dataLabels,
<             connectorPadding = pick(options.connectorPadding, 10),
<             connectorWidth = pick(options.connectorWidth, 1),
<             connector,
<             connectorPath,
<             outside = options.distance > 0,
<             dataLabel,
<             labelPos,
<             labelHeight,
<             lastY,
<             centerY = series.center[1],
<             quarters = [// divide the points into quarters for anti collision
<             [], // top right
<             [], // bottom right
<             [], // bottom left
<             [] // top left
<             ],
<             x,
<             y,
<             visibility,
<             overlapping,
<             rankArr,
<             secondPass,
<             sign,
<             lowerHalf,
<             sort,
<             i = 4,
<             j;
< 			
<             // run parent method
<             Series.prototype.drawDataLabels.apply(series);
< 		
<             // arrange points for detection collision
<             each(data, function(point) {
<                 var angle = point.labelPos[7],
<                 quarter;
<                 if (angle < 0) {
<                     quarter = 0;
<                 } else if (angle < mathPI / 2) {
<                     quarter = 1;
<                 } else if (angle < mathPI) {
<                     quarter = 2;
<                 } else {
<                     quarter = 3;
<                 }
<                 quarters[quarter].push(point);
<             });
<             quarters[1].reverse();
<             quarters[3].reverse();
< 		
<             // define the sorting algorithm
<             sort = function(a,b) {
<                 return a.y > b.y;
<             };
<             /* Loop over the points in each quartile, starting from the top and bottom
---
> 	drawDataLabels: function() {
> 		var series = this,
> 			data = series.data,
> 			point,
> 			chart = series.chart,
> 			options = series.options.dataLabels,
> 			connectorPadding = pick(options.connectorPadding, 10),
> 			connectorWidth = pick(options.connectorWidth, 1),
> 			connector,
> 			connectorPath,
> 			outside = options.distance > 0,
> 			dataLabel,
> 			labelPos,
> 			labelHeight,
> 			lastY,
> 			centerY = series.center[1],
> 			quarters = [// divide the points into quarters for anti collision
> 				[], // top right
> 				[], // bottom right
> 				[], // bottom left
> 				[] // top left
> 			], 
> 			x,
> 			y,
> 			visibility,
> 			overlapping,
> 			rankArr,
> 			secondPass,
> 			sign,
> 			lowerHalf,
> 			sort,
> 			i = 4,
> 			j;
> 			
> 		// run parent method
> 		Series.prototype.drawDataLabels.apply(series);
> 		
> 		// arrange points for detection collision
> 		each(data, function(point) {
> 			var angle = point.labelPos[7],
> 				quarter;
> 			if (angle < 0) {
> 				quarter = 0;
> 			} else if (angle < mathPI / 2) {
> 				quarter = 1;
> 			} else if (angle < mathPI) {
> 				quarter = 2;
> 			} else {
> 				quarter = 3;
> 			}
> 			quarters[quarter].push(point);
> 		});
> 		quarters[1].reverse();
> 		quarters[3].reverse();
> 		
> 		// define the sorting algorithm
> 		sort = function(a,b) {
> 			return a.y > b.y;
> 		};
> 		/* Loop over the points in each quartile, starting from the top and bottom
11061,11062c10892,10893
<             while (i--) {
<                 overlapping = 0;
---
> 		while (i--) {
> 			overlapping = 0;
11064,11070c10895,10901
<                 // create an array for sorting and ranking the points within each quarter
<                 rankArr = [].concat(quarters[i]);
<                 rankArr.sort(sort);
<                 j = rankArr.length;
<                 while (j--) {
<                     rankArr[j].rank = j;
<                 }
---
> 			// create an array for sorting and ranking the points within each quarter
> 			rankArr = [].concat(quarters[i]);
> 			rankArr.sort(sort);
> 			j = rankArr.length;
> 			while (j--) {
> 				rankArr[j].rank = j;
> 			}
11072c10903
<                 /* In the first pass, count the number of overlapping labels. In the second
---
> 			/* In the first pass, count the number of overlapping labels. In the second
11075,11088c10906,10919
<                 for (secondPass = 0; secondPass < 2; secondPass++) {
<                     lowerHalf = i % 3;
<                     lastY = lowerHalf ? 9999 : -9999;
<                     sign = lowerHalf ? -1 : 1;
< 				
<                     for (j = 0; j < quarters[i].length; j++) {
<                         point = quarters[i][j];
< 					
<                         dataLabel = point.dataLabel;
<                         if (dataLabel) {
<                             labelPos = point.labelPos;
<                             visibility = VISIBLE;
<                             x = labelPos[0];
<                             y = labelPos[1];
---
> 			for (secondPass = 0; secondPass < 2; secondPass++) {
> 				lowerHalf = i % 3;
> 				lastY = lowerHalf ? 9999 : -9999;
> 				sign = lowerHalf ? -1 : 1;
> 				
> 				for (j = 0; j < quarters[i].length; j++) {
> 					point = quarters[i][j];
> 					
> 					dataLabel = point.dataLabel;
> 					if (dataLabel) {
> 						labelPos = point.labelPos;
> 						visibility = VISIBLE;
> 						x = labelPos[0];
> 						y = labelPos[1];
11091,11094c10922,10925
<                             // assume all labels have equal height
<                             if (!labelHeight) {
<                                 labelHeight = dataLabel && dataLabel.getBBox().height;
<                             }
---
> 						// assume all labels have equal height
> 						if (!labelHeight) {
> 							labelHeight = dataLabel && dataLabel.getBBox().height;
> 						}
11096,11113c10927,10944
<                             // anticollision
<                             if (outside) {
<                                 if (secondPass && point.rank < overlapping) {
<                                     visibility = HIDDEN;
<                                 } else if ((!lowerHalf && y < lastY + labelHeight) ||
<                                     (lowerHalf && y > lastY - labelHeight)) {
<                                     y = lastY + sign * labelHeight;
<                                     x = series.getX(y, i > 1);
<                                     if ((!lowerHalf && y + labelHeight > centerY) ||
<                                         (lowerHalf && y -labelHeight < centerY)) {
<                                         if (secondPass) {
<                                             visibility = HIDDEN;
<                                         } else {
<                                             overlapping++;
<                                         }
<                                     }
<                                 }
<                             }
---
> 						// anticollision
> 						if (outside) {
> 							if (secondPass && point.rank < overlapping) {
> 								visibility = HIDDEN;
> 							} else if ((!lowerHalf && y < lastY + labelHeight) ||
> 									(lowerHalf && y > lastY - labelHeight)) {  
> 								y = lastY + sign * labelHeight;
> 								x = series.getX(y, i > 1);
> 								if ((!lowerHalf && y + labelHeight > centerY) ||
> 										(lowerHalf && y -labelHeight < centerY)) {
> 									if (secondPass) {
> 										visibility = HIDDEN;
> 									} else {									
> 										overlapping++;
> 									}
> 								}
> 							}
> 						}
11115,11117c10946,10948
<                             if (point.visible === false) {
<                                 visibility = HIDDEN;
<                             }
---
> 						if (point.visible === false) {
> 							visibility = HIDDEN;
> 						}
11119,11121c10950,10952
<                             if (visibility === VISIBLE) {
<                                 lastY = y;
<                             }
---
> 						if (visibility === VISIBLE) {
> 							lastY = y;
> 						}
11123c10954
<                             if (secondPass) {
---
> 						if (secondPass) {
11125,11139c10956,10966
<                                 // move or place the data label
<                                 dataLabel
<                                 .attr({
<                                     visibility: visibility,
<                                     align: labelPos[6]
<                                 })[dataLabel.moved ? 'animate' : 'attr']({
<                                     x: x + options.x +
<                                     ({
<                                         left: connectorPadding,
<                                         right: -connectorPadding
<                                     }
<                                     [labelPos[6]] || 0),
<                                     y: y + options.y
<                                 });
<                                 dataLabel.moved = true;
---
> 							// move or place the data label
> 							dataLabel
> 								.attr({
> 									visibility: visibility,
> 									align: labelPos[6]
> 								})[dataLabel.moved ? 'animate' : 'attr']({
> 									x: x + options.x + 
> 										({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
> 									y: y + options.y
> 								});
> 							dataLabel.moved = true;
11141,11143c10968,10970
<                                 // draw the connector
<                                 if (outside && connectorWidth) {
<                                     connector = point.connector;
---
> 							// draw the connector
> 							if (outside && connectorWidth) {
> 								connector = point.connector;
11145,11154c10972,10981
<                                     connectorPath = [
<                                     M,
<                                     x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
<                                     L,
<                                     x, y, // first break, next to the label
<                                     L,
<                                     labelPos[2], labelPos[3], // second break
<                                     L,
<                                     labelPos[4], labelPos[5] // base
<                                     ];
---
> 								connectorPath = [
> 									M,
> 									x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
> 									L,
> 									x, y, // first break, next to the label
> 									L,
> 									labelPos[2], labelPos[3], // second break
> 									L,
> 									labelPos[4], labelPos[5] // base
> 								];
11156,11160c10983,10985
<                                     if (connector) {
<                                         connector.animate({
<                                             d: connectorPath
<                                         });
<                                         connector.attr('visibility', visibility);
---
> 								if (connector) {
> 									connector.animate({ d: connectorPath });
> 									connector.attr('visibility', visibility);
11162,11178c10987,11003
<                                     } else {
<                                         point.connector = connector = series.chart.renderer.path(connectorPath).attr({
<                                             'stroke-width': connectorWidth,
<                                             stroke: options.connectorColor || '#606060',
<                                             visibility: visibility,
<                                             zIndex: 3
<                                         })
<                                         .translate(chart.plotLeft, chart.plotTop)
<                                         .add();
<                                     }
<                                 }
<                             }
<                         }
<                     }
<                 }
<             }
<         },
---
> 								} else {		
> 									point.connector = connector = series.chart.renderer.path(connectorPath).attr({
> 										'stroke-width': connectorWidth,
> 										stroke: options.connectorColor || '#606060',
> 										visibility: visibility,
> 										zIndex: 3
> 									})
> 									.translate(chart.plotLeft, chart.plotTop)
> 									.add();
> 								}
> 							}
> 						}
> 					}
> 				}
> 			}
> 		}
> 	},
11180c11005
<         /**
---
> 	/**
11183c11008
<         drawTracker: ColumnSeries.prototype.drawTracker,
---
> 	drawTracker: ColumnSeries.prototype.drawTracker,
11185c11010
<         /**
---
> 	/**
11188c11013
<         getSymbol: function() {}
---
> 	getSymbol: function() {}
11190,11191c11015,11016
<     });
<     seriesTypes.pie = PieSeries;
---
> });
> seriesTypes.pie = PieSeries;
11194,11220c11019,11045
<     // global variables
<     win.Highcharts = {
<         Chart: Chart,
<         dateFormat: dateFormat,
<         pathAnim: pathAnim,
<         getOptions: getOptions,
<         numberFormat: numberFormat,
<         Point: Point,
<         Color: Color,
<         Renderer: Renderer,
<         seriesTypes: seriesTypes,
<         setOptions: setOptions,
<         Series: Series,
< 		
<         // Expose utility funcitons for modules
<         addEvent: addEvent,
<         createElement: createElement,
<         discardElement: discardElement,
<         css: css,
<         each: each,
<         extend: extend,
<         map: map,
<         merge: merge,
<         pick: pick,
<         extendClass: extendClass,
<         version: '2.1.5'
<     };
---
> // global variables
> win.Highcharts = {
> 	Chart: Chart,
> 	dateFormat: dateFormat,
> 	pathAnim: pathAnim,
> 	getOptions: getOptions,
> 	numberFormat: numberFormat,
> 	Point: Point,
> 	Color: Color,
> 	Renderer: Renderer,
> 	seriesTypes: seriesTypes,
> 	setOptions: setOptions,
> 	Series: Series,
> 		
> 	// Expose utility funcitons for modules
> 	addEvent: addEvent,
> 	createElement: createElement,
> 	discardElement: discardElement,
> 	css: css,
> 	each: each,
> 	extend: extend,
> 	map: map,
> 	merge: merge,
> 	pick: pick,
> 	extendClass: extendClass,
> 	version: '2.1.5'
> };
diff -r --exclude=.svn v550/public/javascripts/app/components/charts/DeviceHighChart.js v537/public/javascripts/app/components/charts/DeviceHighChart.js
9,11c9,85
<         var registerGroupsStore = oraApp.getRegisterGroupsHighChart();
<         var registersStore = oraApp.getRegistersForHighChart();
<         var registersValueStore = oraApp.getDataRegistersForHighChart(this.fullRecord.id);
---
>         var registerGroupsStore = oraApp.getRegisterGroups();
>         var registersStore = oraApp.getRegisters();
>         var grapicalDataStore = new Ext.data.JsonStore({
>             fields:[{
>                 name: 'date',
>                 type: 'datetime'
>             }, {
>                 name: 'tp',
>                 type: 'float'
>             }, {
>                 name: 'lp',
>                 type: 'float'
>             }, {
>                 name: 'cp',
>                 type: 'float'
>             }, {
>                 name: 'dp',
>                 type: 'float'
>             }],
>             proxy: new Ext.data.HttpProxy({
>                 url: '/dumy-data-for-display',
>                 method: 'GET'
>             }),
>             autoLoad: true
>         });
> 
>         var numaricDataStore = new Ext.data.JsonStore({
>             fields:[{
>                 name: 'date',
>                 type: 'datetime'
>             }, {
>                 name: 'tp',
>                 type: 'float'
>             }, {
>                 name: 'lp',
>                 type: 'float'
>             }, {
>                 name: 'cp',
>                 type: 'float'
>             }, {
>                 name: 'dp',
>                 type: 'float'
>             }],
>             proxy: new Ext.data.HttpProxy({
>                 url: '/dumy-data-for-display',
>                 method: 'GET'
>             }),
>             autoLoad: true
>         });
> 
>         var dummyDataStore = new Ext.data.JsonStore({
>             fields:[{
>                 name: 'date',
>                 type: 'datetime'
>             }, {
>                 name: 'tp',
>                 type: 'float'
>             }, {
>                 name: 'lp',
>                 type: 'float'
>             }, {
>                 name: 'cp',
>                 type: 'float'
>             }, {
>                 name: 'dp',
>                 type: 'float'
>             }],
>             baseParams: {
>                 limit: 1
>             },
>             proxy: new Ext.data.HttpProxy({
>                 url: '/dumy-data-for-display',
>                 method: 'GET'
>             }),
>             autoLoad: true
>         });
> 
13,14c87,290
<         var items = [];
<         var fullRecord = this.fullRecord;
---
>         //var datastore_task = {
>         //run: function() {
>         //dstore.load();
>         //},
>         //interval: 5000
>         //};        
>         //Ext.TaskMgr.start(datastore_task);
> 
>         //        var firstchart = new Ext.ux.HighChart({
>         //            series: [{
>         //                name: 'tp',
>         //                color: '#89A54E',
>         //                type: 'spline',
>         //                yField: 'tp'
>         //            }, {
>         //                name: 'lp',
>         //                color: '#C35F5C',
>         //                type: 'spline',
>         //                yField: 'lp'
>         //
>         //            }, {
>         //                name: 'cp',
>         //                color: '#4572A6',
>         //                type: 'spline',
>         //                yField: 'cp'
>         //
>         //            }, {
>         //                name: 'dp',
>         //                color: '#9684AC',
>         //                type: 'area',
>         //                yAxis: 1,
>         //                yField: 'dp'
>         //            }],
>         //            layout:'fit',
>         //            store: grapicalDataStore,
>         //            animShift: true,
>         //            xField: 'date',
>         //            id: 'pressuresChart-'+devicetypeIndex,
>         //            loadMask: true,
>         //            chartConfig: {
>         //                chart: {
>         //                    marginBottom: 150,
>         //                    zoomType: 'xy'
>         //                },
>         //                title: {
>         //                    text: 'Pressure - Boies',
>         //                    x: -20
>         //                },
>         //                xAxis: [{
>         //                    labels : {
>         //                        y : 20,
>         //                        rotation: -90,
>         //                        align: 'right'
>         //                    }
>         //                }],
>         //                yAxis: [{
>         //                    labels: {
>         //                        formatter: function(){
>         //                            return this.value;
>         //                        },
>         //                        style: {
>         //                            color: '#89A54E'
>         //                        }
>         //                    },
>         //                    title: {
>         //                        text: 'Pressure (psi)',
>         //                        style: {
>         //                            color: '#89A54E'
>         //                        }
>         //                    },
>         //                    plotLines: [{
>         //                        value: 0,
>         //                        width: 1,
>         //                        color: '#808080'
>         //                    }]
>         //                }, {
>         //                    title: {
>         //                        text: 'DP (InH2O)',
>         //                        style: {
>         //                            color: '#4572A7'
>         //                        }
>         //                    },
>         //                    labels: {
>         //                        formatter: function() {
>         //                            return this.value;
>         //                        },
>         //                        style: {
>         //                            color: '#4572A7'
>         //                        }
>         //                    },
>         //                    opposite: true
>         //                }],
>         //                tooltip: {
>         //                    formatter: function(){
>         //                        if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>         //                            return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>         //                        }
>         //                        else{
>         //                            return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>         //                        }
>         //                    },
>         //                    style: {
>         //                        padding: '15px'
>         //                    }
>         //                },
>         //                legend: {
>         //                    layout: 'vertical',
>         //                    align: 'left',
>         //                    x: 70,
>         //                    verticalAlign: 'top',
>         //                    y: 00,
>         //                    floating: true,
>         //                    backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>         //                }
>         //            }
>         //        });
> 
>         //Create the Download button and add it to the top toolbar
>         //        var exportButton = new Ext.ux.Exporter.Button({
>         //            component: grid,
>         //            text: "Download as .xls"
>         //        });
> 
>         //        var exportButton = new Ext.ux.Exporter.Button({
>         //            component: grid,
>         //            //store: grid.store,
>         //            id: 'exportButton'
>         //        });
> 
>         //        var grid = new Ext.grid.GridPanel({
>         //            autoWidth: true,
>         //            height: 400,
>         //            border: false,
>         //            id: 'pressuresNumaricGrid-'+devicetypeIndex,
>         //            stripeRows: true,
>         //            columnLines: true,
>         //            store: numaricDataStore,
>         //            loadMask: true,
>         //            columns: [{
>         //                header: 'Date',
>         //                width: 150,
>         //                sortable: true,
>         //                dataIndex: 'date'
>         //            }, {
>         //                header: 'TP',
>         //                width: 100,
>         //                sortable: true,
>         //                align: 'right',
>         //                dataIndex: 'tp'
>         //            }, {
>         //                header: 'LP',
>         //                width: 100,
>         //                sortable: true,
>         //                align: 'right',
>         //                dataIndex: 'lp'
>         //            }, {
>         //                header: 'CP',
>         //                width: 100,
>         //                sortable: true,
>         //                align: 'right',
>         //                dataIndex: 'cp'
>         //            }, {
>         //                header: 'DP',
>         //                width: 100,
>         //                sortable: true,
>         //                align: 'right',
>         //                dataIndex: 'dp'
>         //            }]
>         //        });
>         //
>         //        var startDate = new Ext.form.DateField({
>         //            id: 'startdt'+devicetypeIndex,
>         //            name: 'start',
>         //            format: 'Y-m-d',
>         //            editable: false,
>         //            listeners: {
>         //                'select': function(){
>         //                    if(endDate.getValue() != ''){
>         //                        if(this.getValue() > endDate.getValue()){
>         //                            Ext.Msg.alert('Error!', 'Range from must be less than Range to.');
>         //                            this.setValue(endDate.getValue());
>         //                        }
>         //                    }
>         //                    endDate.setMinValue(startDate.getValue());
>         //                }
>         //            }
>         //        });
>         //
>         //        var endDate = new Ext.form.DateField({
>         //            id: 'enddt'+devicetypeIndex,
>         //            name: 'start',
>         //            format: 'Y-m-d',
>         //            editable: false,
>         //            listeners: {
>         //                'select': function(){
>         //                    if(startDate.getValue() != ''){
>         //                        if(this.getValue() < startDate.getValue()){
>         //                            Ext.Msg.alert('Error!', 'Range to must not be less than Range from.');
>         //                            this.setValue(startDate.getValue());
>         //                        }
>         //                    }
>         //                }
>         //            }
>         //        });
19a296,297
>         var items = []; 
>         var fullRecord = this.fullRecord;
37a316,1140
> 
>         registerGroupsStore.clearFilter();
>         if(registerGroupsStore.getCount() > 0){
>             registerGroupsStore.filter([{
>                 property: "device_type_id",
>                 value: this.fullRecord.device_type_id
>             }, {
>                 fn : function(record){
>                     return record.get('display_type') == "Display Table" || record.get('display_type') == "Display Configuration - Table"
>                 },
>                 scope: this
>             }]);
>             if(registerGroupsStore.getCount() > 0){
>                 registerGroupsStore.each(function(record){
>                     var display_name = record.get("display_name");
>                     var name = record.get("name");
>                     var id = record.get("id");
>                     registersStore.clearFilter();
>                     registersStore.filter([{
>                         property: "register_group_id",
>                         value: id
>                     }]);
>                     var column = [];
>                     column.push({
>                         header: 'Date',
>                         width: 150,
>                         sortable: true,
>                         dataIndex: 'date'
>                     });
>                     registersStore.each(function(record){
>                         var name = record.get("name");
>                         var unit = record.get("units");
>                         column.push({
>                             header: name+" ("+unit+")",
>                             dataIndex: name.toLowerCase(),
>                             width: 100,
>                             align: 'right',
>                             sortable: true
>                         });
>                     }, this);
>                     //                    var myData = [["570"]];
>                     //                    var ds = new Ext.data.Store({
>                     //                        proxy: new Ext.data.MemoryProxy(myData),
>                     //                        reader: new Ext.data.ArrayReader({}, [{
>                     //                            name: 'name',
>                     //                            type: 'string'
>                     //                        }]),
>                     //                        autoLoad: true
>                     //                    });
>                     var grid = new Ext.grid.GridPanel({
>                         ds: dummyDataStore,
>                         id: 'registerGridDeviceHighChart_'+devicetypeIndex+"-"+id,
>                         layout: 'fit',
>                         loadMask: true,
>                         collapsible: true,
>                         stripeRows: true,
>                         columnLines: true,
>                         autoHeight: true,
>                         frame: false,
>                         title: display_name || name,
>                         style: {
>                             marginBottom: '10px'
>                         },
>                         columns: column
>                     });
>                     items.push(grid);
>                 }, this);
>             }
>         }
> 
>         registerGroupsStore.clearFilter();
>         if(registerGroupsStore.getCount() > 0){
>             registerGroupsStore.filter([{
>                 property: "device_type_id",
>                 value: this.fullRecord.device_type_id
>             }, {
>                 fn : function(record){
>                     return record.get('display_type') != "Display Table" && record.get('display_type') != "Read" && record.get('display_type') != "Read/Write" && record.get('display_type') != "Write" && record.get('display_type') != "Display Dashboard - Table" && record.get('display_type') != "" && record.get('display_type') != "Display Configuration - Table"
>                 },
>                 scope: this
>             }]);
>             if(registerGroupsStore.getCount() > 0){
>                 registerGroupsStore.each(function(record){
>                     var display_name = record.get("display_name");
>                     var name = record.get("name");
>                     var id = record.get("id");
>                     var display_type = record.get("display_type");
>                     var firstchart;
>                     if(display_type == "Display Graph - Spline"){
>                         firstchart = new Ext.ux.HighChart({
>                             series: [{
>                                 name: 'tp',
>                                 color: '#89A54E',
>                                 type: 'spline',
>                                 yField: 'tp'
>                             }, {
>                                 name: 'lp',
>                                 color: '#C35F5C',
>                                 type: 'spline',
>                                 yField: 'lp'
> 
>                             }, {
>                                 name: 'cp',
>                                 color: '#4572A6',
>                                 type: 'spline',
>                                 yField: 'cp'
> 
>                             }],
>                             layout:'fit',
>                             store: grapicalDataStore,
>                             animShift: true,
>                             xField: 'date',
>                             id: 'pressuresChart-'+devicetypeIndex+"-"+id,
>                             loadMask: true,
>                             chartConfig: {
>                                 chart: {
>                                     marginBottom: 150,
>                                     zoomType: 'xy'
>                                 },
>                                 title: {
>                                     text: 'Pressure - Boies',
>                                     x: -20
>                                 },
>                                 xAxis: [{
>                                     labels : {
>                                         y : 20,
>                                         rotation: -90,
>                                         align: 'right'
>                                     }
>                                 }],
>                                 yAxis: [{
>                                     labels: {
>                                         formatter: function(){
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     title: {
>                                         text: 'Pressure (psi)',
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     plotLines: [{
>                                         value: 0,
>                                         width: 1,
>                                         color: '#808080'
>                                     }]
>                                 }],
>                                 tooltip: {
>                                     formatter: function(){
>                                         if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>                                         }
>                                         else{
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>                                         }
>                                     },
>                                     style: {
>                                         padding: '15px'
>                                     }
>                                 },
>                                 legend: {
>                                     layout: 'vertical',
>                                     align: 'left',
>                                     x: 70,
>                                     verticalAlign: 'top',
>                                     y: 00,
>                                     floating: true,
>                                     backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>                                 }
>                             }
>                         });
>                     }
>                     else if(display_type == "Display Graph - Bar"){
>                         firstchart = new Ext.ux.HighChart({
>                             series: [{
>                                 name: 'tp',
>                                 color: '#89A54E',
>                                 type: 'column',
>                                 yField: 'tp'
>                             }, {
>                                 name: 'lp',
>                                 color: '#C35F5C',
>                                 type: 'column',
>                                 yField: 'lp'
> 
>                             }, {
>                                 name: 'cp',
>                                 color: '#4572A6',
>                                 type: 'column',
>                                 yField: 'cp'
> 
>                             }],
>                             layout:'fit',
>                             store: grapicalDataStore,
>                             animShift: true,
>                             xField: 'date',
>                             id: 'pressuresChart-'+devicetypeIndex+"-"+id,
>                             loadMask: true,
>                             chartConfig: {
>                                 chart: {
>                                     marginBottom: 150,
>                                     zoomType: 'xy'
>                                 },
>                                 title: {
>                                     text: 'Pressure - Boies',
>                                     x: -20
>                                 },
>                                 xAxis: [{
>                                     labels : {
>                                         y : 20,
>                                         rotation: -90,
>                                         align: 'right'
>                                     }
>                                 }],
>                                 yAxis: [{
>                                     labels: {
>                                         formatter: function(){
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     title: {
>                                         text: 'Pressure (psi)',
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     plotLines: [{
>                                         value: 0,
>                                         width: 1,
>                                         color: '#808080'
>                                     }]
>                                 }],
>                                 tooltip: {
>                                     formatter: function(){
>                                         if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>                                         }
>                                         else{
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>                                         }
>                                     },
>                                     style: {
>                                         padding: '15px'
>                                     }
>                                 },
>                                 legend: {
>                                     layout: 'vertical',
>                                     align: 'left',
>                                     x: 70,
>                                     verticalAlign: 'top',
>                                     y: 00,
>                                     floating: true,
>                                     backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>                                 }
>                             }
>                         });
>                     }
>                     else if(display_type == "Display Graph - Area"){
>                         firstchart = new Ext.ux.HighChart({
>                             series: [{
>                                 name: 'tp',
>                                 color: '#89A54E',
>                                 type: 'area',
>                                 yField: 'tp'
>                             }, {
>                                 name: 'lp',
>                                 color: '#C35F5C',
>                                 type: 'area',
>                                 yField: 'lp'
> 
>                             }, {
>                                 name: 'cp',
>                                 color: '#4572A6',
>                                 type: 'area',
>                                 yField: 'cp'
> 
>                             }],
>                             layout:'fit',
>                             store: grapicalDataStore,
>                             animShift: true,
>                             xField: 'date',
>                             id: 'pressuresChart-'+devicetypeIndex+"-"+id,
>                             loadMask: true,
>                             chartConfig: {
>                                 chart: {
>                                     marginBottom: 150,
>                                     zoomType: 'xy'
>                                 },
>                                 title: {
>                                     text: 'Pressure - Boies',
>                                     x: -20
>                                 },
>                                 xAxis: [{
>                                     labels : {
>                                         y : 20,
>                                         rotation: -90,
>                                         align: 'right'
>                                     }
>                                 }],
>                                 yAxis: [{
>                                     labels: {
>                                         formatter: function(){
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     title: {
>                                         text: 'Pressure (psi)',
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     plotLines: [{
>                                         value: 0,
>                                         width: 1,
>                                         color: '#808080'
>                                     }]
>                                 }],
>                                 tooltip: {
>                                     formatter: function(){
>                                         if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>                                         }
>                                         else{
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>                                         }
>                                     },
>                                     style: {
>                                         padding: '15px'
>                                     }
>                                 },
>                                 legend: {
>                                     layout: 'vertical',
>                                     align: 'left',
>                                     x: 70,
>                                     verticalAlign: 'top',
>                                     y: 00,
>                                     floating: true,
>                                     backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>                                 }
>                             }
>                         });
>                     }
>                     else if(display_type == "Display Graph - Spline/Bar"){
>                         firstchart = new Ext.ux.HighChart({
>                             series: [{
>                                 name: 'tp',
>                                 color: '#89A54E',
>                                 type: 'spline',
>                                 yField: 'tp'
>                             }, {
>                                 name: 'lp',
>                                 color: '#C35F5C',
>                                 type: 'spline',
>                                 yField: 'lp'
> 
>                             }, {
>                                 name: 'cp',
>                                 color: '#4572A6',
>                                 type: 'spline',
>                                 yField: 'cp'
> 
>                             }, {
>                                 name: 'dp',
>                                 color: '#9684AC',
>                                 type: 'column',
>                                 yAxis: 1,
>                                 yField: 'dp'
>                             }],
>                             layout:'fit',
>                             store: grapicalDataStore,
>                             animShift: true,
>                             xField: 'date',
>                             id: 'pressuresChart-'+devicetypeIndex+"-"+id,
>                             loadMask: true,
>                             chartConfig: {
>                                 chart: {
>                                     marginBottom: 150,
>                                     zoomType: 'xy'
>                                 },
>                                 title: {
>                                     text: 'Pressure - Boies',
>                                     x: -20
>                                 },
>                                 xAxis: [{
>                                     labels : {
>                                         y : 20,
>                                         rotation: -90,
>                                         align: 'right'
>                                     }
>                                 }],
>                                 yAxis: [{
>                                     labels: {
>                                         formatter: function(){
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     title: {
>                                         text: 'Pressure (psi)',
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     plotLines: [{
>                                         value: 0,
>                                         width: 1,
>                                         color: '#808080'
>                                     }]
>                                 }, {
>                                     title: {
>                                         text: 'DP (InH2O)',
>                                         style: {
>                                             color: '#4572A7'
>                                         }
>                                     },
>                                     labels: {
>                                         formatter: function() {
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#4572A7'
>                                         }
>                                     },
>                                     opposite: true
>                                 }],
>                                 tooltip: {
>                                     formatter: function(){
>                                         if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>                                         }
>                                         else{
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>                                         }
>                                     },
>                                     style: {
>                                         padding: '15px'
>                                     }
>                                 },
>                                 legend: {
>                                     layout: 'vertical',
>                                     align: 'left',
>                                     x: 70,
>                                     verticalAlign: 'top',
>                                     y: 00,
>                                     floating: true,
>                                     backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>                                 }
>                             }
>                         });
>                     }
>                     else if(display_type == "Display Graph - Spline/Area"){
>                         firstchart = new Ext.ux.HighChart({
>                             series: [{
>                                 name: 'tp',
>                                 color: '#89A54E',
>                                 type: 'spline',
>                                 yField: 'tp'
>                             }, {
>                                 name: 'lp',
>                                 color: '#C35F5C',
>                                 type: 'spline',
>                                 yField: 'lp'
> 
>                             }, {
>                                 name: 'cp',
>                                 color: '#4572A6',
>                                 type: 'spline',
>                                 yField: 'cp'
> 
>                             }, {
>                                 name: 'dp',
>                                 color: '#9684AC',
>                                 type: 'area',
>                                 yAxis: 1,
>                                 yField: 'dp'
>                             }],
>                             layout:'fit',
>                             store: grapicalDataStore,
>                             animShift: true,
>                             xField: 'date',
>                             id: 'pressuresChart-'+devicetypeIndex+"-"+id,
>                             loadMask: true,
>                             chartConfig: {
>                                 chart: {
>                                     marginBottom: 150,
>                                     zoomType: 'xy'
>                                 },
>                                 title: {
>                                     text: 'Pressure - Boies',
>                                     x: -20
>                                 },
>                                 xAxis: [{
>                                     labels : {
>                                         y : 20,
>                                         rotation: -90,
>                                         align: 'right'
>                                     }
>                                 }],
>                                 yAxis: [{
>                                     labels: {
>                                         formatter: function(){
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     title: {
>                                         text: 'Pressure (psi)',
>                                         style: {
>                                             color: '#89A54E'
>                                         }
>                                     },
>                                     plotLines: [{
>                                         value: 0,
>                                         width: 1,
>                                         color: '#808080'
>                                     }]
>                                 }, {
>                                     title: {
>                                         text: 'DP (InH2O)',
>                                         style: {
>                                             color: '#4572A7'
>                                         }
>                                     },
>                                     labels: {
>                                         formatter: function() {
>                                             return this.value;
>                                         },
>                                         style: {
>                                             color: '#4572A7'
>                                         }
>                                     },
>                                     opposite: true
>                                 }],
>                                 tooltip: {
>                                     formatter: function(){
>                                         if(this.series.name == 'tp' || this.series.name == 'lp' || this.series.name == 'cp'){
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' psi'
>                                         }
>                                         else{
>                                             return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y +' InH2O';
>                                         }
>                                     },
>                                     style: {
>                                         padding: '15px'
>                                     }
>                                 },
>                                 legend: {
>                                     layout: 'vertical',
>                                     align: 'left',
>                                     x: 70,
>                                     verticalAlign: 'top',
>                                     y: 00,
>                                     floating: true,
>                                     backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
>                                 }
>                             }
>                         });
>                     }
> 
>                     var grid = new Ext.grid.GridPanel({
>                         autoWidth: true,
>                         height: 400,
>                         border: false,
>                         id: 'pressuresNumaricGrid-'+devicetypeIndex+"-"+id,
>                         stripeRows: true,
>                         columnLines: true,
>                         store: numaricDataStore,
>                         loadMask: true,
>                         columns: [{
>                             header: 'Date',
>                             width: 150,
>                             sortable: true,
>                             dataIndex: 'date'
>                         }, {
>                             header: 'TP',
>                             width: 100,
>                             sortable: true,
>                             align: 'right',
>                             dataIndex: 'tp'
>                         }, {
>                             header: 'LP',
>                             width: 100,
>                             sortable: true,
>                             align: 'right',
>                             dataIndex: 'lp'
>                         }, {
>                             header: 'CP',
>                             width: 100,
>                             sortable: true,
>                             align: 'right',
>                             dataIndex: 'cp'
>                         }, {
>                             header: 'DP',
>                             width: 100,
>                             sortable: true,
>                             align: 'right',
>                             dataIndex: 'dp'
>                         }]
>                     });
> 
>                     var startDate = new Ext.form.DateField({
>                         id: 'startdt'+devicetypeIndex+"-"+id,
>                         name: 'start',
>                         format: 'Y-m-d',
>                         editable: false,
>                         listeners: {
>                             'select': function(){
>                                 if(endDate.getValue() != ''){
>                                     if(this.getValue() > endDate.getValue()){
>                                         Ext.Msg.alert('Error!', 'Range from must be less than Range to.');
>                                         this.setValue(endDate.getValue());
>                                     }
>                                 }
>                                 endDate.setMinValue(startDate.getValue());
>                             }
>                         }
>                     });
> 
>                     var endDate = new Ext.form.DateField({
>                         id: 'enddt'+devicetypeIndex+"-"+id,
>                         name: 'start',
>                         format: 'Y-m-d',
>                         editable: false,
>                         listeners: {
>                             'select': function(){
>                                 if(startDate.getValue() != ''){
>                                     if(this.getValue() < startDate.getValue()){
>                                         Ext.Msg.alert('Error!', 'Range to must not be less than Range from.');
>                                         this.setValue(startDate.getValue());
>                                     }
>                                 }
>                             }
>                         }
>                     });
> 
>                     items.push({
>                         title: display_name || name,
>                         style:{
>                             marginBottom:'20px',
>                             marginTop:'20px'
>                         },
>                         tools:[{
>                             id: 'refresh-'+devicetypeIndex+"-"+id,
>                             qtip:'Refresh this data',
>                             handler: function(){
>                                 var tab = Ext.getCmp("pressuresTabPanel-"+devicetypeIndex+"-"+id).getActiveTab();
>                                 if(tab.title == "Graphical Data"){
>                                     var graphStore = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id).store;
>                                     graphStore.load({
>                                         params: {
>                                             "start": '',
>                                             "end": ''
>                                         }
>                                     });
>                                     startDate.setValue();
>                                     endDate.setValue();
>                                 }
>                                 else{
>                                     Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store.reload();
>                                     startDate.setValue();
>                                     endDate.setValue();
>                                 }
>                             }
>                         }],
>                         tbar:[{
>                             xtype: 'label',
>                             text: 'Date range from',
>                             style: 'margin: 0 5px 0 5px;'
>                         }, startDate, {
>                             xtype: 'label',
>                             text: 'to',
>                             style: 'margin: 0 5px 0 5px;'
>                         }, endDate, {
>                             xtype: 'button',
>                             text: 'Search',
>                             id: 'search-'+devicetypeIndex+"-"+id,
>                             iconCls: "search-icon",
>                             style: 'margin: 0 5px 0 5px;',
>                             handler: function(){
>                                 var start = startDate.getValue();
>                                 var end = endDate.getValue();
>                                 if(!start && !end){
>                                     Ext.Msg.alert("Error!", "Date range can't be blank.");
>                                 }
>                                 else{
>                                     var rec;
>                                     var numaricStore = Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store;
>                                     var graphStore = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id).store;
>                                     numaricStore.clearFilter();
>                                     graphStore.clearFilter();
>                                     if(start && end){
>                                         numaricStore.filterBy(function(record, id){
>                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
>                                             return rec.format("Y-m-d") >= start.format("Y-m-d") && rec.format("Y-m-d") <= end.format("Y-m-d");
>                                         });
>                                         graphStore.load({
>                                             params: {
>                                                 "start": start,
>                                                 "end": end
>                                             }
>                                         });
>                                     }
>                                     else if(start && !end){
>                                         numaricStore.filterBy(function(record, id){
>                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
>                                             return rec.format("Y-m-d") >= start.format("Y-m-d");
>                                         });
>                                         graphStore.load({
>                                             params: {
>                                                 "start": start,
>                                                 "end": ''
>                                             }
>                                         });
>                                     }
>                                     else if(!start && end){
>                                         numaricStore.filterBy(function(record, id){
>                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
>                                             return rec.format("Y-m-d") <= end.format("Y-m-d");
>                                         });
>                                         graphStore.load({
>                                             params: {
>                                                 "start": '',
>                                                 "end": end
>                                             }
>                                         });
>                                     }
>                                 }
>                             }
>                         }, {
>                             xtype:'button',
>                             iconCls:'reloadIcon',
>                             text:'Refresh',
>                             id: 'tbar-refresh-'+devicetypeIndex+"-"+id,
>                             handler: function(){
>                                 var tab = Ext.getCmp("pressuresTabPanel-"+devicetypeIndex+"-"+id).getActiveTab();
>                                 if(tab.title == "Graphical Data"){
>                                     var graphStore = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id).store;
>                                     graphStore.load({
>                                         params: {
>                                             "start": '',
>                                             "end": ''
>                                         }
>                                     });
>                                     startDate.setValue();
>                                     endDate.setValue();
>                                 }
>                                 else{
>                                     Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store.reload();
>                                     startDate.setValue();
>                                     endDate.setValue();
>                                 }
>                             }
>                         }, {
>                             xtype: "button",
>                             id: 'grid-excel-button-'+devicetypeIndex+"-"+id,
>                             text: "Export to Excel",
>                             iconCls: "export-icon",
>                             handler: function(){
>                                 document.location='data:application/vnd.ms-excel;base64,' +Base64.encode(grid.getExcelXml());
>                             }
>                         }],
>                         items: new Ext.TabPanel({
>                             activeTab:0,
>                             border: true,
>                             id: "pressuresTabPanel-"+devicetypeIndex+"-"+id,
>                             items:[{
>                                 title: "Graphical Data",
>                                 items: firstchart
>                             },{
>                                 title: "Numerical Data",
>                                 items: grid
>                             }]
>                         })
>                     });
> 
>                 }, this);
>             }
>         }
>         
>         //        registerGroupsStore.clearFilter();
>         //        registerGroupsStore.filter("device_type_id", this.fullRecord.device_type_id);
>         //        items.push({
>         //            title:"Register Groups",
>         //            items:[{
>         //                xtype: 'grid',
>         //                autoWidth: true,
>         //                autoHeight: true,
>         //                border: false,
>         //                id: 'register_groups_'+devicetypeIndex,
>         //                store: registerGroupsStore,
>         //                columns: [{
>         //                    header: 'Name',
>         //                    width: 100,
>         //                    sortable: true,
>         //                    dataIndex: 'name'
>         //                }, {
>         //                    header: 'Description',
>         //                    width: 150,
>         //                    sortable: true,
>         //                    dataIndex: 'description'
>         //                }, {
>         //                    header: 'Display Type',
>         //                    width: 150,
>         //                    sortable: true,
>         //                    dataIndex: 'display_type'
>         //                }],
>         //                stripeRows: true,
>         //                columnLines: true
>         //            }]
>         //        });
> 
44a1148
>                         //fullRecord.id
45a1150
>                         //var rec = new recordType({});
47a1153
>                         //formPanel.activeRecord = rec;
48a1155
>                         //formPanel.form.loadRecord(formPanel.activeRecord);
50a1158
> 
54c1162,1186
<             }, '-', {
---
>             },
>             /*'-', {
>                 text:'Edit Note',
>                 iconCls:'companyEditIcon',
>                 handler:this.handleEditCompaniesButtonClick,
>                 scope:this,
>                 listeners : {
>                     'click': function(grid, rowIndex, e){
>                         var r = this.getSelectionModel().getSelected();
>                         var rI = this.getStore().indexOf(r);
>                         var selectedId = r.id;
>                         var rec = this.getStore().getAt(rI);
>                         //var selectedId = document.getElementById('device_id_in_layout_for_edit').value;
>                         var formWin = oraApp.getEditNotesForm(selectedId);
>                         var formPanel = formWin.items.first();
>                         formPanel.activeRecord = rec;
>                         formPanel.form.loadRecord(formPanel.activeRecord);
>                         formWin.show();
>                         document.getElementById('device_id_in_layout_for_edit').value = selectedId;
>                         
>                     },
>                     scope:this
>                 }
>             },*/
>             '-', {
60a1193
>         
61a1195,1197
>             autoWidth: true,
>             height: 400,
>             border: false,
63,67d1198
<             store: oraApp.getDataNotes(),
<             layout: 'fit',
<             loadMask: true,
<             collapsible: true,
<             //collapsed: true,
70,76c1201,1202
<             autoWidth: true,
<             height: 400,
<             autoHeight: true,
<             frame: false,
<             style: {
<                 marginBottom: '10px'
<             },
---
>             store: oraApp.getDataNotes(),
>             loadMask: true,
84a1211
>                 //width: 750,
88a1216
>                 //width: 750,
124a1253
> 
125a1255
> 
127,140d1256
<         app.components.charts.DeviceHighChart.superclass.initComponent.apply(this, arguments);
<         var pan = this;
<         registerGroupsStore.on("load", function(){
<             this.clearFilter();
<             if(this.getCount() > 0){
<                 this.filter([{
<                     property: "device_type_id",
<                     value: fullRecord.device_type_id
<                 }, {
<                     fn : function(record){
<                         return record.get('display_type') == "Display Table" || record.get('display_type') == "Display Configuration - Table";
<                     },
<                     scope: this
<                 }]);
142,571c1258
<                 if(this.getCount() > 0){
<                     ///////Start new Store for Register Value(Which Register Group display type is 'Display Table')///////////
<                     var registerTableStore = new Ext.data.Store({
<                         recordType: registersValueStore.recordType
<                     });
<                     var records = [];
<                     registersValueStore.on("load", function(){
<                         this.each(function(r){
<                             records.push(r.copy());
<                         });
<                         registerTableStore.add(records);
<                     });
<                     ///////End new Store///////////
<                     this.each(function(record){
<                         var display_name = record.get("display_name");
<                         var name = record.get("name");
<                         var id = record.get("id");
<                         var column = [];
<                         column.push({
<                             header: 'Date',
<                             width: 150,
<                             sortable: true,
<                             dataIndex: 'date'
<                         });
<                         registersStore.on("load", function(){
<                             this.clearFilter();
<                             this.filter([{
<                                 property: "register_group_id",
<                                 value: id
<                             }]);
<                             if(this.getCount() > 0){
<                                 this.each(function(record){
<                                     var name = record.get("tag");
<                                     var id = record.get("rid");
<                                     var unit = record.get("units");
<                                     column.push({
<                                         header: name+" ("+unit+")",
<                                         dataIndex: 'R'+id,
<                                         width: 100,
<                                         align: 'right',
<                                         sortable: true
<                                     });
<                                 }, this);
<                                 
<                                 var grid = new Ext.grid.GridPanel({
<                                     ds: registerTableStore,
<                                     id: 'registerGridDeviceHighChart_'+devicetypeIndex+"-"+id,
<                                     layout: 'fit',
<                                     loadMask: true,
<                                     collapsible: true,
<                                     stripeRows: true,
<                                     columnLines: true,
<                                     autoHeight: true,
<                                     frame: false,
<                                     title: display_name || name,
<                                     style: {
<                                         marginBottom: '10px'
<                                     },
<                                     columns: column
<                                 });
<                                 pan.insert(pan.items.length - 1, grid);
<                                 pan.doLayout();
<                             }
<                         });
<                     }, this);
<                 }
<                 ////////////////////// High Chart Start ////////////////////////
<                 this.clearFilter();
<                 this.filter([{
<                     property: "device_type_id",
<                     value: fullRecord.device_type_id
<                 }, {
<                     fn: function(record){
<                         return record.get('display_type') != "Display Table" && record.get('display_type') != "Display Configuration - Table";
<                     },
<                     scope: this
<                 }]);
<                 if(this.getCount() > 0){
<                     this.each(function(record){
<                         var display_type = record.get("display_type"),
<                         display_name = record.get("display_name"),
<                         name = record.get("name"),
<                         id = record.get("id"),
<                         leftaxis = record.get("leftaxis"), 
<                         rightaxis = record.get("rightaxis"),
<                         highchart,
<                         series = [],
<                         column = [];
<                         column.push({
<                             header: 'Date',
<                             width: 150,
<                             sortable: true,
<                             dataIndex: 'date'
<                         });
<                         registersStore.on("load", function(){
<                             this.clearFilter();
<                             this.filter([{
<                                 property: "register_group_id",
<                                 value: id
<                             }, {
<                                 fn: function(record){
<                                     return record.get('units') == leftaxis || record.get('units') == rightaxis;
<                                 },
<                                 scope: this
<                             }]);
<                             if(this.getCount() > 0){
<                                 this.each(function(record){
<                                     var name = record.get("tag"), id = record.get("rid"), unit = record.get("units");
<                                     var hash = {
<                                         name: name,
<                                         color: getRandomColor(),
<                                         unit: unit
<                                     };
<                                     if(unit == leftaxis){
<                                         hash.type = getGraphDisplayType(display_type, 'left');
<                                         hash.yField = 'R'+id;
<                                     }
<                                     else if(unit == rightaxis){
<                                         hash.type = getGraphDisplayType(display_type, 'right');
<                                         hash.yAxis = 1;
<                                         hash.yField = 'R'+id;
<                                     }
<                                     series.push(hash);
<                                     column.push({
<                                         header: name+" ("+unit+")",
<                                         dataIndex: 'R'+id,
<                                         width: 100,
<                                         align: 'right',
<                                         sortable: true
<                                     });
<                                 }, this);
<                                 ///////Start new Store for Graphical Data(Which Register Group display type is 'Map')///////////
<                                 //var graphValueStore = new Ext.data.Store({
<                                 //    recordType: registersValueStore.recordType
<                                 //});
<                                 //var records = [];
<                                 //registersValueStore.on("load", function(){
<                                 //    this.each(function(r){
<                                 //        records.push(r.copy());
<                                 //    });
<                                 //    graphValueStore.add(records);
<                                 //});
<                                 ///////End new Store for Graphical Data //////////
<                                 highchart = new Ext.ux.HighChart({
<                                     series: series,
<                                     layout: 'fit',
<                                     store: registersValueStore,
<                                     animShift: true,
<                                     xField: 'date',
<                                     id: 'pressuresChart-'+devicetypeIndex+"-"+id,
<                                     loadMask: true,
<                                     chartConfig: {
<                                         chart: {
<                                             marginBottom: 150,
<                                             zoomType: 'xy'
<                                         },
<                                         title: {
<                                             text: 'Pressure - Boies',
<                                             x: -20
<                                         },
<                                         xAxis: [{
<                                             labels: {
<                                                 y: 20,
<                                                 rotation: -90,
<                                                 align: 'right'
<                                             }
<                                         }],
<                                         yAxis: [{
<                                             labels: {
<                                                 formatter: function(){
<                                                     return this.value;
<                                                 },
<                                                 style: {
<                                                     color: '#89A54E'
<                                                 }
<                                             },
<                                             title: {
<                                                 text: leftaxis||'',
<                                                 style: {
<                                                     color: '#89A54E'
<                                                 }
<                                             },
<                                             plotLines: [{
<                                                 value: 0,
<                                                 width: 1,
<                                                 color: '#808080'
<                                             }]
<                                         }, {
<                                             title: {
<                                                 text: rightaxis||'',
<                                                 style: {
<                                                     color: '#4572A7'
<                                                 }
<                                             },
<                                             labels: {
<                                                 formatter: function() {
<                                                     return this.value;
<                                                 },
<                                                 style: {
<                                                     color: '#4572A7'
<                                                 }
<                                             },
<                                             opposite: true
<                                         }],
<                                         tooltip: {
<                                             formatter: function(){
<                                                 return '<b>'+this.series.name+'</b><br/>'+this.x+'<br/>'+this.y+' '+this.series.options.unit;
<                                             },
<                                             style: {
<                                                 padding: '15px'
<                                             }
<                                         },
<                                         legend: {
<                                             layout: 'vertical',
<                                             align: 'left',
<                                             x: 70,
<                                             verticalAlign: 'top',
<                                             y: 00,
<                                             floating: true,
<                                             backgroundColor: Highcharts.theme.legendBackgroundColor || '#FFFFFF'
<                                         }
<                                     }
<                                 });
<                                 ///////Start new Store for Numaric Data(Which Register Group display type is 'Map')///////////
<                                 var numaricValueStore = new Ext.data.Store({
<                                     recordType: registersValueStore.recordType
<                                 });
<                                 var records = [];
<                                 registersValueStore.on("load", function(){
<                                     this.each(function(r){
<                                         records.push(r.copy());
<                                     });
<                                     numaricValueStore.add(records);
<                                 });
<                                 ///////End new Store for Numaric Data //////////
<                                 var grid = new Ext.grid.GridPanel({
<                                     autoWidth: true,
<                                     height: 400,
<                                     border: false,
<                                     id: 'pressuresNumaricGrid-'+devicetypeIndex+"-"+id,
<                                     stripeRows: true,
<                                     columnLines: true,
<                                     store: numaricValueStore,
<                                     loadMask: true,
<                                     columns: column
<                                 });
<                                 var startDate = new Ext.form.DateField({
<                                     id: 'startdt'+devicetypeIndex+"-"+id,
<                                     name: 'start',
<                                     format: 'Y-m-d',
<                                     editable: false,
<                                     listeners: {
<                                         'select': function(){
<                                             if(endDate.getValue() != ''){
<                                                 if(this.getValue() > endDate.getValue()){
<                                                     Ext.Msg.alert('Error!', 'Range from must be less than Range to.');
<                                                     this.setValue(endDate.getValue());
<                                                 }
<                                             }
<                                             endDate.setMinValue(startDate.getValue());
<                                         }
<                                     }
<                                 });
<                                 var endDate = new Ext.form.DateField({
<                                     id: 'enddt'+devicetypeIndex+"-"+id,
<                                     name: 'start',
<                                     format: 'Y-m-d',
<                                     editable: false,
<                                     listeners: {
<                                         'select': function(){
<                                             if(startDate.getValue() != ''){
<                                                 if(this.getValue() < startDate.getValue()){
<                                                     Ext.Msg.alert('Error!', 'Range to must not be less than Range from.');
<                                                     this.setValue(startDate.getValue());
<                                                 }
<                                             }
<                                         }
<                                     }
<                                 });
<                                 pan.insert(pan.items.length-1, {
<                                     title: display_name || name,
<                                     style: {
<                                         marginBottom: '10px'
<                                     },
<                                     /*tools:[{
<                                         id: 'refresh-'+devicetypeIndex+"-"+id,
<                                         qtip:'Refresh this data',
<                                         handler: function(){
<                                             var tab = Ext.getCmp("pressuresTabPanel-"+devicetypeIndex+"-"+id).getActiveTab();
<                                             if(tab.title == "Graphical Data"){
<                                                 var graphStore = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id).store;
<                                                 graphStore.load({
<                                                     params: {
<                                                         "start": '',
<                                                         "end": ''
<                                                     }
<                                                 });
<                                                 startDate.setValue();
<                                                 endDate.setValue();
<                                             }
<                                             else{
<                                                 Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store.reload();
<                                                 startDate.setValue();
<                                                 endDate.setValue();
<                                             }
<                                         }
<                                     }],*/
<                                     tbar:[{
<                                         xtype: 'label',
<                                         text: 'Date range from',
<                                         style: 'margin: 0 5px 0 5px;'
<                                     }, startDate, {
<                                         xtype: 'label',
<                                         text: 'to',
<                                         style: 'margin: 0 5px 0 5px;'
<                                     }, endDate, {
<                                         xtype: 'button',
<                                         text: 'Search',
<                                         id: 'search-'+devicetypeIndex+"-"+id,
<                                         iconCls: "search-icon",
<                                         style: 'margin: 0 5px 0 5px;',
<                                         handler: function(){
<                                             var start = startDate.getValue();
<                                             var end = endDate.getValue();
<                                             if(!start && !end){
<                                                 Ext.Msg.alert("Error!", "Date range can't be blank.");
<                                             }
<                                             else{
<                                                 var rec;
<                                                 var tab = Ext.getCmp("pressuresTabPanel-"+devicetypeIndex+"-"+id).getActiveTab();
<                                                 if(tab.title == "Graphical Data"){
<                                                     var graph = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id);
<                                                     graph.store.clearFilter();
<                                                     if(start && end){
<                                                         graph.store.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") >= start.format("Y-m-d") && rec.format("Y-m-d") <= end.format("Y-m-d");
<                                                         });
<                                                         graph.refresh();
<                                                     }
<                                                     else if(start && !end){
<                                                         graph.store.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") >= start.format("Y-m-d");
<                                                         });
<                                                         graph.refresh();
<                                                     }
<                                                     else if(!start && end){
<                                                         graph.store.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") <= end.format("Y-m-d");
<                                                         });
<                                                         graph.refresh();
<                                                     }
<                                                 }
<                                                 else{
<                                                     var numaricStore = Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store;
<                                                     numaricStore.clearFilter();
<                                                     if(start && end){
<                                                         numaricStore.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") >= start.format("Y-m-d") && rec.format("Y-m-d") <= end.format("Y-m-d");
<                                                         });
<                                                     }
<                                                     else if(start && !end){
<                                                         numaricStore.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") >= start.format("Y-m-d");
<                                                         });
<                                                     }
<                                                     else if(!start && end){
<                                                         numaricStore.filterBy(function(record, id){
<                                                             rec = Date.parseDate(record.get("date"), "Y-m-d H:i:s");
<                                                             return rec.format("Y-m-d") <= end.format("Y-m-d");
<                                                         });
<                                                     }
<                                                 }
<                                             }
<                                         }
<                                     }, {
<                                         xtype:'button',
<                                         iconCls:'reloadIcon',
<                                         text:'Refresh',
<                                         id: 'tbar-refresh-'+devicetypeIndex+"-"+id,
<                                         handler: function(){
<                                             var tab = Ext.getCmp("pressuresTabPanel-"+devicetypeIndex+"-"+id).getActiveTab();
<                                             if(tab.title == "Graphical Data"){
<                                                 var graph = Ext.getCmp("pressuresChart-"+devicetypeIndex+"-"+id);
<                                                 graph.store.clearFilter();
<                                                 graph.refresh();
<                                                 startDate.setValue();
<                                                 endDate.setValue();
<                                             }
<                                             else{
<                                                 var numaricStore = Ext.getCmp("pressuresNumaricGrid-"+devicetypeIndex+"-"+id).store;
<                                                 numaricStore.clearFilter();
<                                                 startDate.setValue();
<                                                 endDate.setValue();
<                                             }
<                                         }
<                                     }, {
<                                         xtype: "button",
<                                         id: 'grid-excel-button-'+devicetypeIndex+"-"+id,
<                                         text: "Export to Excel",
<                                         iconCls: "export-icon",
<                                         handler: function(){
<                                             document.location='data:application/vnd.ms-excel;base64,' +Base64.encode(grid.getExcelXml());
<                                         }
<                                     }],
<                                     items: new Ext.TabPanel({
<                                         activeTab: 0,
<                                         border: true,
<                                         id: "pressuresTabPanel-"+devicetypeIndex+"-"+id,
<                                         items:[{
<                                             title: "Graphical Data",
<                                             items: highchart
<                                         },{
<                                             title: "Numerical Data",
<                                             items: grid
<                                         }]
<                                     })
<                                 });
<                                 pan.doLayout();
<                             }
<                         });
<                     });
<                 }
<             ////////////////////// High Chart End //////////////////////////
<             }
<         });
---
>         app.components.charts.DeviceHighChart.superclass.initComponent.apply(this, arguments);
574c1261
<     dataRefresh: function() {
---
>     dataRefresh:function() {
575a1263
>             //params:{ColumnCnt:4},
603c1291
< 
---
>         
diff -r --exclude=.svn v550/public/javascripts/app/forms/EditRegisterGroup.js v537/public/javascripts/app/forms/EditRegisterGroup.js
73c73
<                             case 7: case 8: case 9: case 10: case 11:
---
>                             case 6: case 7: case 8: case 9: case 10: case 11:
diff -r --exclude=.svn v550/public/javascripts/app/forms/EditReporting.js v537/public/javascripts/app/forms/EditReporting.js
419c419
<                     if(deviceTypeCombo && arr && arr.length > 0){
---
>                     if(deviceTypeCombo && arr && arr.length > 0){                        
422d421
<                         deviceTypeCombo.store.load();
423a423
>                             alert("deviceTypeCombo");
427a428
>                             console.dir(registerGroupCombo);
428a430
>                                 // alert('RG outside');
431a434
>                                     // alert('RG');
461a465,466
>                                     // alert(registerCombo);
>                                     
462a468
>                                         //alert('Register Outside');
464a471
>                                             //alert('Register');
diff -r --exclude=.svn v550/public/javascripts/app/forms/RegisterGroup.js v537/public/javascripts/app/forms/RegisterGroup.js
70c70
<                             case 7: case 8: case 9: case 10: case 11:
---
>                             case 6: case 7: case 8: case 9: case 10: case 11:
diff -r --exclude=.svn v550/public/javascripts/application.js v537/public/javascripts/application.js
996,997c996,997
<     getDataNotes: function(cfg){
<         if(this.dataStores.notes === undefined){
---
>     getDataNotes:function(cfg) {
>         if(this.dataStores.notes === undefined) {
1050,1051c1050,1051
<     getRegisterGroups: function(){
<         if(this.dataStores.registerGroupsStore === undefined){
---
>     getRegisterGroups: function() {
>         if(this.dataStores.registerGroupsStore === undefined) {
1081,1155d1080
<     getRegisterGroupsHighChart: function(){
<         this.dataStores.registerGroupsStoreHighChart = new Ext.data.JsonStore({
<             fields:[{
<                 name: 'id',
<                 type: 'int'
<             }, {
<                 name: 'device_type_id',
<                 type: 'int'
<             }, {
<                 name: 'name',
<                 type: 'string'
<             }, {
<                 name: 'display_name',
<                 type: 'string'
<             }, {
<                 name: 'display_type',
<                 type: 'string'
<             }, {
<                 name: 'leftaxis',
<                 type: 'string'
<             }, {
<                 name: 'rightaxis',
<                 type: 'string'
<             }],
<             proxy: new Ext.data.HttpProxy({
<                 url: '/list-of-register-groups-for-highchart',
<                 method: 'GET'
<             }),
<             autoLoad: true
<         });
<         return(this.dataStores.registerGroupsStoreHighChart);
<     },
< 
<     getDataRegistersForHighChart: function(did){
<         this.dataStores.registersforhighchart = new app.data.RESTfulJsonStore({
<             id: 'ds_registers_for_highchart',
<             url: '/data-to-display',
<             sortInfo: {
<                 field: 'id',
<                 direction: 'ASC'
<             },
<             baseParams: {
<                 device_id: did
<             }
<         });
<         return(this.dataStores.registersforhighchart);
<     },
< 
<     getRegistersForHighChart: function(){
<         this.dataStores.registersStoreForHighChart = new Ext.data.JsonStore({
<             fields:[{
<                 name: 'id',
<                 type: 'int'
<             }, {
<                 name: 'rid',
<                 type: 'int'
<             }, {
<                 name: 'register_group_id',
<                 type: 'int'
<             }, {
<                 name: 'tag',
<                 type: 'string'
<             }, {
<                 name: 'units',
<                 type: 'string'
<             }],
<             proxy: new Ext.data.HttpProxy({
<                 url: '/list-of-registers-for-highchart',
<                 method: 'GET'
<             }),
<             autoLoad: true
<         });
<         return(this.dataStores.registersStoreForHighChart);
<     },
< 
1930,1964c1855
< };
< 
< function getGraphDisplayType(v, axis){
<     v = v.replace('Display Graph - ', '');
<     v = v.split('/');
<     switch(axis){
<         case 'left':
<             v = getDisplayType(v[0]);
<             break;
<         default:
<             if(v.length > 1){
<                 v = getDisplayType(v[1]);
<             }
<             else{
<                 v = getDisplayType(v[0]);
<             }
<             
<     }
<     return v;
< }
< 
< function getDisplayType(v){
<     switch(v){
<         case 'Bar':
<             v = 'column';
<             break;
<         default:
<             v = v.toLowerCase();
<     }
<     return v;
< }
< // Random Color generator
< function getRandomColor(){
<     return '#' + ('000000' + Math.floor(Math.random()*0xFFFFFF).toString(16)).substr(-6);
< }
\ No newline at end of file
---
> };
\ No newline at end of file
